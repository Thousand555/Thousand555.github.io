[{"title":"linux-全志V3s移植uboot kernel rootfile记录","path":"/2024/03/14/linux-全志V3s移植uboot-kernel-rootfile记录/","content":"环境及材料准备系统环境安装好相应的ubuntu系统环境，这里为ubuntu 20.04系统： .uplpoimnzkki{zoom:67%;} 材料准备开发板为licheepi的V3s开发板，资料如下： 链接：https://pan.baidu.com/s/1iXh4KYYlQPyKgEGASLdnNA 提取码：byga 交叉编译器安装下载材料中的交叉编译器”gcc-linaro-6.3.1-2017.02-x86_64_arm-linux-gnueabihf.tar.xz“到ubuntu系统中，解压并添加环境变量： 12345678910111213#创建文件夹V3scd ~sudo mkdir V3smv gcc-linaro-6.3.1-2017.02-x86_64_arm-linux-gnueabihf.tar.xz V3s#解压cd V3ssudo tar -vxf gcc-linaro-6.3.1-2017.02-x86_64_arm-linux-gnueabihf.tar.xz#进入环境变量配置文件sudo vim /etc/profile #或者sudo vim ~/.bashrc#添加环境变量，在文件最后添加 export PATH=$PATH:~/V3s/gcc-linaro-6.3.1-2017.02-x86_64_arm-linux-gnueabihf/bin#更新系统环境变量：sudo source /etc/profile\t#或者sudo source ~/.bashrc uboot编译下载材料中的uboot源码”u-boot-v3s-current.zip”到系统中： 123456789101112131415161718#解压mv u-boot-v3s-current.zip ~/V3scd ~/V3sunzip u-boot-v3s-current.zipmv u-boot-v3s-current uboot#选择配置文件，配置ubootcd ubootmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- LicheePi_Zero_defconfig#或者选择带显示功能的配置文件make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- LicheePi_Zero_800x480LCD_defconfig make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- LicheePi_Zero_480x272LCD_defconfig#添加其他uboot配置，先安装ncursessudo apt updatesudo apt install build-essentialsudo apt install libncurses5-devmake ARCH=arm menuconfig #进入配置界面后，添加网络功能，如下图：#添加开发板网口网络支持 .dzmelpvpmeqi{zoom:67%;} 1234#编译make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-#或者计算编译时间，并输入编译信息到build.log日志文件中time make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- 2&gt;&amp;1 | tee build.log 成功得到”u-boot-sunxi-with-spl.bin”编译文件： .tngmydhmfwlw{zoom:67%;} kernel编译下载“linux-zero-5.2.y.zip”文件到系统中： 123456789101112#解压mv linux-zero-5.2.y.zip V3scd ~/V3sunzip linux-zero-5.2.y.zip#选择配置文件，配置kernelcd linux-zero-5.2.ymake ARCH=arm licheepi_zero_defconfig#添加其他配置make ARCH=arm menuconfig #使能linux logo显示，如图 .bdybdyzqwskb{zoom:67%;} 1234make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j8 #“-jx”的x为CPU的核心个数，可以查看当前CPU情况进行选择，也可以删掉-jx，但编译速度慢#或者使用time统计编译时间time make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j8 编译得到“zImage”镜像文件和”sun8i-v3s-licheepi-zero.dtb”设备树文件： .jllrbqywefye{zoom:67%;} 1234#&quot;sun8i-v3s-licheepi-zero.dtb&quot;设备树文件目录：cd ~/V3s/linux-zero-5.2.yls arch/arm/boot/dts/#如图： .cowgebntfmec{zoom:67%;} rootfs制作下载”buildroot-2017.08.tar.gz“文件到系统中： 12345678#解压mv buildroot-2017.08.tar.gz ~/V3scd ~/V3star xvf buildroot-2017.08.tar.gz#配置cd buildroot-2017.08make menuconfig 依次配置“Target options”： .kelomcpbldko{zoom:67%;} 配置“Toolchain”编译工具链，注意交叉编译器的位置为“~&#x2F;V3s&#x2F;gcc-linaro-6.3.1-2017.02-x86_64_arm-linux-gnueabihf”，和图片里面不太一样： .uuauojgjzpzb{zoom:67%;} .psjumbqbehvg{zoom:67%;} .picpiqazhwbo{zoom:67%;} 系统信息设置，设置系统主机名字、系统横幅信息、root管理员用户密码、时区选择等： .tbotamdhlatk{zoom:67%;} .ughyxyfxsksi{zoom:67%;} .saooyuhgytii{zoom:67%;} 添加ssh功能方便后续进行“网络根文件系统启动”，如图： .wjsrhzojnkvt{zoom:67%;} 12#编译time make 编译后的rootfs位于“~&#x2F;V3s&#x2F;buildroot-2017.08&#x2F;output”，target目录中为解压后的根文件系统，images目录中为压缩好的“rootfs.tar”根文件系统压缩包： .wkitvipygofc{zoom:67%;} SD卡烧录准备一个tf卡，利用tf卡读卡器，插入到ubuntu中进行烧录。 tf卡分区123#查看tf卡的设备sudo fdisk -l#若ubuntu只有一个盘且无分区(sdb1…表示sd卡中的分区)，则设备为/dev/sdb .eiwbrwpcaodd{zoom:67%;} 1234567891011#进入tf卡设备sudo fdisk /dev/sdb#删除分区：d#添加分区：n#查看分区：p#保存操作：w#注：修改后，需要用w保存修改。#按p检查是否存在原分区，有的话按d删除#删除原分区后，按n新建两个分区，第一个分区大小根据zImage和设备树文件等大小，这里设置32M，起始地址为2048；第二个分区用尽剩余容量。#按w写入修改后的信息，再按p检查结果是否有误，最后按q退出 原始格式： 第一部分：扇区起始地址2，大小为20478个扇区，格式为原始格式，不用分区进行格式化，用于存放uboot；(1扇区&#x3D;512Bytes，2048扇区&#x3D;1MB，uboot镜像约为400K，该空间足够写入该镜像。) 分区1： 第二部分：扇区起始地址2048，大小为32M，分区格式为FAT，用于存放内核和设备树； 分区2： 第三部分：大小为SD卡剩余的空间，分区格式为Ext3或Et4，用于存放rootfs也就是文件系统。 .mbnwfupgvvcg{zoom:50%;} .ucvvuwxkwsol{zoom:50%;} .zawucvhloujn{zoom:50%;} 格式化1234567#若分区有挂载则取消挂载sudo umount /dev/sdb1sudo umount /dev/sdb2#第一个分区格式化为fatsudo mkfs.vfat /dev/sdb1#第二个分区格式化为ext4sudo mkfs.ext4 /dev/sdb2 .xbwlpjqmzyxw{zoom: 67%;} 写入镜像文件123#写入uboot，将uboot写入到sd卡8k偏移处(必须8K偏移)。cd ~/V3s/ubootsudo dd if=u-boot-sunxi-with-spl.bin of=/dev/sdb bs=1024 seek=8 注意观察写入的速率大小，若非常大有可能写入不正确： .nkpiegmqvgdu{} .jeypjmfswjlh{zoom:67%;} 写入kernel文件123456789#挂载第一个分区mkdir /mnt/v3ssudo mount /dev/sdb1 /mnt/v3ssudo cp ~/V3s/linux-zero-5.2.y/arch/arm/boot/zImage /mnt/v3ssudo cp ~/V3s/linux-zero-5.2.y/arch/arm/boot/dts/sun8i-v3s-licheepi-zero.dtb /mnt/v3s#或者选择这个设备树 cp sun8i-v3s-licheepi-zero-dock.dtb /mnt/v3s#卸载分区并同步写入数据sudo umount /mnt/v3ssync .hqvmmlvzupjv{zoom:67%;} 写入根文件系统1234567#挂载第二个分区cd /mntsudo mount /dev/sdb2 /mnt/v3ssudo cp ~/V3s/buildroot-2017.08/output/images/rootfs.tar /mnt/v3ssudo tar -xf /mnt/v3s/rootfs.tar -C /mnt/v3ssudo umount /mnt/v3ssync .rltqufnrvoqz{zoom:67%;} 系统一般启动插入内存卡到开发板上，上电启动，利用USB转串口工具，进入uboot界面进行设置： uboot启动参数设置123456789101112131415#一、boot启动方式#1、设置boot启动方式的bootcmd加载命令setenv bootcmd &quot;setenv bootm_boot_mode sec;load mmc 0:1 0x41000000 zImage;load mmc 0:1 0x41800000 sun8i-v3s-licheepi-zero-dock.dtb;bootz 0x41000000 - 0x41800000;&quot;#除了linux5.2版本外，其他内核不要使用以下屏幕参数，否则设备树会卡死，暂不使用，linux中已有fb0设备（有simplefb和drm两种显示模式），不用额外配置setenv bootcmd &quot;setenv bootm_boot_mode sec;load mmc 0:1 0x41000000 zImage;load mmc 0:1 0x41800000 sun8i-v3s-licheepi-zero-with-480x272-lcd.dtb;bootz 0x41000000 - 0x41800000;&quot;setenv bootcmd &quot;setenv bootm_boot_mode sec;load mmc 0:1 0x41000000 zImage;load mmc 0:1 0x41800000 sun8i-v3s-licheepi-zero-with-800x480-lcd.dtb;bootz 0x41000000 - 0x41800000;&quot;#2、设置传递给linux内核的参数setenv bootargs &quot;console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 earlyprintk rw vt.global_cursor_default=0&quot;setenv bootargs &quot;console=tty0 console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 earlyprintk rw &quot;#保存saveenv#3、启动boot 12345678910111213#二、bootz启动方式#设置传递给linux内核的参数setenv bootargs &quot;console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 earlyprintk rw vt.global_cursor_default=0&quot;setenv bootargs &quot;console=tty0 console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 earlyprintk rw &quot;#保存saveenv#tftp加载至内存再启动（需设置好tftp服务器，提前复制编译好的文件到tftp服务器目录）#tftp DRAM地址 [[tftp服务IP地址]:文件名]tftp 0x41000000 zImagetftp 0x41800000 sun8i-v3s-licheepi-zero-dock.dtbbootz 0x41000000 - 0x41800000 以上参数设置后，即可进入kernel，运行rootfs根文件系统： linux系统配置网络配置uboot启动kernel进入linux系统后，系统网络无法正常通信。 修改&#x2F;etc&#x2F;init.d&#x2F;rcS的启动文件，添加内容： 1234ifconfig eth0 upifconfig eth0 192.168.123.66 netmask 255.255.255.0route add default gw 192.168.123.1echo &quot;nameserver 192.168.123.1&quot; &gt; /etc/resolv.conf 重启后，ping www.baidu.com ，网络正常。 ssh配置uboot启动kernel进入linux系统后，ssh无法正常工作。 修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件，修改对应的内容为： 12PermitRootLogin yesPermitEmptyPasswords yes 重启后，ssh连接正常。 系统远程启动——网络根文件系统​\t前面系统启动后，运行的是内存卡中第2分区中的rootfs，在平常测试中，需要添加或者修改rootfs，为了方便相关操作，可以使kernel从网络远程运行根文件系统（即本地ubuntu系统的某个文件夹目录）。 TFTP和NFS工具准备TFTP工具TFTP是一个基于UDP协议实现的用于在客户机和服务器之间进行简单文件传输的协议，适用于开销不大、不复杂的应用场合。TFTP协议专门为小文件传输而设计，只能从服务器上获取文件，或者向服务器写入文件，不能列出目录，也不能进行认证。 这里使用TFTP，主机Ubuntu为TFTP服务器，开发板为客户端，让主机和开发板进行文件传输，如kernel镜像文件传输。 12#安装服务器、客户端和守护进程sudo apt install tftp-hpa tftpd-hpa xinetd 修改&#x2F;etc&#x2F;default&#x2F;tftpd-hpa： 1sudo vi /etc/default/tftpd-hpa 1234TFTP_USERNAME=&quot;tftp&quot;TFTP_DIRECTORY=&quot;/home/thousand/tftpboot&quot;TFTP_ADDRESS=&quot;:69&quot;TFTP_OPTIONS=&quot;-l -c -s&quot; TFTP配置文件，使用命令建立文件，向文件中写入如下代码： 1sudo vi /etc/xinetd.d/tftp 12345678910111213service tftp&#123; socket_type = dgram protocol = udp wait = yes user = root server = /usr/sbin/in.tftpd server_args = -s ~/tftpboot/ -c disable = no per_source = 11 cps = 100 2 flags = IPv4&#125; 其中，server_args设置的&#x2F;tftpboot目录是tftp服务器的目录，TFTP客户端就是从这个目录里获取文件的。使用命令”mkdir &#x2F;tftpboot”建立TFTP服务器的目录。然后设置&#x2F;tftpboot的访问权限为777。 12mkdir ~/tftpbootsudo chmod 777 ~/tftpboot 最后重启tftpd-hpa、xinetd服务。输入命令。 123sudo /etc/init.d/xinetd reloadsudo /etc/init.d/xinetd restartsudo service tftpd-hpa restart 测试： 12345678#先在tftpboot目录建新文件，随便输入内容cd ~/tftpbootvi tftp_test#打开另外一个目录，输入：tftp 127.0.0.1get tftp_test#输入q退出tftp NFS工具注意：Ubuntu版本太高，NFS版本也高，uboot的版本一般是V2，需要修改Ubuntu进行兼容，参考：https://blog.csdn.net/beetleinv/article/details/114916323 1234567891011121314151617181920212223242526272829303132#安装nfs服务器sudo apt install nfs-kernel-server rpcbind#查看是否启动sudo systemctl status nfs-server#创建nfs分享目录cd ~mkdir nfssudo chmod 777 nfs#查看共享的目录showmount -e#配置，打开配置文件sudo vi /etc/exports#最后一行添加下面的内容#这个登录root账户会出错失败：#/home/thousand/nfs *(rw,sync,no_subtree_check)#使用这个：/home/thousand/nfs *(rw,sync,no_root_squash,no_subtree_check) #/home/nfs_share： 是nfs服务端的共享路径。 #*： 表示所有网段都可以访问（可以指定具体的ip）。 #rw： 挂接指定共享目录的客户端具有读写权限。 #sync： 资料同步写入内存和硬盘. #no_root_squash： 客户机用root访问该共享文件夹时，不映射root用户。 #no_subtree_check：不检查父目录的权限。#重启nfs服务sudo /etc/init.d/nfs-kernel-server restart kernel编译配置12345678910111213141516171819在内核编译配置阶段，添加以下功能配置：make ARCH=arm menuconfig1、配置网络部分，主要是使能CONFIG_IP_PNP以在2中能够看到Root file system on NFS选项\tNetworking support Networking options TCP/IP networking IP: kernel level autoconfiguration [*] IP: DHCP support [*]IP: BOOTP support2、配置开启nfs服务\tFile systems ---&gt; Network File Systems ---&gt; &lt;*&gt; NFS client support [*] NFS client support for NFS version 3 [*] NFS client support for the NFSv3 ACL protocol extension [*] NFS client support for NFS version 4 (EXPERIMENTAL) [*] NFS client support for NFSv4.1 (DEVELOPER ONLY) [*] Root file system on NFS .yuphnotlobxr{zoom:67%;} 启动如果使用网络根文件系统，需要创建网络根文件系统放到nfs目录中，再修改bootargs变量。 12345678910111213141516171819#uboot网络配置setenv ipaddr 192.168.123.66 #设置开发板IP地址setenv netmask 255.255.255.0 #子网掩码配置setenv serverip 192.168.123.166 #设置tftp服务IP地址setenv gatewayip 192.168.123.1 #设置网关setenv ethaddr b8:ae:1d:01:00:00 #设置网卡mac地址，48bit 的地址不和其他重复即可#uboot设置网络根文件系统启动参数setenv bootargs &#x27;console=ttyS0,115200 root=/dev/nfs nfsroot=192.168.123.166:/home/thousand/licheepi/nfs/rootfs,proto=tcp rw ip=192.168.123.66:192.168.123.166:192.168.123.1:255.255.255.0::eth0:off&#x27;setenv bootargs &#x27;console=tty0 console=ttyS0,115200 root=/dev/nfs nfsroot=192.168.123.166:/home/thousand/licheepi/nfs/rootfs,proto=tcp rw ip=192.168.123.66:192.168.123.166:192.168.123.1:255.255.255.0::eth0:off&#x27;#内存卡linux启动setenv bootcmd &quot;setenv bootm_boot_mode sec;load mmc 0:1 0x41000000 zImage;load mmc 0:1 0x41800000 sun8i-v3s-licheepi-zero-dock.dtb;bootz 0x41000000 - 0x41800000;&quot;saveenvboot#tftp网络启动tftp 41800000 sun8i-v3s-licheepi-zero-with-480x272-lcd.dtbtftp 41000000 zImagebootz 0x41000000 - 0x41800000 相关问题解决uboot相关DTC设备树编译工具版本太旧报错”Your dtc is too old,please upgrade to dtc 1.4 or newer“，设备树编译器版本过旧，需更新。 .dtqemgnvslua{zoom:67%;} 更新命令： 1sudo apt-get install device-tree-compiler .hjbwtmrdvbot{zoom:67%;} 缺少python解析器报错”.&#x2F;tools&#x2F;binman&#x2F;binman:not found“，没有python解析器 .urxlllikopas{zoom:67%;} 安装python： 1sudo apt-get install python 缺少bc工具报错”bc: not found“，缺少bc工具 .ewficocmxnks{zoom:67%;} 安装bc： 1sudo apt-get install bc 正常输出： .fqiojxwzeufq{zoom:67%;} linux内核相关缺少相关库文件报错”flex: not found“，缺少相关库文件 .fjitcednsvyn{zoom:67%;} 安装相关库： 12sudo apt-get install flexsudo apt-get install bison 报错” fatal error: openssl&#x2F;bio.h: No such file or directory“,缺少文件 .jyhdxnhhylkx{zoom:67%;} 添加文件： 1sudo apt-get install libssl-dev 根文件系统相关编译ssh出错.kovurvwuuoti{zoom:67%;} 解决： 123456cd buildroot-2017.08cd output/build/host-m4-1.4.18/sed -i &#x27;s/IO_ftrylockfile/IO_EOF_SEEN/&#x27; lib/*.cecho &quot;#define _IO_IN_BACKUP 0x100&quot; &gt;&gt; lib/stdio-impl.hmake 登录nfs挂载的根文件系统出错问题：“nfs挂载rootfs login: root Login incorrect” .iwyuhshyzjbz{zoom:67%;} 主机配置nfs服务器需添加“no_root_squash”参数： 1234567#配置，打开配置文件sudo vi /etc/exports#最后一行添加下面的内容##/home/thousand/nfs *(rw,sync,no_subtree_check)/home/thousand/nfs *(rw,sync,no_root_squash,no_subtree_check)#重启nfs服务sudo /etc/init.d/nfs-kernel-server restart 系统启动阶段相关屏幕无输出显示这个是因为编译时，没有选着对应屏幕驱动的配置，比如 1234#编译Uboot时选择了LicheePi_Zero_defconfig，该配置没有适配屏幕make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- LicheePi_Zero_defconfig#编译linux内核使用了licheepi_zero_defconfig配置make ARCH=arm licheepi_zero_defconfig lichee的uboot配置文件放在u-boot&#x2F;confgs文件目录下面，名称为 LicheePi_Zero_480x272LCD_defconfig LicheePi_Zero_800x480LCD_defconfig LicheePi_Zero_defconfig改用LicheePi_Zero_800x480LCD_defconfig配置后，uboot启动屏幕正常输出。 lichee的linux配置文件放在linux&#x2F;arch&#x2F;arm&#x2F;configs文件命令下，名称为 licheePi_zero_defconfig可能由于官方给的这个文件没有适配屏幕，故Linux启动后屏幕无输出。 传递给Linux的bootargs参数若如下设置，会导致没有选择输出到屏幕中： 1setenv bootargs &quot;console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 earlyprintk rw vt.global_cursor_default=0&quot; 修改成如下参数，屏幕正常输出信息： 1setenv bootargs &quot;console=ttyS0,115200 panic=5 console=tty0 rootwait root=/dev/mmcblk0p2 earlyprintk rw vt.global_cursor_default=0&quot; 不过，此时串口端无法看到登录项，也不能输入，无法登录系统。屏幕上可以看到登录项，或许可以插入键盘到开发板上输入登录信息。 .ipblogevwpxu{zoom:67%;} 然后把”console&#x3D;ttys0”移到前面就可以了，不过这时变成屏幕看不到登录选项了，确实奇怪： 1setenv bootargs &quot;console=tty0 console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 earlyprintk rw vt.global_cursor_default=0&quot; 以下是网上看到的，由于usb口需供电，故暂时没法插键盘测试： 此时编译的uboot是可以LCD和串口同时输出log的，但是LCD端还不是控制台无法使用USB键盘进行控制，需要做以下改动来实现多个console控制台： 1vi /etc/inittab 将原有的console注释掉，改为ttyS0和tty0，ttyS0是USB键盘输入，tty0就是正常输出输入 123#console::respawn:-/bin/sh ttyS0::respawn:-/bin/sh tty0::respawn:-/bin/sh 调节LCD背光12345678910#lcd背光控制ls sys/class/backlight/backlight/#查看最大亮度等级cat /sys/class/backlight/backlight/max_brightness#调节亮度echo 1 &gt; /sys/class/backlight/backlight/brightness#关闭背光echo 1 &gt; /sys/class/backlight/backlight/bl_power#打开背光电源echo 0 &gt; /sys/class/backlight/backlight/bl_power .wgfladpmftbp{zoom:67%;} LCD启动卡住123#使用以下屏幕参数的设备树会卡死，暂不使用，setenv bootcmd &quot;setenv bootm_boot_mode sec;load mmc 0:1 0x41000000 zImage;load mmc 0:1 0x41800000 sun8i-v3s-licheepi-zero-with-480x272-lcd.dtb;bootz 0x41000000 - 0x41800000;&quot;setenv bootcmd &quot;setenv bootm_boot_mode sec;load mmc 0:1 0x41000000 zImage;load mmc 0:1 0x41800000 sun8i-v3s-licheepi-zero-with-800x480-lcd.dtb;bootz 0x41000000 - 0x41800000;&quot; .yoqunprkimyn{zoom:67%;} 由于linux中sun8i-v3s.dtsi已默认有lcd的设备结点，生成的内核已有fb0设备，故这里不用额外配置lcd，不使用带有“-with-480x272-lcd.dtb”的设备树文件： .mvimjyboncby{zoom:67%;} .feoaluohorim{zoom:67%;} 12345#fb0测试#现象为黑屏cat /dev/zero&gt; /dev/fb0 #屏幕会随机花屏cat /dev/urandom &gt; /dev/fb0 无eth0网口设备设备树修改修改“修改文件&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;sun8i-v3s-licheepi-zero.dts”设备树文件： aliases节点内添加如下内容：1ethernet0 = &amp;emac; 在末尾添加如下内容，启用emac外设123456&amp;emac &#123; phy-handle = &lt;&amp;int_mii_phy&gt;; phy-mode = &quot;mii&quot;; allwinner,leds-active-low; status = &quot;okay&quot;;&#125;; menuconfig 修改这里主要是针对linux5.2版本的linux，之前的版本（linux4.10，4.13，4.14）都默认勾选了这个配置： 12make ARCH=arm menuconfig make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j2 .rguhrpqojflp{zoom:67%;} 网卡信息修改制作好的文件系统，需要修改Net相关描述，在&#x2F;etc&#x2F;network&#x2F;interfaces 下添加： 12345678910#静态IPauto eth0iface eth0 inet staticaddress 192.168.123.88netmask 255.255.255.0gateway 192.168.123.1#动态IPauto eth0iface eth0 inet dhcp 也可以修改&#x2F;etc&#x2F;init.d&#x2F;rcS的启动文件，添加： 12345ifconfig eth0 upifconfig eth0 192.168.123.66 netmask 255.255.255.0route add default gw 192.168.123.1echo &quot;nameserver 192.168.123.1&quot; &gt; /etc/resolv.conf 重启开发板，使用reboot指令重启。直接按开发板的复位键，可能会导致刚刚的修改丢失不被保存。 .qgywtbxaokxg{zoom:67%;} 对应的PC主机 ,Windows 可能需要关闭防火墙或者改出入站规则 ，不然ping 不上 ssh传输出错运行重新编译的文件系统后，如果网络ip和之前设置的一样，容易出现其“指纹”和保存的不一样的问题，发出警告不予传输： .lbwochiwqqph{zoom:67%;} 解决办法，打开用户目录下面的.ssh&#x2F;known_hosts文件，然后删除连过这个ip地址的记录，那么下次连接的时候会认为是第一次连接，所以会重新保存指纹。 1echo &quot;&quot; &gt; ./.ssh/known_hosts .xderdgseyyhe{zoom:67%;}","tags":["linux驱动"]},{"title":"ARM体系结构","path":"/2024/03/12/ARM体系结构/","content":"概述内容主要参考“arm体系结构与编程”第2版，这里的体系架构主要以ARM9为例进行说明。 ARM含义ARM有三种含义：ARM公司、ARM处理器、ARM技术 ARM公司是专门从事基于RISC技术的芯片设计开发的公司。作为知识产权供应商，ARM本身并不直接从事芯片生产，而是转让设计许可，由合作公司生产各具特色的芯片。世界各大半导体生产商从ARM公司购买其设计的ARM微处理器核，根据各自的不同应用领域，加入适当的外围电路，从而形成自己的ARM微处理器芯片进入市场。目前，全世界有几十家大的半导体公司都使用ARM公司的授权，因此既使得ARM技术获得更多的第三方工具、制造、软件的支持特，又使整个系统成本降低，使产品更容易进入市场并被消费者接受，更具有竞争力。 ARM知识产权授权用户非常众多，其中包括世界顶级的半导体和系统公司。 ARM处理器：ARM处理器是由ARM公司设计和授权的处理器架构。 架构特点：ARM处理器采用精简指令集计算机（RISC）架构，设计目标是提供高性能和低功耗的处理解决方案。ARM处理器的指令集简洁高效，优化了指令执行和内存访问，提供高效的数据处理和控制能力。 处理器系列：ARM公司设计了多个系列的处理器架构，以满足不同应用需求。其中包括： ARM Cortex-A系列：面向高性能计算和多任务处理，适用于智能手机、平板电脑、云服务器等需要较强处理能力的应用。 ARM Cortex-R系列：专为实时应用设计，提供可靠的实时性能和可预测性，适用于汽车电子、工业控制和嵌入式系统等领域。 ARM Cortex-M系列：针对低功耗和资源受限的嵌入式应用，提供紧凑的处理能力和实时性能，适用于物联网设备、传感器节点等。 ARM技术是由ARM公司开发和推广的一系列技术和解决方案，涵盖了处理器架构、系统设计、软件开发和生态系统支持等方面。 ARM体系架构版本迄今为止，ARM体系结构已经定义了多个版本，从低版本到高版本，ARM体系的指令集功能不断扩大。同时，各版本中还有一些变种，这些变种定义了该版本指令集中不同的功能。ARM处理器系列中的各种处理器，所采用的实现技术各不相同，性能差别很大，应用场合也有所不同，但是只要它们支持相同的ARM体系版本，基于它们的应用软件将是兼容的。 ARM的版本分为两类，一个是内核版本，一个处理器版本。内核版本也就是ARM架构，如ARMv1、ARMv2、ARMv3、ARMv4、ARMv5、ARMv6、ARMv7、ARMv8等。处理器版本也就是ARM处理器，如ARM1、ARM9、ARM11、ARM Cortex-A（A7、A9、A15），ARM Cortex-M（M1、M3、M4）、ARM Cortex-R，这个也是通常意义上所指的ARM版本。 ARM体系结构的版本 内核（架构）版本 时间 处理器版本 ARMv1 1985 ARM1 ARMv2 1986 ARM2、ARM3 ARMv3 1990 ARM6、ARM7（没有MMU）（引入了Thumb指令集，该指令集使用16位指令，用于提高代码密度。） ARMv4 1993 StrongARM、ARM7TDMI、ARM9TDMI（支持分页内存管理等） ARMv5 1998 ARM7EJ、ARM9、ARM9E、ARM10E、XScale（协处理器支持、增强的分页内存管理和增强的Thumb指令集） ARMv6 2001 ARM11、ARM Cortex-M（引入了Thumb-2指令集，该指令集能够同时支持16位和32位指令。） ARMv7 2004 ARM Cortex-A（应用程序处理器）、ARM Cortex-R（实时处理器）、ARM Cortex-M（微控制器）（32位ARM处理器体系结构的最高版本，从这时开始ARM公司以Cortex来重新命名处理器） ARMv8 2011 ARM Cortex-A30、ARM Cortex-A50、ARM Cortex-A70等（引入了AArch64，开始支持64位指令集） ARMv9 2021 ARM Cortex-A510 &#x2F; A710 &#x2F; A715&#x2F;X2&#x2F;X3…等 常见SoC型号的架构及处理器版本示例： SoC型号 处理器版本 架构版本 三星s3c2440&#x2F;S3C2410 ARM9系列 ARMv4 全志F1C100s&#x2F;F1C200s ARM9系列 ARMv5 三星S3C6440 ARM11系列 ARMv6 i.MX6ULL全志A20&#x2F;A31&#x2F;V3s Cortex-A7 ARMv7 全志A10苹果A4 Cortex-A8 ARMv7 高通骁龙815全志H616瑞芯微RK3528 Cortex-A53&#x2F;A57 ARMv8 瑞芯微RK3399 Cortex-A53+A72 ARMv8 麒麟9000骁龙888、天玑8100 Cortex-A77&#x2F;A78 ARMv8 骁龙8Gen1 Cortex-X2+A710+A510 ARMv9 ARM体系结构特点主要参考”ARM体系结构与编程_唐振明“。 ARM 内核采用精简指令集结构（Reduced Instruction Set Computer，RISC）体系结构。RISC技术产生于 20 世纪 70 年代，其设计目标是创建一种能以每个时钟周期执行一条指令的速度很快的计算机。RISC 的设计重点在于降低由硬件执行的指令复杂度，这是因为软件比硬件容易提供更大的灵活性和更高的智能。与其相对的传统复杂指令级计算机（CISC）则更侧重于硬件执行指令的功能性，这使 CISC 指令变得更复杂。 .qipmlfvejqyi{zoom:67%;} （1）Load&#x2F;Store 体系结构 Load&#x2F;Store 体系结构也称为寄存器&#x2F;寄存器体系结构或者 RR 系统结构。在这类结构中，操作数和运算结果不是通过主存储器直接取回而是借用大量标量和矢量寄存器来取回的。与 RR体系结构相反，还有一种存储器&#x2F;存储器体系结构，在这种体系结构中，源操作数的中间值和最后的运算结果是直接从主存储器中取回的，这类结构的缩写符号是 SS 体系结构。 （2）固定长度指令 固定长度指令使得机器译码变得比较容易。由于指令简单，需要更多的指令来完成相同的工作，但是开发快速的价格低廉的存储器装置使得可以更快地执行较大代码段（大量指令成为可能）。 （3）硬联控制 RISC 机以硬联控制指令为特点，而 CISC 的微代码指令则相反。与用 CISC（常常是可变长度的）指令集来使处理器的语义效率最大相反，简单指令往往容易被机器翻译。像 CISC 那样通过执行较少指令来完成工作未必省时，因为还要包括微代码译码所需要的时间。因此，由硬件实现指令在执行时间方面提供了更好的平衡。除此之外，还节省了芯片上用于存储微代码的空间并且消除了翻译微代码所需的时间。 （4）流水线 指令处理过程被拆分为几个更小的、能够被流水线并行执行的单元。在理想情况下，流水线每周期前进一步，可获得更高的吞吐率。 （5）寄存器 RICS 处理器拥有更多的通用寄存器，每个寄存器都可存放数据或地址。寄存器可为所有的数据操作提供快速的局部存储访问。 ARM处理器的运行模式 运行模式 描述 用户模式(User,usr) 正常程序执行的模式 快速中断模式(FIQ,fq) 用于高速数据传输和通道处理 外部中断模式(IRQ,irq) 用于通常的中断处理 特权模式(Supervisor,sve) 供操作系统使用的一种保护模式 数据访问中止模式(Abort,abt) 用于虚拟存储及存储保护 未定义指令中止模式(Undefined,und) 用于支持通过软件仿真硬件的协处理器 系统模式(System,sys) 用于运行特权级的操作系统任务 除了用户模式之外的其他6种处理器模式称为特权模式（Privileged Modes）。在这些模式下，程序可以访问所有的系统资源，也可以任意地进行处理器模式的切换。其中，除系统模式外，其他5种特权模式又称为异常模式。 处理器模式可以通过软件控制进行切换，也可以通过外部中断或异常处理过程进行切换。大多数的用户程序运行在用户模式下。这时，应用程序不能够访问一些受操作系统保护的系统资源。应用程序也不能直接进行处理器模式的切换。当需要进行处理器模式切换时，应用程序可以产生异常处理，在异常处理过程中进行处理器模式的切换。这种体系结构可以使操作系统控制整个系统的资源。 当应用程序发生异常中断时，处理器进入相应的异常模式。在每一种异常模式中都有一组寄存器，供相应的异常处理程序使用，这样就可以保证在进入异常模式时，用户模式下的寄存器（保存了程序运行状态）不被破坏。 系统模式并不是通过异常过程进入的，它和用户模式具有完全一样的寄存器。但是系统模式属于特权模式，可以访问所用的系统资源，也可以直接进行处理器模式切换。它主要供操作系统任务使用。通常操作系统的任务需要访问所有的系统资源，同时该任务仍然使用用户模式的寄存器组，而不是使用异常模式下相应的寄存器组，这样可以保证当异常中断发生时任务状态不被破坏。 ARM寄存器ARM处理器共有37个寄存器。其中包括： ●　31个通用寄存器，包括程序计数器（PC）在内。这些寄存器都是32位寄存器。 ●　6个状态寄存器。这些寄存器都是32位寄存器，但目前只使用了其中12位。 ARM处理器共有7种不同的处理器模式，在每一种处理器模式中有一组相应的寄存器组。任意时刻（也就是任意的处理器模式下），可见的寄存器包括15个通用寄存器（R0～R14）、一个或两个状态寄存器及程序计数器（PC）。在所有的寄存器中，有些是各模式共用的同一个物理寄存器；有一些寄存器是各模式自己拥有的独立的物理寄存器。 .gqhcdroeudsx{zoom:67%;} 通用寄存器 通用寄存器可以分为下面3类： ●　未备份寄存器（Unbanked Registers），包括R0～R7。 ●　备份寄存器（Banked Registers），包括R8～R14。 ●　程序计数器PC，即R15。 1．未备份寄存器 未备份寄存器包括R0～R7。对于每一个未备份寄存器来说，在所有的处理器模式下指的都是同一个物理寄存器。在异常中断造成处理器模式切换时，由于不同的处理器模式使用相同的物理寄存器，可能造成寄存器中数据被破坏。未备份寄存器没有被系统用于特别的用途，任何可采用通用寄存器的应用场合都可以使用未备份寄存器。 2．备份寄存器 对于备份寄存器R8～R12来说，每个寄存器对应两个不同的物理寄存器。例如，当使用快速中断模式下的寄存器时，寄存器R8和寄存器R9分别记作R8_fiq、R9_fiq；当使用用户模式下的寄存器时，寄存器R8和寄存器R9分别记作R8_usr、R9_usr等。在这两种情况下，使用的是不同的物理寄存器。系统没有将这几个寄存器用于任何特殊用途，但是当中断处理非常简单，仅仅使用R8～R14寄存器时，FIQ处理程序可以不必执行保存和恢复中断现场的指令，从而可以使中断处理过程非常迅速。 对于备份寄存器R13和R14来说，每个寄存器对应6个不同的物理寄存器，其中的一个是用户模式和系统模式共用的；另外的5个对应于其他5种处理器模式。 3．程序计数器R15 程序计数器R15又被记作PC。它虽然可以作为一般的通用寄存器使用，但是有一些指令在使用R15时有一些特殊限制。当违反了这些限制时，该指令执行的结果将是不可预料的。 程序状态寄存器 CPSR（当前程序状态寄存器）可以在任何处理器模式下被访问。它包含了条件标志位、中断禁止位、当前处理器模式标志以及其他的一些控制和状态位。 每一种处理器模式下都有一个专用的物理状态寄存器，称为SPSR（备份程序状态寄存器）。当特定的异常中断发生时，这个寄存器用于存放当前程序状态寄存器的内容。在异常中断程序退出时，可以用SPSR中保存的值来恢复CPSR。 由于用户模式和系统模式不是异常中断模式，所以它们没有SPSR。当在用户模式或系统模式中访问SPSR时，将会产生不可预知的结果。 CPSR的格式如下所示，SPSR格式与CPSR格式相同 ARM指令集ARM处理器使用ARM指令集和Thumb指令集。 ARM指令集包含32位的指令，提供了丰富的功能和灵活性。 Thumb指令集支持16位的指令，用于提高代码密度和节省存储空间。 最新的ARM处理器还支持AArch64执行状态，提供了64位的指令集，称为AArch64指令集。 Thumb指令集 Thumb指令集是ARM架构中的一种16位指令集，旨在提高代码密度和降低存储器需求。 Thumb指令集与ARM指令集的区别： 指令长度：ARM指令集的指令长度为32位，而Thumb指令集的指令长度为16位。由于指令长度减少了一半，Thumb指令集可以在同样的存储空间下存储更多的指令，从而提高了代码密度。 寄存器数量：ARM指令集有16个通用寄存器，每个寄存器都是32位的。而Thumb指令集有8个通用寄存器，每个寄存器都是16位的。这意味着在Thumb指令集中，可以同时使用的寄存器数量更少，因此需要更频繁地进行数据的加载和存储。 指令集功能：ARM指令集提供了更多的功能和灵活性，支持更多的数据处理操作和复杂的指令流控制。相比之下，Thumb指令集在设计上更加简化，提供了基本的数据操作和简单的控制流指令，牺牲了一些高级功能和复杂的指令。 性能：由于Thumb指令集的指令长度较短，指令的执行时间通常也较短。因此，在某些情况下，Thumb指令集可以提供更高的执行速度和更低的功耗。 ARM指令集 ARM指令集可以分为6类，即跳转指令、数据处理指令、程序状态寄存器（PSR）传输指令、Load&#x2F;Store指令、协处理器指令和异常中断产生指令。 ARM体系的异常中断在ARM体系中，通常有以下3种方式控制程序的执行流程： ●　在正常程序执行过程中，每执行一条ARM指令，程序计数寄存器（PC）的值加4个字节；每执行一条Thumb指令，程序计数寄存器（PC）的值加两个字节。整个过程是按顺序执行的。 ●　通过跳转指令，程序可以跳转到特定的地址标号处执行，或者跳转到特定的子程序处执行。其中，B指令用于执行跳转操作；BL指令在执行跳转操作的同时，保存子程序的返回地址；BX指令在执行跳转操作的同时，根据目标地址的最低位可以将程序状态切换到Thumb状态；BLX指令执行3个操作，跳转到目标地址处执行，保存子程序的返回地址，根据目标地址的最低位可以将程序状态切换到Thumb状态。 ●　当异常中断发生时，系统执行完当前指令后，将跳转到相应的异常中断处理程序处执行。在异常中断处理程序执行完成后，程序返回到发生中断的指令的下一条指令处执行。在进入异常中断处理程序时，要保存被中断的程序的执行现场，在从异常中断处理程序退出时，要恢复被中断的程序的执行现场。 ARM中异常中断的种类 .pksinvmvjlwp{zoom:67%;} ARM处理器对异常中断的响应过程 （1）保存处理器当前状态、中断屏蔽位以及各条件标志位。这是通过将当前程序状态寄存器CPSR的内容保存到将要执行的异常中断对应的SPSR寄存器中实现的。各异常中断有自己的物理SPSR寄存器。 （2）设置当前程序状态寄存器CPSR中相应的位。包括设置CPSR中的位，使处理器进入相应的执行模式；设置CPSR中的位，禁止IRQ中断，当进入FIQ模式时，禁止FIQ中断。 （3）将寄存器lr_mode设置成返回地址。 （4）将程序计数器（PC）设置成该异常中断的中断向量地址，从而跳转到相应的异常中断处理程序处执行。 从异常中断处理程序中返回过程 （1）恢复被中断的程序的处理器状态，即将SPSR_mode寄存器内容复制到CPSR中。 （2）返回到发生异常中断的指令的下一条指令处执行，即把lr_mode寄存器的内容复制到程序计数器PC中。 中断和异常的区别 中断（Interrupt）是由外部设备或事件引发的中断请求，用于打断正在执行的指令流，让处理器转移到中断服务程序（Interrupt Service Routine，ISR）来处理该事件。中断通常由外部设备的信号触发，例如定时器溢出、外部设备的输入等。 异常（Exception）是由程序运行过程中的异常情况引发的事件，如无效的指令、访问越界、除以零等。异常会导致处理器从当前模式切换到异常模式，并执行异常处理程序（Exception Handler）来处理异常情况。 异常处理过程 当发生异常时，处理器会保存当前的上下文信息（如寄存器状态、程序计数器等），以便稍后恢复执行。 处理器会根据异常类型和优先级判断是否响应该异常，如果需要响应，则会切换到异常模式，并跳转到相应的异常处理程序。 异常处理程序会执行相关的异常处理逻辑，如错误处理、状态恢复、错误日志记录等。 在处理完异常后，处理器会从保存的上下文信息中恢复状态，并回到原来的模式和指令流中，继续执行。 ARM 流水线处理器按照一系列步骤来执行每一条指令。典型计算机系统的步骤如下: （1）从存储器读取指令（fetch）； （2）译码以鉴别它是属于哪一条指令（dec）； （3）从指令中提取指令的操作数（这些操作数往往存在于寄存器中）（reg）； （4）将操作数进行组合以得到结果或存储器地址（ALU）； （5）如果需要，则访问存储器以存储数据（mem）； （6）将结果写回到寄存器堆（res）。 并不是所有的指令都需要其中的每一个步骤，但是，多数指令需要其中的多个步骤。这些步骤往往使用不同的硬件功能，如果一条指令不是在前一条指令结束之前就开始，那么在每一步骤内处理器只有少部分的硬件在使用。 有一个明显的方法可以改善硬件资源的使用率和处理器的吞吐量，这就是当前一条指令结束之前就开始执行下一条指令，也就是通常所说的流水线（Pipeline）技术。 流水线是RISC 处理器执行指令时采用的机制。使用流水线，可在取下一条指令的同时译码和执行其他指令，从而加快执行的速度。 管道流水线 ARM处理器的管道流水线是一种用于提高指令执行效率的技术。它将指令执行过程划分为多个阶段，并在每个阶段引入寄存器，使得多条指令可以同时在不同的阶段执行。这样可以提高处理器的吞吐量，使得指令能够更快地完成执行。 流水线中的不同阶段包括： 取指令（Instruction Fetch） 译码（Instruction Decode） 执行（Execute） 访存（Memory Access） 写回（Write Back） 通过流水线技术，当一条指令执行进入流水线后，后续的指令可以继续进入流水线的不同阶段，从而实现指令级并行（Instruction-Level Parallelism）。这可以提高处理器的效率，使得多条指令可以在同一时间段内重叠执行。 ARM存储器ARM 处理器内核广泛应用于嵌入式系统和其他行业应用中。为了适应不同系统的需要，ARM 采用了灵活多样的存储管理体系。从平板式内存映射到灵活方便的 MMU 内存管理单元，用户可以根据自己的需要使用不同的存储管理策略。在 ARM 体系结构中可使用的存储管理策略包括以下几种： （1）多类型的存储单元（可以使用 SDRAM、FLASH 等）； （2）Caches； （3）写缓存； （4）虚拟内存地址 另外，内存映射 I&#x2F;O 机制可以使开发者灵活、方便地增加大量外设。可以通过下面的几种方法实现对存储系统的管理： （1）使能 Cache，加快存储器的访问速度； （2）启动虚拟地址到物理地址的映射； （3）使用“域管理”策略，对存储单元的访问进行保护； （4）对 I&#x2F;O 映射地址空间的访问加以限制。 ARM的Cache和MMU Cache：Cache是一种位于处理器和主存之间的高速存储器，用于存储最近使用的数据和指令。它的作用是通过预先将数据和指令复制到快速的缓存中，加快对数据的访问速度，减少对主存的访问次数。Cache的工作原理是基于局部性原理，即程序和数据的访问往往呈现出一定的空间局部性和时间局部性。Cache通过存储最近使用的数据块，以便在后续的访问中快速提供数据，减少了对主存的延迟。 MMU:MMU是负责管理虚拟内存和物理内存之间映射关系的组件。它允许操作系统和应用程序使用虚拟内存地址，而不必关心物理内存的实际分配情况。MMU的主要功能包括地址转换和内存保护。它通过将虚拟地址转换为物理地址，实现了对虚拟内存的透明访问。MMU还负责内存保护，通过访问控制和权限设置，确保不同应用程序之间的内存隔离和安全性。MMU还支持内存映射技术，例如页面映射（Page Mapping）和段映射（Segment Mapping），以及虚拟内存的分页和分段机制，实现了灵活的内存管理和资源分配。 ARM的大端和小端字节序 字节序（Byte Order）指的是多字节数据在内存中存储的顺序。在ARM体系结构中，字节序对于处理器和操作系统的开发者来说是重要的。不同的字节序可能会影响数据的读取和存储，特别是在跨平台和数据交换的情况下。 大端字节序：在大端字节序中，多字节数据的高位字节存储在低地址处，而低位字节存储在高地址处。这意味着多字节数据的字节顺序与其在内存中的存储顺序相同。 小端字节序：在小端字节序中，多字节数据的低位字节存储在低地址处，而高位字节存储在高地址处。这意味着多字节数据的字节顺序与其在内存中的存储顺序相反。 I&#x2F;O 管理ARM 系统完成 I&#x2F;O 功能的标准方法是使用存储器映射 I&#x2F;O。这种方法使用特定的存储器地址。当从这些地址加载或向这些地址存储时，它们提供 I&#x2F;O 功能。某些 ARM 系统中也可能存在直接存储器访问（Direct Memory Access，DMA）硬件。 外围设备（如串行线控制器）中包含一些寄存器。在存储器映射系统中，这些寄存器就像特定地址的存储器一样（在其他的系统组织中，I&#x2F;O 功能可能与存储器件有不同的寻址空间）。如串行线控制器可能有以下 5 种寄存器： （1）发送数据寄存器（只写）：写入这个位置的数据被送往串行线。 （2）接收数据寄存器（只读）：保存从串行线送来的数据。 （3）控制寄存器（读&#x2F;写）：设置数据速率，管理 RTS（请求发送）和其他类似信号。 （4）中断使能寄存器（读&#x2F;写）：控制中断的硬件事件。 （5）状态寄存器（读&#x2F;写）：指示读数据是否有效，写缓存是否满等。 其他来源：https://eight-legged-essay.yangpaopao.space/arm/basic.html ARM的协处理器（Coprocessor）和向量处理器（NEON） 协处理器（Coprocessor）：协处理器是ARM处理器的一个可选扩展，用于执行特定的处理任务。它是与主处理器并行工作的一个辅助处理器。协处理器可以执行一些特定的指令和操作，例如浮点运算、加密算法、信号处理等。通过将特定任务分配给协处理器，ARM处理器可以提高处理性能和效率。 向量处理器（NEON）：NEON是ARM处理器中的一个向量处理器扩展，用于高效执行并行的多媒体和信号处理操作。NEON提供了一组特定的指令和寄存器，用于同时处理多个数据元素，例如矢量、矩阵和像素数据。这使得ARM处理器能够高效地执行诸如图像处理、音频处理、视频编解码等计算密集型任务。 ARM体系结构中的Thumb-2技术 Thumb-2是ARM体系结构中的一种指令集技术，旨在提高代码密度和性能。它结合了Thumb指令集（16位指令）和ARM指令集（32位指令），使得处理器能够同时执行16位和32位指令，以适应不同的应用场景。Thumb-2技术提供了以下优势： 代码密度改善：Thumb-2指令集中的16位指令相比于32位指令更加紧凑，占用更少的存储空间。通过使用Thumb-2指令集，可以显著减少程序的代码大小。这对于存储有限的设备（如嵌入式系统）和带宽受限的环境非常有益。 性能提升：Thumb-2技术不仅仅是为了减少代码大小，还针对性能进行了优化。Thumb-2指令集中的某些16位指令具有与对应的32位指令相似的执行效率。这意味着通过使用Thumb-2指令集，可以在减少代码大小的同时保持较高的执行效率。 兼容性和灵活性：Thumb-2技术兼容先前的Thumb指令集，因此可以无缝地与使用Thumb指令集编写的现有代码进行交互。此外，处理器可以在Thumb状态和ARM状态之间进行快速切换，使得开发人员可以根据需要选择最适合的指令集。","tags":["arm"]},{"title":"cpp常用STL记录","path":"/2024/03/11/cpp-常用STL记录/","content":"概述参考：https://zhuanlan.zhihu.com/p/582795495 C++ STL是C++标准库的一部分，不等于C++标准库。 C++ 标准库C++ 标准库可以分为两部分： 标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。 面向对象类库： 这个库是类及其相关函数的集合。 标准函数库标准函数库分为以下几类： 输入&#x2F;输出 I&#x2F;O 字符串和字符处理 数学 时间、日期和本地化 动态分配 其他 宽字符函数 面向对象类库标准的 C++ 面向对象类库定义了大量支持一些常见操作的类，比如输入&#x2F;输出 I&#x2F;O、字符串处理、数值处理。面向对象类库包含以下内容： 标准的 C++ I&#x2F;O 类 String 类 数值类 STL 容器类 STL 算法 STL 函数对象 STL 迭代器 STL 分配器 本地化库 异常处理类 杂项支持库 STL 标准模板库STL (Standard Template Library)，即标准模板库，是一个具有工业强度的，高效的C++程序库。 C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。 C++ 标准模板库的核心包括以下三个组件： 组件 描述 容器（Containers） 一种数据结构，容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。 算法（Algorithms） 它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。 迭代器（iterators） 迭代器用于遍历对象集合的元素，提供了访问容器中对象的方法。 除此之外，还有仿函数（Functor）、适配器（Adaptor）、分配器（allocator）。 STL容器参考：https://zhuanlan.zhihu.com/p/564057584 说明STL中的容器有顺序性容器、关联容器、容器适配器。容器类自动申请和释放内存，无需new和delete操作。 （1）顺序性容器（Sequence containers） 每个元素都有固定位置，取决于插入时机和地点，和元素值无关，vector、deque、list； Vector：将元素置于一个动态数组中加以管理，可以随机存取元素（用索引直接存取），数组尾部添加或移除元素非常快速，但是在中部或头部安插元素比较费时； Deque：是“double-ended queue”的缩写，可以随机存取元素（用索引直接存取），数组头部和尾部添加或移除元素都非常快速，但是在中部或头部安插元素比较费时； List：双向链表，不提供随机存取（按顺序走到需存取的元素，O(n)），在任何位置上执行插入或删除动作都非常迅速，内部只需调整一下指针； 容器 简介说明 vector 可变大小数组。相当于数组，可动态构建，支持随机访问，无头插和尾插，仅支持inset插入，除尾部外的元素删除比较麻烦。但使用最为广泛 deque 双端队列。支持头插、删，尾插、删，随机访问较vector容器来说慢,但对于首尾的数据操作比较方便 list 双向循环链表。使用起来很高效，对于任意位置的插入和删除都很快，在操作过后，以后指针、迭代器、引用都不会失效 forward_list 单向链表。只支持单向访问，在链表的任何位置进行插入&#x2F;删除操作都非常快 array 固定数组。vector的底层即为array数组，它保存了一个以严格顺序排列的特定数量的元素 （2）关联式容器（Associated containers） 元素位置取决于特定的排序准则，和插入顺序无关，set、multiset、map、multimap等。 Set&#x2F;Multiset：内部的元素依据其值自动排序，Set内的相同数值的元素只能出现一次，Multisets内可包含多个数值相同的元素，内部由二叉树实现，便于查找； Map&#x2F;Multimap：Map的元素是成对的键值&#x2F;实值，内部的元素依据其值自动排序，Map内的相同数值的元素只能出现一次，Multimaps内可包含多个数值相同的元素，内部由二叉树实现，便于查找； 容器 简介说明 set&#x2F;mutliset 集合&#x2F;多重集合。对于set，在使用insert插入元素时，已插入过的元素不可重复插入，这正好符合了集合的互异性，在插入完成显示后，会默认按照升序进行排序，对于multiset，可插入多个重复的元素 map&#x2F;mutlimap 映射&#x2F;多重映射。二者均为二元关联容器（在构造时需要写两个参数类型，前者对key值，后者对应value值），因为有两个参数，因此在插入元素的时候需要配合对组pair进行插入，具体见深入详解 （3）容器适配器（Congtainer adapters） 容器 简介说明 stack 堆栈。其原理是先进后出（FILO），其底层容器可以是任何标准的容器适配器，默认为deque双端队列 queue 队列。其原理是先进先出（FIFO），只有队头和队尾可以被访问，故不可有遍历行为，默认也为deque双端队列 pirority_queue 优先队列。它的第一个元素总是它所包含的元素中优先级最高的，就像数据结构里的堆，会默认形成大堆，还可以使用仿函数来控制生成大根堆还是生成小根堆，若没定义，默认使用vector容器 对于 stack 堆栈，在我们日常生活中类似于坐地铁、电梯； 对于 deque 队列，在我们日常生活中类似于排队打饭； 对于 pirority_queue，因为其本质是堆，可以考虑解决一些贪心问题； 顺序性容器vector12#include &lt; vector&gt; using namespace std; 12345678910111213141516171819202122232425262728293031323334353637383940411.构造函数vector():创建一个空vectorvector(int nSize):创建一个vector,元素个数为nSizevector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为tvector(const vector&amp;):复制构造函数vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中2.增加函数void push_back(const T&amp; x):向量尾部增加一个元素Xiterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素xiterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素xiterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据3.删除函数iterator erase(iterator it):删除向量中迭代器指向元素iterator erase(iterator first,iterator last):删除向量中[first,last)中元素void pop_back():删除向量中最后一个元素void clear():清空向量中所有元素4.遍历函数reference at(int pos):返回pos位置元素的引用reference front():返回首元素的引用reference back():返回尾元素的引用iterator begin():返回向量头指针，指向第一个元素iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置reverse_iterator rbegin():反向迭代器，指向最后一个元素reverse_iterator rend():反向迭代器，指向第一个元素之前的位置5.判断函数bool empty() const:判断向量是否为空，若为空，则向量中无元素6.大小函数int size() const:返回向量中元素的个数int capacity() const:返回当前向量张红所能容纳的最大元素值int max_size() const:返回最大可允许的vector元素数量值7.其他函数void swap(vector&amp;):交换两个同类型向量的数据void assign(int n,const T&amp; x):设置向量中第n个元素的值为xvoid assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素 二维数组两种定义方法 12345678910111213141516171819202122232425262728293031323334353637//方法一int main()&#123; int N=5, M=6; vector&lt;vector&lt;int&gt; &gt; obj(N); //定义二维动态数组大小5行 for(int i =0; i&lt; obj.size(); i++)//动态二维数组为5行6列，值全为0 &#123; obj[i].resize(M); &#125; for(int i=0; i&lt; obj.size(); i++)//输出二维动态数组 &#123; for(int j=0;j&lt;obj[i].size();j++) &#123; cout&lt;&lt;obj[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;&quot; &quot;; &#125; return 0;&#125;//方法二int main()&#123; int N=5, M=6; vector&lt;vector&lt;int&gt; &gt; obj(N, vector&lt;int&gt;(M)); //定义二维动态数组5行6列 for(int i=0; i&lt; obj.size(); i++)//输出二维动态数组 &#123; for(int j=0;j&lt;obj[i].size();j++) &#123; cout&lt;&lt;obj[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;&quot; &quot;; &#125; return 0;&#125; deque1234567891011121314151617#include &lt;deque&gt; // 头文件deque&lt;type&gt; deq; // 声明一个元素类型为type的双端队列quedeque&lt;type&gt; deq(size); // 声明一个类型为type、含有size个默认值初始化元素的的双端队列quedeque&lt;type&gt; deq(size, value); // 声明一个元素类型为type、含有size个value元素的双端队列quedeque&lt;type&gt; deq(mydeque); // deq是mydeque的一个副本deque&lt;type&gt; deq(first, last); // 使用迭代器first、last范围内的元素初始化deqdeque&lt;int&gt; deq;deq[ ]：用来访问双向队列中单个的元素。deq.front()：返回第一个元素的引用。deq.back()：返回最后一个元素的引用。deq.push_front(x)：把元素x插入到双向队列的头部。deq.pop_front()：弹出双向队列的第一个元素。deq.push_back(x)：把元素x插入到双向队列的尾部。deq.pop_back()：弹出双向队列的最后一个元素。 特点： 支持随机访问，即支持[ ]以及at()，但是性能没有vector好。 可以在内部进行插入和删除操作，但性能不及list。 deque两端都能够快速插入和删除元素，而vector只能在尾端进行。 deque的元素存取和迭代器操作会稍微慢一些，因为deque的内部结构会多一个间接过程。 deque迭代器是特殊的智能指针，而不是一般指针，它需要在不同的区块之间跳转。 deque可以包含更多的元素，其max_size可能更大，因为不止使用一块内存。 deque不支持对容量和内存分配时机的控制。 在除了首尾两端的其他地方插入和删除元素，都将会导致指向deque元素的任何pointers、references、iterators失效。不过，deque的内存重分配优于vector，因为其内部结构显示不需要复制所有元素。 deque的内存区块不再被使用时，会被释放，deque的内存大小是可缩减的。不过，是不是这么做以及怎么做由实际操作版本定义。 deque不提供容量操作：capacity()和reverse()，但是vector可以。 list1234567891011121314151617181920212223242526272829303132333435//list定义和初始化list&lt;int&gt;lst1; //创建空listlist&lt;int&gt; lst2(5); //创建含有5个元素的listlist&lt;int&gt;lst3(3,2); //创建含有3个元素的listlist&lt;int&gt;lst4(lst2); //使用lst2初始化lst4list&lt;int&gt;lst5(lst2.begin(),lst2.end()); //同lst4//list常用操作函数Lst1.assign() 给list赋值Lst1.back() 返回最后一个元素Lst1.begin() 返回指向第一个元素的迭代器Lst1.clear() 删除所有元素Lst1.empty() 如果list是空的则返回trueLst1.end() 返回末尾的迭代器Lst1.erase() 删除一个元素Lst1.front() 返回第一个元素Lst1.get_allocator() 返回list的配置器Lst1.insert() 插入一个元素到list中Lst1.max_size() 返回list能容纳的最大元素数量Lst1.merge() 合并两个listLst1.pop_back() 删除最后一个元素Lst1.pop_front() 删除第一个元素Lst1.push_back() 在list的末尾添加一个元素Lst1.push_front() 在list的头部添加一个元素Lst1.rbegin() 返回指向第一个元素的逆向迭代器Lst1.remove() 从list删除元素Lst1.remove_if() 按指定条件删除元素Lst1.rend() 指向list末尾的逆向迭代器Lst1.resize() 改变list的大小Lst1.reverse() 把list的元素倒转Lst1.size() 返回list中的元素个数Lst1.sort() 给list排序Lst1.splice() 合并两个listLst1.swap() 交换两个listLst1.unique() 删除list中相邻重复的元素 关联式容器set&#x2F;multisetset中的元素即是键值又是实值，set不允许两个元素有相同的键值。不能通过set的迭代器去修改set元素，原因是修改元素会破坏set组织。当对容器中的元素进行插入或者删除时，操作之前的所有迭代器在操作之后依然有效。 set元素是排好序的，且默认为升序. set常用成员函数 123456789101112131415161718191. begin()--返回指向第一个元素的迭代器2. clear()--清除所有元素3. count()--返回某个值元素的个数4. empty()--如果集合为空，返回true5. end()--返回指向最后一个元素的迭代器6. equal_range()--返回集合中与给定值相等的上下限的两个迭代器7. erase()--删除集合中的元素8. find()--返回一个指向被查找到元素的迭代器9. get_allocator()--返回集合的分配器10. insert()--在集合中插入元素11. lower_bound()--返回指向大于（或等于）某值的第一个元素的迭代器12. key_comp()--返回一个用于元素间值比较的函数13. max_size()--返回集合能容纳的元素的最大限值14. rbegin()--返回指向集合中最后一个元素的反向迭代器15. rend()--返回指向集合中第一个元素的反向迭代器16. size()--集合中元素的数目17. swap()--交换两个集合变量18. upper_bound()--返回大于某个值元素的迭代器19. value_comp()--返回一个用于比较元素间的值的函数 map&#x2F;multimapmap和multimap都需要#include，唯一的不同是，map的键值key不可重复，而multimap可以，也正是由于这种区别，map支持[ ]运算符，multimap不支持[ ]运算符，在用法上没什么区别。 map中的元素是自动按Key升序排序，所以不能对map用sort函数； 12345678910111213141516171819202122232425262728293031//头文件#include&lt;map&gt; map&lt;int, string&gt; ID_Name; // 使用&#123;&#125;赋值是从c++11开始的，因此编译器版本过低时会报错，如visual studio 2012map&lt;int, string&gt; ID_Name = &#123; &#123; 2015, &quot;Jim&quot; &#125;, &#123; 2016, &quot;Tom&quot; &#125;, &#123; 2017, &quot;Bob&quot; &#125; &#125;;//基本操作函数begin() 返回指向map头部的迭代器clear(） 删除所有元素count() 返回指定元素出现的次数empty() 如果map为空则返回trueend() 返回指向map末尾的迭代器equal_range() 返回特殊条目的迭代器对erase() 删除一个元素find() 查找一个元素get_allocator() 返回map的配置器insert() 插入元素key_comp() 返回比较元素key的函数lower_bound() 返回键值&gt;=给定元素的第一个位置max_size() 返回可以容纳的最大元素个数rbegin() 返回一个指向map尾部的逆向迭代器rend() 返回一个指向map头部的逆向迭代器size() 返回map中元素的个数swap() 交换两个mapupper_bound() 返回键值&gt;给定元素的第一个位置value_comp() 返回比较元素value的函数 用insert插入pair数据 12345678910111213141516//数据的插入--第一种：用insert函数插入pair数据 #include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; map&lt;int, string&gt; mapStudent; mapStudent.insert(pair&lt;int, string&gt;(1, &quot;student_one&quot;)); mapStudent.insert(pair&lt;int, string&gt;(2, &quot;student_two&quot;)); mapStudent.insert(pair&lt;int, string&gt;(3, &quot;student_three&quot;)); map&lt;int, string&gt;::iterator iter; for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl; &#125; 用insert函数插入value_type数据 1234567891011121314151617//第二种：用insert函数插入value_type数据，下面举例说明 #include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; map&lt;int, string&gt; mapStudent; mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;)); mapStudent.insert(map&lt;int, string&gt;::value_type (2, &quot;student_two&quot;)); mapStudent.insert(map&lt;int, string&gt;::value_type (3, &quot;student_three&quot;)); map&lt;int, string&gt;::iterator iter; for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl; &#125; 用数组方式插入数据 1234567891011121314151617//第三种：用数组方式插入数据，下面举例说明 #include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; map&lt;int, string&gt; mapStudent; mapStudent[1] = &quot;student_one&quot;; mapStudent[2] = &quot;student_two&quot;; mapStudent[3] = &quot;student_three&quot;; map&lt;int, string&gt;::iterator iter; for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl; &#125; 以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是插入数据不了的，但是用数组方式就不同了，它可以覆盖以前该关键字对应的值. STL容器适配器stack&#x2F;deque适配器：是使一种事物的行为类似于另外一种事物行为的一种机制”，适配器对容器进行包装，使其表现出另外一种行为。例 如，stack&lt;int, vector &gt;实现了栈的功能，但其内部使用顺序容器vector来存储数据。（相当于是vector表现出 了栈的行为）。 标准库提供了三种顺序容器适配器：queue(FIFO队列)、priority_queue(优先级队列)、stack(栈) .kdsoxcrbwngk{zoom:67%;} 要使用适配器，需要加入一下头文件： 12#include &lt;stack&gt; //stack#include&lt;queue&gt; //queue、priority_queue pair 小技巧：使用typedef定义 typedef pair&lt;int, int&gt; PII 头文件 1#include&lt;utility&gt; 初始化 123//俩种方法初始化pair&lt;string,int&gt; p(&quot;hello&quot;,1);p = make_pair(&quot;hello&quot;,1); 取值 123p(&quot;hello&quot;,1);p.first; //第一个元素 =hellop.second; //第二个元素 = 1 嵌套（套娃） 123vector&lt; vector&lt;pair&lt;int, int&gt; &gt; &gt;//与vector结合【再写个vector结合即可】//套娃操作 用pair存储3个数据 pair&lt;int, pair&lt;int, int&gt;&gt; p(1,&#123;2,3&#125;); stack1234567stack&lt;int&gt; s;stack&lt; int, vector&lt;int&gt; &gt; stk; //覆盖基础容器类型，使用vector实现stks.empty(); //判断stack是否为空，为空返回true，否则返回falses.size(); //返回stack中元素的个数s.pop(); //删除栈顶元素，但不返回其值s.top(); //返回栈顶元素的值，但不删除此元素s.push(item); //在栈顶压入新元素item queue &amp; priority_queue123456789101112queue&lt;int&gt; q; //priority_queue&lt;int&gt; q;q.empty(); //判断队列是否为空q.size(); //返回队列长度q.push(item); //对于queue，在队尾压入一个新元素 //对于priority_queue，在基于优先级的适当位置插入新元素 //queue only:q.front(); //返回队首元素的值，但不删除该元素q.back(); //返回队尾元素的值，但不删除该元素 //priority_queue only:q.top(); //返回具有最高优先级的元素值，但不删除该元素 string参考：https://zhuanlan.zhihu.com/p/353910845 1、string构造函数 1234string();//创建一个空的字符串 例如: string str; string(const string&amp; str);//使用一个string对象初始化另一个string对象 string(const char* s);//使用字符串s初始化 string(int n, char c);//使用n个字符c初始化 2、string基本赋值操作 12345678string&amp; operator=(const char* s);//char*类型字符串 赋值给当前的字符串 string&amp; operator=(const string &amp;s);//把字符串s赋给当前的字符串 string&amp; operator=(char c);//字符赋值给当前的字符串 string&amp; assign(const char *s);//把字符串s赋给当前的字符串 string&amp; assign(const char *s, int n);//把字符串s的前n个字符赋给当前的字符串 string&amp; assign(const string &amp;s);//把字符串s赋给当前字符串 string&amp; assign(int n, char c);//用n个字符c赋给当前字符串 string&amp; assign(const string &amp;s, int start, int n);//将s从start开始n个字符赋值给字符串 3、string存取字符操作 12char&amp; operator[](int n);//通过[]方式取字符 char&amp; at(int n);//通过at方法获取字符 4、string拼接操作 12345678string&amp; operator+=(const string&amp; str);//重载+=操作符 string&amp; operator+=(const char* str);//重载+=操作符 string&amp; operator+=(const char c);//重载+=操作符 string&amp; append(const char *s);//把字符串s连接到当前字符串结尾 string&amp; append(const char *s, int n);//把字符串s的前n个字符连接到当前字符串结尾 string&amp; append(const string &amp;s);//同operator+=() string&amp; append(const string &amp;s, int pos, int n);//把字符串s中从pos开始的n个字符连接到 当前字符串结尾 string&amp; append(int n, char c);//在当前字符串结尾添加n个字符c 5、string查找和替换 12345678910int find(const string&amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找 int find(const char* s, int pos = 0) const; //查找s第一次出现位置,从pos开始查找 int find(const char* s, int pos, int n) const; //从pos位置查找s的前n个字符第一次位置 int find(const char c, int pos = 0) const; //查找字符c第一次出现位置 int rfind(const string&amp; str, int pos = npos) const;//查找str最后一次位置,从pos开始查找int rfind(const char* s, int pos = npos) const;//查找s最后一次出现位置,从pos开始查找 int rfind(const char* s, int pos, int n) const;//从pos查找s的前n个字符最后一次位置 int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置 string&amp; replace(int pos, int n, const string&amp; str); //替换从pos开始n个字符为字符串 str string&amp; replace(int pos, int n, const char* s); //替换从pos开始的n个字符为字符串s 6、string比较操作 1234567/*compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。 比较区分大小写，比较时参考字典顺序，排越前面的越小。 大写的A比小写的a小。 */int compare(const string &amp;s) const;//与字符串s比较 int compare(const char *s) const;//与字符串s比较 7、string子串 1string substr(int pos = 0, int n = npos) const;//返回由pos开始的n个字符组成的字符串 8、string插入和删除操作 1234string&amp; insert(int pos, const char* s); //插入字符串 string&amp; insert(int pos, const string&amp; str); //插入字符串 string&amp; insert(int pos, int n, char c);//在指定位置插入n个字符c string&amp; erase(int pos, int n = npos);//删除从Pos开始的n个字符 9、string和c-style字符串转换 12345//string 转 char* string str = &quot;itcast&quot;; const char* cstr = str.c_str(); //char* 转 string char* s = &quot;itcast&quot;; string str(s); 在c++中存在一个从const char到string的隐式类型转换，却不存在从一个string对象到C_string的自动类 型转换。对于string类型的字符串，可以通过c_str()函数返回string对象对应的C_string. 通常，程序员在整个程序中应坚持使用string类对象，直到必须将内容转化为char时才将其转换为C_string. unordered哈希表unordered_set，unordered_map，unordered_muliset,unordered_multimap bitset参考：https://zhuanlan.zhihu.com/p/607895839 std::bitset 是 C++ 标准库中的一个类，用于表示二进制位序列。它提供了一种方便的方式来处理二进制数据，尤其适用于位运算操作。 std::bitset 类型表示一个固定长度的位序列，每个位都只能是 0 或 1。这个固定长度在创建对象时指定，并且不能在运行时更改。类似于整数类型，std::bitset 支持多种操作，包括位运算、位查询和位设置。 创建方式： 123456#include &lt;bitset&gt;std::bitset&lt;N&gt; bitset1; // 创建一个长度为 N 的 bitset，所有位都被初始化为 0std::bitset&lt;N&gt; bitset2(value); // 使用二进制整数 value 初始化一个长度为 N 的 bitsetstd::bitset&lt;N&gt; bitset3(string); // 使用二进制字符串 string 初始化一个长度为 N 的 bitsetstd::bitset&lt;N&gt; bitset4(bitset); // 使用另一个 bitset 初始化一个长度为 N 的 bitset 常用操作： size() 返回 std::bitset 的长度 count() 返回 std::bitset 中值为 1 的位的数量 any() 返回 std::bitset 中是否存在值为 1 的位 none() 返回 std::bitset 中是否所有位都是 0 all() 返回 std::bitset 中是否所有位都是 1 test(pos) 返回 std::bitset 中位于 pos 位置的值 set(pos) 将 std::bitset 中位于 pos 位置的值设为 1 reset(pos) 将 std::bitset 中位于 pos 位置的值设为 0 flip(pos) 将 std::bitset 中位于 pos 位置的值取反 to_ulong() 返回 std::bitset 转换成的无符号整数值 to_ullong() 返回 std::bitset 转换成的无符号长整数值 STL迭代器Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。 迭代器的作用：能够让迭代器与算法不干扰的相互发展，最后又能无间隙的粘合起来，重载了*，＋＋，＝＝，！＝，＝运算符，用以操作复杂的数据结构。 容器提供迭代器，算法使用迭代器；常见的一些迭代器类型：iterator、const_iterator、reverse_iterator和const_reverse_iterator. STL算法STL中算法大致分为四类： 非可变序列算法：指不直接修改其所操作的容器内容的算法。 可变序列算法：指可以修改它们所操作的容器内容的算法。 排序算法：对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。 数值算法：对容器内容进行数值计算。 常用函数参考：https://blog.csdn.net/weixin_49486457/article/details/123439229?spm=1001.2014.3001.5502 ①、sort();【具有和快排一样的速度】 时间复杂度O (n*logn) 1234int a[5] = &#123;4,2,1,3,5&#125;;vector&lt;int&gt; b(a,a+5);sort(a,a+5);//搭配数组 从小到大排序sort(b.begin(),b.end()); ②__gcd() 最大公约数最大公约数小题 123456789101112#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,m;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); int k=__gcd(n,m);//最大公约数 printf(&quot;%d &quot;,k); printf(&quot;%d&quot;, n * m / k); //最小公倍数 return 0;&#125; ③max()、min() 12max(a,b);//返回最大值min(a,b);//返回最小值 ④swap() 1swap(a,b);//交换a和b ⑤lower_bound()与upper_bound()【二分查找】 ower bound()返回数组中第一个大于等于x的数的地址： upper bound()返回数组中第一个大于x的数的地址 将得到的地址减去数组的起始地址可得在数组中的下标 ⑥reverse() 【倒置】 12ector&lt;int&gt; v=&#123;1,2,3,4,5&#125;;reverse(v.begin(),v.end());//v的值为5，4，3，2，1 倒置 ⑦find() 123//在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，//若存在返回其在向量中的位置find(a.begin(),a.end(),10); ⑧、erase()【删除】 1234//从c中删除迭代器p指定的元素，p必须指向c中的一个真实元素，不能等于c.end()c.erase(p)//从c中删除迭代器对b和e所表示的范围中的元素，返回ec.erase(b,e)","tags":["C++"]},{"title":"数据结构与算法","path":"/2024/03/10/数据结构与算法/","content":"来源 《大话数据结构》 https://zhuanlan.zhihu.com/p/367994409 .ngedwyfeikgc{zoom:67%;} 数据结构绪论基本概念.rurjurpgusjq{zoom:67%;} 数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。 数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。 数据项：一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。 数据对象：是性质相同的数据元素的集合，是数据的子集。 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。 .tgamjvalqdey{zoom:67%;} 逻辑结构.toywpxyihnht{zoom:67%;} 数据结构分为逻辑结构和物理结构。逻辑结构是面向问题的，而物理结构就是面向计算机的。 逻辑结构：是指数据对象中数据元素之间的相互关系。 集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。各个数据元素是“平等”的，它们的共同属性是“同属于一个集合”。 .pdeureksqqhi{zoom:50%;} 线性结构：线性结构中的数据元素之间是一对一的关系。 .aqavmbccqiot{zoom: 50%;} 树形结构：树形结构中的数据元素之间存在一种一对多的层次关系。 .jncegzfpduvw{zoom: 50%;} 图形结构：图形结构的数据元素是多对多的关系。 .gwjfkvkiwrtj{zoom:50%;} 物理结构物理结构：也叫做存储结构，是指数据的逻辑结构在计算机中的存储形式。数据元素的存储结构形式有两种：顺序存储和链式存储。 顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。 .tpgkjqhcvntz{zoom:67%;} 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置。 .eauriqqdbdfj{zoom:67%;} 线性表.ckvxmyzocvdu{zoom:67%;} 线性表(List)：零个或多个数据元素的有限序列。 特点：元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其他每个元素都有且只有一个前驱和后继；线性表强调是有限的。 .gwogdirpwehf{zoom:67%;} 抽象数据类型线性表的抽象数据类型定义如下： 12345678910111213ADT线性表(List)Data\t线性表的数据对象集合为&#123;a1,a2,,an&#125;,每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。Operation InitList(*L):初始化操作，建立一个空的线性表工。 ListEmpty(L):若线性表为空，返回true,否则返回false。\tClearList(*L):将线性表清空。 GetElem(L,i,*e):将线性表工中的第i个位置元素值返回给e。 LocateElem(L,e):在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成 功；否则，返回0表示失败。 ListInsert(*L,1,e):在线性表L中的第i个位置插入新元素e。 ListDelete(*L,i,*e):删除线性表L中第i个位置元素，并用e返回其值。 ListLength(L):返回线性表工的元素个数。endADT 对于不同的应用，线性表的基本操作是不同的，上述操作是最基本的，对于实际问题中涉及的关于线性表的更复杂操作，完全可以用这些基本操作的组合来实现。 顺序存储结构线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。 线性表的顺序存储的结构代码： 1234567#define MAXSIZE 20\t/*存储空间初始分配量*/typedef int ElemType;\t/*ElemType类型根据实际情况而定，这里假设为int*/typedef struct&#123; ElemType data[MAXSIZE];\t/*数组存储数据元素，最大值为MAXSIZE*/ int length;\t/*线性表当前长度*/&#125;SqList; 描述顺序存储结构需要三个属性： 存储空间的起始位置：数组data,它的存储位置就是存储空间的存储位置。 线性表的最大存储容量：数组长度MaxSize 线性表的当前长度：length。 线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是O(1)；而插入或删除时，时间复杂度都是O(n)。这就说明，它比较适合元素个数不太变化，而更多是存取数据的应用。 .ttdjsqbijabp{zoom:67%;} 链式存储结构把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称做指针或链。这两部分信息组成数据元素的存储映像，称为结点(Node)。 n个结点链结成一个链表，即为线性表(a1,a2,…,an)的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。 .lfuxthumsmkb{zoom:67%;} 链表中第一个结点的存储位置叫做头指针，最后一个结点指针为“空”（通常用NULL或“”符号表示）。 .tzhvdxhwggbc{zoom:67%;} 为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针。 .jfqsxdshcpby{zoom:67%;} 单链表中，在C语言中可用结构指针来描述： 1234567/*线性表的单链表存储结构*/typedef struct Node&#123; ElemType data; struct Node *next;&#125;Node;typedef struct Node *LinkList;/*LinkList*/ 从整个算法推导出：单链表插入和删除的时间复杂度都是O(n)。如果在不知道第ⅰ个元素的指针位置，单链表数据结构在插入和删除操作上，与线性表的顺序存储结构是没有太大优势的。但如果，我们希望从第ⅰ个位置，插入10个元素，对于顺序存储结构意味着，每一次插入都需要移动n-1个元素，每次都是O(n)。而单链表，我们只需要在第一次时，找到第1个位置的指针，此时为O(n)，接下来只是简单地通过赋值移动指针而已，时间复杂度都是O(1)。显然，对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显。 单链表初始化可以分为头插法和尾插法。 优缺点对比.hwgpovxbqbxr{zoom:67%;} 通过上面的对比，我们可以得出一些经验性的结论： 若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。 当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。而如果事先知道线性表的大致长度，比如一年12个月，一周就是星期一至星期日共七天，这种用顺序存储结构效率会高很多。 静态链表一般来说，静态链表其实是为了给没有指针的高级语言设计的一种实现单链表能力的方法。 静态链表：数组的元素都是由两个数据域组成，data和cur。数据域data，用来存放数据元素；而游标cur相当于单链表中的next指针，存放该元素的后继在数组中的下标。 1234567/*线性表的静态链表存储结构*/#define MAXSIZE 1000\t/*假设链表的最大长度是1000*/typedef struct&#123; ElemType data; int cur;\t/*游标（Cursor),为0时表示无指向*/&#125;Component,StaticLinkList [MAXSIZE]; .xgjmkvmwqlvg{zoom:67%;} .syfbjjtwwdbk{zoom:67%;} 对数组第一个和最后一个元素作为特殊元素处理，不存数据。数组第一个元素，即下标为0的元素的cur就存放备用链表的第一个结点的下标；而数组的最后一个元素的cur则存放第一个有数值的元素的下标，相当于单链表中的头结点作用，当整个链表为空时，则为0。通常把未被使用的数组元素称为备用链表。 .qgvrjhkngmii{zoom:67%;} 循环链表循环链表（circular linked list)：将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表。 .sjbgpppqgoii{zoom:67%;} 双向链表双向链表(double linked list)：在单链表的每个结点中，再设置一个指向其前驱结点的指针域。所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。 1234567/*线性表的双向链表存储结构*/typedef struct DulNode&#123; ElemType data; struct DuLNode *prior;\t/*直接前驱指针*/ struct DuLNode *next;\t/*直接后继指针*/&#125;DulNode,*DuLinkList; .ojhexbdxzguy{zoom:67%;} 栈与队列.rrfiweylmbyn{zoom:67%;} 栈栈是限定仅在表尾进行插入和删除操作的线性表。 把允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom)，不含任何数据元素的栈称为空栈。栈又称为后进先出(Last In First Out)的线性表，简称LIF0结构。 是在线性表的表尾进行插入和删除操作，这里表尾是指栈顶，而不是栈底。 栈的插入操作，叫作进栈，也称压栈、入栈。栈的删除操作，叫作出栈，也有的叫作弹栈。 .bdbeotjpchid{zoom:67%;} 抽象数据类型 12345678910111213ADT\t栈(stack)Data\t同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。Operation InitStack(*S):初始化操作，建立一个空栈S。 DestroyStack(*S):若栈存在，则销毁它。 ClearStack(*S):将栈清空。 StackEmpty(S):若栈为空，返回true,否则返回false。 GetTop(S,*e):若栈存在且非空，用e返回S的栈顶元素。 Push(*S,e):若栈S存在，插入新元素e到栈S中并成为栈顶元素。 Pop(*S,*e):刷除栈S中栈顶元素，并用e返回其值。 StackLength(s)：返回栈s的元素个数。endADT 顺序存储空间 123456typedef int SElemType;/*SElemType类型根据实际情况而定，这里假设为int*/typedef struct&#123; SElemType data [MAXSIZE]; int top;\t/*用于栈顶指针*/)SqStack; 两栈共享空间 如果有两个相同类型的栈，为它们各自开辟了数组空间，极有可能是第一个栈已经满了，再进栈就溢出了，而另一个栈还有很多存储空间空闲。可以用一个数组来存储两个栈。 数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为数组的末端，即下标为数组长度n-1处。这样，两个栈如果增加元素，就是两端点向中间延伸。 .fhldeoiiadjz{zoom:67%;} 链式存储结构 1234567891011typedef struct StackNode&#123; SElemType data; struct StackNode *next;&#125;StackNode,*LinkstackPtr;typedef struct Linkstack&#123; LinkStackPtr top; int count;&#125;Linkstack; 链式存储结构简称为链栈。由于栈只是栈顶来做插入和删除操作，一般把栈顶放在单链表的头部。且栈顶在头部了，单链表中比较常用的头结点也就失去了意义，通常对于链栈来说，是不需要头结点的。 .xczjsskojamg{zoom:67%;} 队列队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。 队列是一种先进先出(First In First Out)的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。 .birfytazosxn{zoom:67%;} 抽象数据类型 12345678910111213ADT\t队列(Queue)Data\t同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。Operation InitQueue(*Q):初始化操作，建立一个空队列Q。 DestroyQueue(*Q)：若队列Q存在，则销毁它。 c1earQueue(*Q):将队列Q清空。 QueueEmpty(Q):若队列Q为空，返回true,否则返回false。 GetHead(Q,*e):若队列Q存在且非空，用e返回队列Q的队头元素。 EnQueue(*Q,e):若队列Q存在，插入新元素e到队列Q中并成为队尾元素。 DeQueue(*Q,*e):刷除队列Q中队头元素，并用e返回其值。 QueueLength(Q):返回队列Q的元素个数endADT 顺序存储结构——循环队列 把队列的这种头尾相接的顺序存储结构称为循环队列，解决“假溢出”问题。 12345678typedef int QElemType;/*QElemType类型根据实际情况而定，这里假设为int*//*循环队列的顺序存储结构*/typedef struct&#123; QElemType data [MAXSIZE]; int front;\t/*头指针*/ int rear;\t/*尾指针，若队列不空，指向队列尾元素的下一个位置*/&#125;SqQueue; 链式存储结构 队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，简称为链队列。 1234567891011typedef int QElemType;/*QElemType类型根据实际情况而定，这里假设为int*/typedef struct QNode/*结，点结构*/&#123; QElemType data; struct QNode *next;&#125;QNode,*Queueptr;typedef struct\t/*队列的链表结构*/&#123;\tQueuePtr front,rear;/*队头、队尾指针*/&#125;LinkQueue; 串串(string)是由零个或多个字符组成的有限序列，又名叫字符串。 空串：零个字符的串称为空串(null string)，它的长度为零，可以直接用两双引号““””表示。 空格串：是只包含空格的串。注意它与空串的区别，空格串是有内容有长度的，而且可以不止一个空格。 子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串。子串在主串中的位置就是子串的第一个字符在主串中的序号。 树.ucqkwoeqtgky{zoom:67%;} 概念树(Tree)是n(n≥0)个结点的有限集。n&#x3D;0时称为空树。在任意一棵非空树中：（1)有且仅有一个特定的称为根（Root)的结点；(2)当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1、T2、…、Tm,其中每一个集合本身又是一棵树，并且称为根的子树(SubTree)，如图6-2-1所示。 .ywkuqucndomg{zoom:67%;} 树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为结点的度(Degree)。度为0的结点称为叶结点(Leaf)或终端结点；度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。 结点的子树的根称为该结点的孩子(Child)，相应地，该结点称为孩子的双亲(Parent))。同一个双亲的孩子之间互称兄弟(Sibling)。结点的祖先是从根到该结点所经分支上的所有结点。所以对于H来说，D、B、A都是它的祖先。反之，以某结点为根的子树中的任一结点都称为该结点的子孙。 .mgsbjguhnjfr{zoom:67%;} 结点的层次(Level)从根开始定义起，根为第一层，根的孩子为第二层。若某结点在第l层，则其子树的根就在第l+1层。其双亲在同一层的结点互为堂兄弟。显然图6-2-6中的D、E、F是堂兄弟，而G、H、I、J也是。树中结点的最大层次称为树的深度(Depth)或高度，当前树的深度为4。 .dwxdquczxvwk{zoom:67%;} 如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。 森林(Forest)是m(m&gt;≥0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。 树的抽象数据类型12345678910111213141516171819ADT\t树(tree)Data\t树是由一个根结点和若干棵子树构成。树中结点具有相同数据类型及层次关系。Operation InitTree(*T):构造空树T。 DestroyTree(*T):销毁树T。 CreateTree(*T,definition):按definition中给出树的定义来构造树。 ClearTree(*T)：若树T存在，则将树T清为空树。 TreeEmpty(T):若T为空树，返回true,否则返回false。 TreeDepth(T):返回T的深度。 Root(T):返回T的根结点。 Value(T,cure):cure是树T中一个结，点，返回此结，点的值。 Assign(T,cure,value):给树T的结点cure赋值为value。 Parent(T,cure)：若cure是树T的非根结点，则返回它的双亲，否则返回空。 LeftChild(T,cure)：若cure是树T的非叶结点，则返回它的最左孩子，否则返回空。 Rightsibling(T,cure):若cure有右兄弟，则返回它的右兄弟，否则返回空。 InsertChild(*T,*p,i,c):其中p指向树T的某个结点，i为所指结，点p的度加上1，非空树c与T不相交，操 作结果为插入c为树T中P指结点的第i棵子树。 DeleteChild(*T,*p,i)：其中p指向树T的某个结，点，i为所指结点p的度，操作结果为删除T中p所指结，点的第i棵子树。endADT 树的存储结构双亲表示法假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点到链表中的位置。也就是说，每个结点除了知道自己是谁以外，还知道它的双亲在哪里。 .bavlxfmwqggb{zoom:67%;} 其中daa是数据域，存储结点的数据信息。而parent是指针域，存储该结点的双亲在数组中的下标。 123456789101112131415/*树的双亲表示法结，点结构定义*/#define MAX TREE SIZE 100typedef int TElemType;\t/*树结点的数据类型，目前暂定为整型*/typedef struct PTNode\t/*结，点结构*/&#123; TElemType data;/*结，点数据*/ int parent;/*双亲位置*/&#125;PTNode;typedef struct&#123; /*树结构*/ PTNode nodes[MAX TREE SIZE];\t/*结，点数组*/ int r,n;\t/*根的位置和结，点数*/&#125;PTree; 孩子表示法由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法。不过，树的每个结点的度，也就是它的孩子个数是不同的。 孩子兄弟表示法二叉树二叉树(Binary Tree)是n(n≥0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。 二叉树的特点有： 每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。注意不是 只有两棵子树，而是最多有。没有子树或者有一棵子树都是可以的。 左子树和右子树是有顺序的，次序不能任意颠倒。 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。下图中，树1和树2是同一棵树，但它们却是不同的二叉树。就好像你一不小心，摔伤了手，伤的是左手还是右手，对你的生活影响度是完全不同的。 .wywmmsfuwjol{zoom:67%;} 满二叉树：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。 .flgglidxfixm{zoom:67%;} 完全二叉树：对一棵具有n个结点的二叉树按层序编号，如果编号为i(1≤i≤)的结点与同样深度的满二叉树中编号为1的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。 .lhsqxpodvfyx{zoom:67%;} 图图(Graph)是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E),其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。 算法概念基本算法：是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。 算法的基本特性：输入（零个或多个输入）、输出（至少有一个或多个）、有穷性、确定性和可行性。有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。确定性：算法的每一步骤都具有确定的含义，不会出现二义性。可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。可行性意味着算法可以转换为程序上机运行，并得到正确的结果。 算法的设计要求：正确性、可读性、健壮性、高效率和低存储量需求。 算法时间复杂度算法效率的度量方法。事后统计方法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算。 算法的度量方法：事后统计方法（不科学、不准确）、事前分析估算方法。 算法的时间复杂度，也就是算法的时间量度，记作：T[n]&#x3D;O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。 用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。推导大O阶： 用常数1取代运行时间中的所有加法常数。 在修改后的运行次数函数中，只保留最高阶项。 如果最高阶项存在且不是1，则去除与这个项相乘的常数。得到的结果就是大O阶。 .wondgoreufxf{zoom:67%;} 算法空间复杂度算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)&#x3D;O(f(n),其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。 通常，我们都使用“时间复杂度”来指运行时间的需求，使用“空间复杂度”指空间需求。当不用限定词地使用“复杂度”时，通常都是指时间复杂度。 查找参考：https://www.cnblogs.com/maybe2030/p/4715035.html#top 查找算法分类： 1）静态查找和动态查找； 注：静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。 2）无序查找和有序查找。 无序查找：被查找数列有序无序均可； 有序查找：被查找数列必须为有序数列。 七大查找算法： 1顺序查找 2二分查找 3插值查找 4斐波那契查找 5树表查找 6分块查找 7哈希查找 1 顺序查找(O(n))1234567891011/*顺序查找，a为数组，n为要查找的数组个数，key为要查找的关键字*/int Sequential Search (int *a,int n,int key)&#123; int i; for (i=1;i&lt;=n;i++) &#123; if (a[i]==key) return i; &#125; return 0;&#125; 优化，设置哨兵： 12345678910111213/*有哨兵顺序查找*/int Sequential Search2 (int *a,int n,int key)&#123; int i; a[0]=key;/*设置a[0]为关键字值，我们称之为“哨兵”*/ i=n; /*循环从数组尾部开始*/ while (a[i]!=key) &#123; i-- &#125;\treturn i;/*返回0则说明查找失败*/&#125; 但这里优化后，会改变原数组a[0]的值？ 2 有序查找有序查找为插值插值类，有三种有序表查找，本质上是分隔点的选择不同，各有优劣，实际开发时可根据数据的特点综合考虑再做出选择。 二分查找(O(logn))折半查找(Binary Search)技术，又称为二分查找。 它的前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。 123456789101112131415161718int Binary Search (int *a,int n,int key)&#123; int low,high,mid; 1ow=1:/*定义最低下标为记录首位*/ high=n;/*定义最高下标为记录末位*/ while (low&lt;=high) &#123; mid=(low+high)/2;\t/*折半*/ if (key&lt;a[mid]\t/*若查找值比中值小*/ high=mid-1;\t/*最高下标调整到中位下标小一位*/ else if (key&gt;a[mid])\t/*若查找值比中值大*/ low=mid+1;\t/*最低下标调整到中位下标大一位*/ else return mid; &#125; /*若相等则说明mid即为查找到的位置*/ return 0;&#125; 不过由于折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，这样的算法已经比较好了。 但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。 插值查找(O(logn))折半查找公式： $m i d&#x3D;\\frac{l o w+h i g h}{2}&#x3D;l o w+\\frac{1}{2}\\bigl(h i g h-l o w\\bigr)$ 改变$1&#x2F;2$变成$\\frac{k e y-a[l o w]}{a[h i g h]-a[l o w]}$： $m i d&#x3D;l o w+\\frac{k e y-a[l o w]}{a[h i g h]-a[l o w]}(h i g h-l o w)$ 代码中： 123 mid=(low+high)/2;\t/*折半*///改成：mid=low+(high-low)*（key-a[low])/(a[high]-a[1ow]);/*插值*/ 斐波那契查找(O(logn))斐波那契查找(Fibonacci Search)，它是利用了黄金分割原理来实现的。 123456789101112131415161718192021222324252627282930313233int Fibonacci Search (int *a,int n,int key)&#123; int low,high,mid,i,k; 10w=1;\t/*定义最低下标为记录首位*/ high=n; /*定义最高下标为记录末位*/ k=0: while(n&gt;F[k]-1)\t/*计算n位于斐波那契数列的位置*/ k++: for（i=n;1&lt;F[k]-1;i++)/*将不满的数值补全*/ a[i]=a[n]; while (low&lt;=high) &#123; mid=low+F[k-1]-1;\t/*计算当前分隔的下标*/ if (key&lt;a[mid])\t/*若查找记录小于当前分隔记录*/ &#123; high=mid-1;\t/*最高下标调整到分隔下标mid-1处*/ k=k-1:\t/*斐波那契数列下标减一位*/ &#125; else if(key&gt;a[mid])/*若查找记录大于当前分隔记录*/ &#123; low=mid+1;\t/*最低下标调整到分隔下标mid+1处*/ k=k-2;\t/*斐波那契数列下标减两位*/ &#125; else &#123; if (mid&lt;=n) return mid;\t/*若相等则说明mid即为查找到的位置*/ else return n;\t/*若mid&gt;n说明是补全数值，返回n*/ &#125; &#125; return 0;&#125; 索引查找索引按照结构可以分为线性索引、树形索引和多级索引。 所谓线性索引就是将索引项集合组织为线性结构，也称为索引表。重点介绍三种线性索引：稠密索引、分块索引和倒排索引。 稠密索引稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项。 .khekomzkttjm{zoom: 67%;} 对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列。 分块索引（分块查找）稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大。为了减少索引项的个数，我们可以对数据集进行分块，使其分块有序，然后再对每一块建立一个索引项，从而减少索引项的个数。 分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件： 块内无序，即每一块内的记录不要求有序。当然，你如果能够让块内有序 对查找来说更理想，不过这就要付出大量时间和空间的代价，因此通常我 们不要求块内有序。 块间有序，例如，要求第二块所有记录的关键字均要大于第一块中所有记 录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键 字…因为只有块间有序，才有可能在查找时带来效率。 最大关键码，它存储每一块中的最大关键字，这样的好处就是可以使得在 它之后的下一块中的最小关键字也能比这一块最大的关键字要大； 存储了块中的记录个数，以便于循环时使用； 用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历。 .uygqychmkbbx{zoom:67%;} 在分块索引表中查找，就是分两步进行： 在分块索引表中查找要查关键字所在的块。由于分块索引表是块间有序的， 因此很容易利用折半、插值等算法得到结果。例如，在图8-5-4的数据集中 查找62，我们可以很快可以从左上角的索引表中由57&lt;62&lt;96得到62在第 三个块中。 根据块首指针找到相应的块，并在块中顺序查找关键码。因为块中可以是无序 的，因此只能顺序查找。 倒排索引3 树表查找假设查找的数据集是普通的顺序存储，那么插入操作就是将记录放在表的末端，给表记录数加一即可，删除操作可以是删除后，后面的记录向前移，也可以是要删除的元素与最后一个元素互换，表记录数减一，反正整个数据集也没有什么顺序，这样的效率也不错。应该说，插入和删除对于顺序存储结构来说，效率是可以接受的，但这样的表由于无序造成查找的效率很低。 如果查找的数据集是有序线性表，并且是顺序存储的，查找可以用折半、插值、斐波那契等查找算法来实现，可惜，因为有序，在插入和删除操作上，就需要耗费大量的时间。 在查找时插入或删除的查找表称为动态查找表。 以下查找方法可以使得插入和删除效率不错，又可以比较高效率地实现查找。 二叉排序树二叉排序树(Binary Sort Tree),又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树。 若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。 平衡二叉树（AVL树）平衡二叉树(Self-Balancing Binary Search Tree或Height-Balanced Binary Search Tree)，是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1。 平衡二叉树（红黑树）多路查找树（2-3、B、B+树）多路查找树(muitl-way search tree),其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素。由于它是查找树，所有元素之间存在某种特定的排序关系。 23树是这样的一棵多路查找树：其中的每一个结点都具有两个孩子（我们称它为2结点)或三个孩子（我们称它为3结点）。 B树(B-ree)是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。结点最大的孩子数目称为B树的阶(order)，因此，2-3树是3阶B树，2-3-4树是4阶B树。 B+树是应文件系统所需而出的一种B树的变形树，注意严格意义上讲，它其实已经不是第六章定义的树了。在B树中，每一个元素在该树中只出现一次，有可能在叶子结点上，也有可能在分支结点上。而在B+树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者（叶子结点）中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针。 4 哈希查找哈希查找，即哈希表查找，或者散列表查找。 散列技术：是在记录的存储位置和它的关键字之间建立一个确定的对应关系，使得每个关键字key对应一个存储位置f(key)。查找时，根据这个确定的对应关系找到给定值key的映射f(key)，若查找集合中存在这个记录，则必定在f(key)的位置上。 这里把这种对应关系f称为散列函数，又称为哈希(Hash)函数。按这个思想，采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表(Hash table)。那么关键字对应的记录存储位置我们称为散列地址。 散列技术最适合的求解问题是查找与给定值相等的记录。 哈希冲突：在理想的情况下，每一个关键字，通过散列函数计算出来的地址都是不一样的，可现实中，这只是一个理想。我们时常会碰到两个关键字ky1≠ key2,但是却有f(key1)&#x3D;f(key2)，这种现象称为冲突（(collision)，并把key1和 key2称为这个散列函数的同义词(synonym)。 散列函数的构造1、直接定址法 以取关键字的某个线性函数值为散列地址，即 f(key)&#x3D;a×key+b（a、b为常数)这样的散列函数优点就是简单、均匀，也不会产生冲突，但这需要事先知道关键字的分布情况，适合查找表较小且连续的情况。由于这样的限制，在现实应用中，此方法虽然简单，但却并不常用。 2、数字分析法 .oftcngrwedhh{zoom:67%;} 3、平方取中法 这个方法计算很简单，假设关键字是1234，那么它的平方就是1522756，再抽取中间的3位就是227，用做散列地址。再比如关键字是4321，那么它的平方就是 18671041,抽取中间的3位就可以是671，也可以是710，用做散列地址。 平方取中法比较适合于不知道关键字的分布，而位数又不是很大的情况。 4、折叠法 折叠法是将关键字从左到右分割成位数相等的几部分（注意最后一部分位数不够时可以短些)，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。 比如我们的关键字是9876543210，散列表表长为三位，我们将它分为四组， 987|654|321|0,然后将它们叠加求和987+654+321+0&#x3D;1962，再求后3位得到散列地址为962。有时可能这还不能够保证分布均匀，不妨从一端向另一端来回折叠后对齐相加。比如我们将987和321反转，再与654和0相加，变成789+654+123+0&#x3D;1566，此时散列地址为566。 折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。 5、除留余数法 此方法为最常用的构造散列函数方法。对于散列表长为的散列函数公式为：f(key)&#x3D;key mod p(p≤m)，mod是取模（求余数）的意思。事实上，这方法不仅可以对关键字直接取模，也可在折叠、平方取中后再取模。 因此根据前辈们的经验，若散列表表长为，通常p为小于或等于表长（最好接近m)的最小质数或不包含小于20质因子的合数。 6、随机数法 选择一个随机数，取关键字的随机函数值为它的散列地址。也就是f(key)&#x3D;random(key)。这里random是随机函数。当关键字的长度不等时，采用这个方法构造散列函数是比较合适的。 处理散列冲突的方法1、开放定址法 所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。 线性探测法 2、再散列函数法 每当发生散列地址冲突时，就换一个散列函数计算，相信总会有一个可以把冲突解决掉。这种方法能够使得关键字不产生聚集，当然，相应地也增加了计算的时间。 3、链地址法 将所有关键字为同义词的记录存储在一个单链表中，我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。 .sdwghfqrsdgt{zoom:67%;} 4、公共溢出区法 为所有冲突的关键字建立了一个公共的溢出区来存放。 .sbtmtodyjqol{zoom:67%;} 排序参考： https://www.cnblogs.com/onepixel/p/7674659.html https://www.zhihu.com/question/485281894/answer/2526978559 排序的分类 按在排序过程中是否涉及数据的内、外存交换来分类，排序大致分为两类：内部排序和外部排序。 内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。外排序是一种线性时间复杂度的排序，利用空间来换时间。 根据排序过程中借助的主要操作，我们把内排序分为：插入排序、交换排序、选择排序和归并排序。外排序可以分为：计数排序、桶排序和基数排序。 按照是否通过比较来决定元素间的相对次序，排序可以分为比较类排序和非比较类排序。 十大排序 .pdjvybnhdsbf{zoom: 50%;} .jolternyvvbn{zoom: 50%;} 1冒泡排序冒泡排序(Bubble Sort)一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。 .eetmucenieiq{zoom:67%;} 简单实现： 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;void bubble_sort(int a[], int n) &#123; for(int i = 0; i &lt; n - 1; i++) &#123; for(int j = 0; j &lt; n - 1 - i; j++) &#123; if(a[j] &gt; a[j+1]) &#123; // 让大的沉底 int temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; &#125; &#125; &#125;&#125;int main()&#123; int n; cin &gt;&gt; n; int a[n]; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; bubble_sort(a, n); for(int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 优化： 123456789101112131415161718//若序列已经有序，为减少两两间的比较，可以设置标志flagvoid bubble_sort(int a[], int n) &#123; bool flag = true; for(int i = 0; i &lt; n - 1 &amp;&amp; flag; i++) &#123; flag = false; for(int j = 0; j &lt; n - 1 - i; j++) &#123; if(a[j] &gt; a[j+1]) &#123; // 让大的沉底 int temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; flag = true; &#125; &#125; &#125;&#125; 2简单选择排序简单选择排序法(Simple Selection Sort)就是通过n-i次关键字间的比较，从 n-i+1个记录中选出关键字最小的记录，并和第i（1≤i≤n)个记录交换之。 .myoimnbqgqil{zoom:67%;} 思路：首先在未排序的序列中找到最小或者最大的元素，放到排序序列的起始位置，然后再从未排序的序列中继继续寻找最小或者最大元素，然后放到已经排序序列的末尾。以此类推，直到所有元素排序完毕。 1234567891011121314151617void swap(int *a, int *b) //交換兩個變數，C语言可以这样写：swap(&amp;a, &amp;b);&#123; int temp = *a; *a = *b; *b = temp;&#125;void select_sort(int a[], int n) &#123; for(int i = 0; i &lt; n - 1; i++) &#123; int min = i; for(int j = i + 1; j &lt; n; j++) &#123; //走訪未排序的元素 if(a[min] &gt; a[j]) &#123; //找到目前最小值 min = j; //紀錄最小值 &#125; &#125; swap(a[min], a[i]); //做交換，C++可以不用自己写swap &#125;&#125; 3直接插入排序直接插入排序(Straight Insertion Sort)的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。 .hiswluxeahlm{zoom:67%;} 12345678910void insert_sort(int a[], int n) &#123; int i, j, key; for(i = 1; i &lt; n; i++) &#123; key = a[i]; for(j = i - 1; j &gt;= 0 &amp;&amp; a[j] &gt; key; j--) &#123; a[j + 1] = a[j]; &#125; a[j + 1] = key; &#125;&#125; 4希尔排序1959年Shell发明，第个突破O(n^2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 .zhdtxulxmkxe{zoom:67%;} 123456789101112void shell_sort(int a[], int n) &#123; int i, j, gap, key; for(gap = n / 2; gap &gt;= 1; gap /= 2) &#123; for(i = gap; i &lt; n; i++) &#123; key = a[i]; for(j = i - gap; j &gt;= 0 &amp;&amp; a[j] &gt; key; j -= gap) &#123; a[j + gap] = a[j]; &#125; a[j + gap] = key; &#125; &#125;&#125; 5归并排序归并排序的步骤，是把一个数组切分成两个，接着递归，一直到单个元素，然后再合并，单个元素合并成小数组，小数组合并成大数组。 1234567891011121314151617181920212223242526272829303132333435void merge(int a[], int start, int mid, int end) &#123; int start1 = start, end1 = mid; int start2 = mid + 1, end2 = end; int temp[10000], k = 0, i; //temp临时存放合并后的数组 while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) temp[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++]; while (start1 &lt;= end1) temp[k++] = a[start1++]; while (start2 &lt;= end2) temp[k++] = a[start2++]; for (i = 0; i &lt; k; i++) a[start + i] = temp[i];&#125;//将a数组区间[start, end]进行归并排序（递归实现）void merge_sort(int a[], int start, int end) &#123; if (start &gt;= end) return; int mid = start + (end - start) / 2; merge_sort(a, start, mid); merge_sort(a, mid + 1, end); merge(a, start, mid, end);&#125;//将a数组区间[start, end]进行归并排序（C++循环实现）void merge_sort(int a[], int len) &#123; //step为组内元素个数，step / 2为左子区间元素个数 for(int step = 2; step / 2 &lt; len; step *= 2) &#123; for(int i = 0; i &lt; len; i += step) &#123; // 对每一组 int mid = i + (step - 1) / 2; //区间元素个数为step，故end = i + step - 1 if(mid + 1 &lt;= len) &#123; //右子区间左端点&lt;=右端点 merge(a, i, mid, min(i + step - 1, len - 1)); &#125; &#125; &#125;&#125; 6快速排序快速排序是面试最高频的排序算法。大概过程： 选出一个基准数，基准值一般取序列最左边的元素 重新排序序列，比基准值小的放在基准值左边，比基准值大的放在基准值右边，这就是所谓的分区 快排也采用了“分治思想”，需要使用到递归，这一点跟归并排序相同；不同的是比较过程， 快排序不需要“合并”的过程，因为递归分解后，数据已经是有序的。 .eghjomhujvvg{zoom:67%;} 快速排序实现方法分为单边扫描和双边扫描快速排序。 单边扫描快速排序 选择一个数作为基准数pivot，同时设定一个标记 mark 代表左边序列最右侧的下标位置，接下来遍历数组，如果元素大于基准值，无操作，继续遍历，如果元素小于基准值，则把 mark + 1 ，再将 mark 所在位置的元素和遍历到的元素交换位置，mark 这个位置存储的是比基准值小的数据，当遍历结束后，将基准值与 mark 所在元素交换位置。 双边扫描快速排序 选择一个数作为基准值，然后从数组左右两边进行扫描，先从左往右找到一个大于基准值的元素，将它填入到right指针位置，然后转到从右往左扫描，找到一个小于基准值的元素，将他填入到left指针位置。 快排最好的情况是，每次正好中分，复杂度为O(nlogn)。最差情况，复杂度为O(n^2)： 7堆排序简单选择排序，它在待排序的个记录中选择一个最小的记录需要比较n-1次。可惜的是，这样的操作并没有把每一趟的比较结果保存下来，在后一趟的比较中，有许多比较在前一趟已经做过了，但由于前一趟排序时未保存这些比较结果，所以后一趟排序时又重复执行了这些比较操作，因而记录的比较次数较多。 堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。 .qcgguzwiihmw{zoom:67%;} 堆排序(Heap Sort)就是利用堆（假设利用大顶堆）进行排序的方法。它的基本思想是，将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值)，然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次小值。如此反复执行，便能得到一个有序序列了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100;int heap[maxn], n = 10;//对heap数组在[low, high]范围进行向下调整//其中low为欲调整结点的数组下标，high一般为堆的最后一个元素的数组下标void downAdjust(int low, int high) &#123; int i = low, j = i * 2; //i为欲调整结点，j为其左孩子 while(j &lt;= high) &#123; //如果右孩子存在且值大于左孩子 if(j + 1 &lt;= high &amp;&amp; heap[j + 1] &gt; heap[j]) &#123; j = j + 1; //j存储右孩子下标 &#125; //如果孩子中最大的权值比欲调整结点i大 if(heap[j] &gt; heap[i]) &#123; //建大顶堆，以完成升序排序 swap(heap[j], heap[i]); i = j; //权值比i大的孩子结点变成下一个欲调整结点 j = i * 2; &#125; else &#123; break; //孩子的权值均比欲调整结点i小，调整结束 &#125; &#125; &#125;void createHeap() &#123; for(int i = n / 2; i &gt;= 1; i--) &#123; //只需对非叶子结点进行调整，而且要先把下面的结点调整好 downAdjust(i, n); &#125;&#125;void heapSort() &#123; createHeap(); for(int i = n; i &gt; 1; i--) &#123; //倒着枚举，直到堆中只有一个元素 swap(heap[i], heap[1]); //把堆顶交换到当前无序序列的最后一个 downAdjust(1, i - 1); //在1~i - 1的坐标范围内调整堆顶 &#125;&#125;int main() &#123; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; heap[i]; &#125; heapSort(); for(int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; heap[i] &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 8计数排序计数排序的大致过程： 找出待排序的数组中最大max和最小的元素min，创建一个最大下标为max或(max-min)的空数组arr 统计数组中每个值为i的元素出现的次数，存入数组arr的第i项： 对所有的计数累加（从arr中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素i放在新数组的第arr(i)项，每放一个元素就将arr(i)减去1。 12345678910111213141516171819202122232425void countingSort(int arr[], int len) &#123; int max = arr[0]; for(int i = 1; i &lt; len; i++) &#123; if(max &lt; arr[i]) max = arr[i]; // 得到数组中元素的最大取值 &#125; int *count = new int[max + 1]; // 申请计数数组count，存放原数组中值与索引对应的元素出现的次数 fill(count, count + max + 1, 0); for(int i = 0; i &lt; len; i++) &#123; count[arr[i]]++; &#125; for(int i = 1; i &lt;= max; i++) &#123; count[i] += count[i - 1]; // 依次累加，从count数组中的第一个元素开始，每一项和前一项相加 &#125; // 累加后count[i]代表arr中小于等于i的元素总个数 int *result = new int[len]; // 目标数组，存放排序之后的结果 for(int i = len - 1; i &gt;= 0; i--) &#123; // 反向填充目标数组 result[count[arr[i]] - 1] = arr[i]; // 将每个元素i放在目标数组的第C[i]项 count[arr[i]]--; &#125; for(int i = 0; i &lt; len; i++) &#123; arr[i] = result[i]; // 把目标数组复制回原数组 &#125; delete []count; // 释放分配的空间 delete []result; // 释放分配的空间&#125; 计数排序实际上不适合有负数的，元素偏移值过大的数组。 9桶排序桶排序大概的过程： 设置指定数量个的数组当作空桶； 遍历输入数据，并且把元素一个一个放到对应的桶里去； 对每个不是空的桶进行排序； 从不是空的桶里把排好序的数据拼接起来。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class BucketSort implements IArraySort &#123; private static final InsertSort insertSort = new InsertSort(); @Override public int[] sort(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); return bucketSort(arr, 5); &#125; private int[] bucketSort(int[] arr, int bucketSize) throws Exception &#123; if (arr.length == 0) &#123; return arr; &#125; int minValue = arr[0]; int maxValue = arr[0]; for (int value : arr) &#123; if (value &lt; minValue) &#123; minValue = value; &#125; else if (value &gt; maxValue) &#123; maxValue = value; &#125; &#125; int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1; int[][] buckets = new int[bucketCount][0]; // 利用映射函数将数据分配到各个桶中 for (int i = 0; i &lt; arr.length; i++) &#123; int index = (int) Math.floor((arr[i] - minValue) / bucketSize); buckets[index] = arrAppend(buckets[index], arr[i]); &#125; int arrIndex = 0; for (int[] bucket : buckets) &#123; if (bucket.length &lt;= 0) &#123; continue; &#125; // 对每个桶进行排序，这里使用了插入排序 bucket = insertSort.sort(bucket); for (int value : bucket) &#123; arr[arrIndex++] = value; &#125; &#125; return arr; &#125; /** * 自动扩容，并保存数据 * * @param arr * @param value */ private int[] arrAppend(int[] arr, int value) &#123; arr = Arrays.copyOf(arr, arr.length + 1); arr[arr.length - 1] = value; return arr; &#125;&#125; 10基数排序它的基本原理是将元素按照位数切割成不同的数字，然后按照每个位数进行比较，大概过程： 取得数组中的最大数，并取得位数； arr为原始数组，从最低位开始取每个位组成radix数组； 对radixi进行计数排序（利用计数排序适用于小范围数的特点） 123456789101112131415161718192021222324252627282930313233343536373839404142int maxbit(int data[], int n) &#123; //辅助函数，求数据的最大位数 int maxData = data[0]; // 最大数 for (int i = 1; i &lt; n; ++i) &#123; // 先求出最大数，再求其位数。 if (maxData &lt; data[i]) maxData = data[i]; &#125; int d = 1; int p = 10; while (maxData &gt;= p) &#123; maxData /= 10; ++d; &#125; return d;&#125;void radixSort(int data[], int n) //基数排序&#123; int d = maxbit(data, n); int *tmp = new int[n]; int *count = new int[10]; //计数器 int i, j, k; int radix = 1; for(i = 1; i &lt;= d; i++) &#123; //进行d次排序 for(j = 0; j &lt; 10; j++) count[j] = 0; //每次分配前清空计数器 for(j = 0; j &lt; n; j++) &#123; k = (data[j] / radix) % 10; //统计每个桶中的记录数 count[k]++; &#125; for(j = 1; j &lt; 10; j++) count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶 for(j = n - 1; j &gt;= 0; j--) &#123; //将所有桶中记录依次收集到tmp中 k = (data[j] / radix) % 10; tmp[count[k] - 1] = data[j]; count[k]--; &#125; for(j = 0; j &lt; n; j++) //将临时数组的内容复制到data中 data[j] = tmp[j]; radix = radix * 10; &#125; delete []tmp; delete []count;&#125; 三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶； 计数排序：每个桶只存储单一键值； 桶排序：每个桶存储一定范围的数值。","tags":["数据结构与算法"]},{"title":"C语言基础","path":"/2024/03/08/C语言-基础/","content":"数据类型关键字指针","tags":["C语言"]},{"title":"数字图像传统分割方法","path":"/2024/03/03/数字图像传统分割方法/","content":"参考https://zhuanlan.zhihu.com/p/70758906 黄鹏,郑淇,梁超.图像分割方法综述[J].武汉大学学报(理学版),2020,66(06):519-531. （1）基于阈值分割基于阈值的图像分割方法实质是通过设定不同的灰度阈值，对图像灰度直方图进行分类，灰度值在同一个灰度范围内的像素认为属于同一类并具有一定相似性，该类方法是一种常用的灰度图像分割方法。 （2）基于区域分割基于区域的图像分割方法是根据图像的空间信息进行分割，通过像素的相似性特征对像素点进行分类并构成区域。 区域生长、区域分裂合并、分水岭算法 （3）基于边缘分割二维图像上的边缘检测是指检测出图像上灰度不连续的像素，筛选假边缘、保留真边缘，并尽量维护边缘的连接性。常见的边缘检测方法有基于差分的边缘检测、基于模糊理论的边缘检测、基于小波变换的边缘检测、基于数学形态学的边缘检测和基于深度学习的边缘检测等。 基于差分的边缘检测算子主要有以下四类：基于一阶导数的算子、基于二阶导数的算子、高斯-拉普拉斯算子（LOG）和 Canny 算子。基于一阶导数的边缘检测算子是最早提出的一类边缘检测算子，包括 Roberts 算子、Prewitt 算子和 Sobel 算子。 （4）基于聚类分割基于聚类的图像分割方法将具有特征相似性的像素点聚集到同一区域，反复迭代聚类结果至收敛，最终将所有像素点聚集到几个不同的类别中，完成图像区域的划分，从而实现分割。 （5）基于图论的图像分割方法基于图论的图像分割方法将分割问题转换成图的划分，通过对目标函数的最优化求解，完成分割过程。","tags":["图像处理"]},{"title":"代码命名规范","path":"/2024/03/02/代码命名规范/","content":"内容来源：https://www.zhihu.com/question/31498049/answer/3288298579 命名规则蛇形命名法(Snake Case): snake_case 短横线命名法(Kebab Case): kebab-case 驼峰式大小写(Camel Case): camelCase 帕斯卡命名法(Pascal Case): PascalCase 全部小写(lowercase): lowercaseall 大写(uppercase): UPPER_CASE_WITH_UNDERSCORES 短横线命名法: 多用于 css 名 函数命名, 变量命名, 文件命名要有描述性; 少用缩写。 对象 规则 示例 Google Qt 目录 snake_case snake_case snake_case PascalCase C\\C++文件 PascalCase PascalCase.h snake_case lowercaseall &#x2F; PascalCase 类型 PascalCase PascalCase PascalCase Q + PascalCase 变量 camelCase camelCase snake_case 参数 camelCase camelCase snake_case 类数据成员 m_ + camelCase m_camelCase snake_case + _ m_ + snake_case 静态变量 c + PascalCase cPascalCase k + PascalCase 全局变量 c + PascalCase cPascalCase k + PascalCase 函数 getter camelCase() camelCase() snake_case() camelCase() 函数 setter setCamelCase() setcamelCase() set_snake_case() setCamelCase() 函数 getter(bool) isCamelCase() isCamelCase() snake_case() isCamelCase() 函数 setter(bool) setCamelCase() setCamelCase() set_snake_case() setCamelCase() 函数 camelCase() camelCase() PascalCase camelCase() 命名空间(最高级) snake_case，顶级命名空间的名称应当是项目名 afm snake_case 命名空间 snake_case snake_case snake_case 枚举类型 PascalCase PascalCase PascalCase 枚举值 c + PascalCase cPascalCase k + PascalCase 宏 UPPER_CASE_WITH_UNDERSCORES UPPER_CASE_WITH_UNDERSCORES UPPER_CASE_WITH_UNDERSCORES 其它文件 建议：小写单词 lower_case_with_underscores.png 使用通用的缩写，或者产品内部有共识的缩写字母 命名空间不要使用 std 一些约定俗称的变量名是允许的。 i,j,k 用于迭代变量 T 用于模板参数","tags":["code"]},{"title":"Visual Studio的属性配置解释","path":"/2024/02/27/Visual-Studio的属性配置解释/","content":"来源：包含目录、库目录、附加包含目录、附加库目录、附加依赖项之详解 学习备份VS项目中的包含目录、库目录、附加包含目录、附加库目录、附加依赖项均在”项目-&gt;属性-&gt;配置属性”下进行配置，具体说明如下： .cxrulgofpqul{zoom:67%;} 概念说明VC++目录： 123包含目录：寻找#include&lt;xxxx.h&gt;中的xxxx.h的搜索目录库目录：寻找.lib文件的搜索目录 C&#x2F;C++： 1常规-&gt;附加包含目录：寻找#include&lt;xxxx.h&gt;中的xxxx.h的搜索目录（每一项对应一个文件夹XXXX，文件夹中包含了编译时所需的头文件，使用时直接#include&lt;XXXX&gt;即可） 链接器： 123常规-&gt;附加库目录：寻找.lib文件的搜索目录输入-&gt;附加依赖项：lib库（C++的库会把函数、类的声明放在*.h中，实现放在*.cpp或*.cc中。编译之后，*.cpp，*.cc，*.c会被打包成一个.lib文件，这样可以保护源代码） 区别与使用包含目录和附加包含目录（库目录和附加库目录）的区别：12345包含目录：修改了系统的include宏的值，是全局的；附加包含目录：用于当前项目，对其他项目没有影响。（库目录和附加库目录的区别同上） 可知包含目录和附加包含目录（库目录和附加库目录）的区别主要在于全局还是当前，那么当需要对某工程添加这些目录时，通常情况下，都是在附加包含目录和附加库目录中添加的。 要使用一个库，除了要include其头文件以外（附加包含目录），还要在链接过程中把lib加进去（附加库目录、附加依赖项）。 使用1234567891011附加包含目录---添加工程的头文件目录： 项目-&gt;属性-&gt;配置属性-&gt;C/C++-&gt;常规-&gt;附加包含目录：加上头文件的存放目录；附加库目录---添加文件引用的lib静态库路径： 项目-&gt;属性-&gt;配置属性-&gt;链接器-&gt;常规-&gt;附加库目录：加上lib文件的存放目录；附加依赖项---添加工程引用的lib文件名： 项目-&gt;属性-&gt;配置属性-&gt;链接器-&gt;输入-&gt;附加依赖项：加上lib文件名。 参考动态链接库DLL和静态链接库Lib的讲解，目前以lib后缀的库有两种，一种为静态链接库，另一种为动态连接库的导入库 (Import Libary，简称“导入库”）。动态链接库比较重要的文件有三个：.h .dll .lib；静态链接库比较重要的文件有两个：.h .lib。 当需要向项目中添加.dll动态链接库时，直接将需要添加的.dll文件拖拽到项目生成的.exe所在的文件夹下即可（项目-&gt;属性-&gt;配置属性-&gt;常规-&gt;输出目录，可以看到.exe生成在哪个目录下）。 在添加上述几个目录的路径的时候，可以看到$(xxxx)，这就是宏了，可以点开右下角的宏查看这些分别代表什么字符串。","tags":["vs"]},{"title":"奥比中光Femto Bolt相机","path":"/2024/02/27/奥比中光Femto-Bolt相机说明/","content":"几种深度相机对比参考了网上众多的资料，以下是其中一个视频中对市面上常见相机拍摄的点云结果对比，例如ZED MINI相机、OAK-D-LITE相机、OAK-D-PRO相机、D415相机、D435相机、Femto Bolt相机、Azure Kinect相机和L515相机等，如图所示。 其点云成像质量如下： 以上几款相机分别基于双目视觉、结构光和ToF飞行时间原理，从生成点云的质量效果上看，还是ToF原理的微软Kinect相机较好，如图所示。微软的深度相机依次经过以下几个版本的变化：Kinect V1、Kinect V2和Azure Kinect，目前以上三种深度相机都已停产。 Femto Bolt深度相机Femto Bolt深度相机是微软和奥比中光合作，在2023年10月最新推出的Azure Kinect的替代品，其相关硬件如图所示。 Femto Bolt 深度相机采用了微软最新的先进ToF传感技术，拥有与微软Azure Kinect深度相机完全一致的工作模式和性能表现，其拍摄的深度图效果如图所示。现Azure Kinect深度相机市场售价6000元左右，而Femto Bolt 深度相机价格2866元，综合比较可见Femto Bolt相机的性价比较高。","tags":["Orbbec"]},{"title":"linux-应用编程","path":"/2024/02/27/linux-应用编程/","content":"Linux应用编程Linux文件I&#x2F;O编程Linux系统中，I&#x2F;O的类型可以分为标准I&#x2F;O与文件I&#x2F;O。同时针对I&#x2F;O的操作模式，也实现了阻塞I&#x2F;O、非阻塞I&#x2F;O、多路复用I&#x2F;O以及异步I&#x2F;O，这四种典型的模型。 标准I&#x2F;O和文件I&#x2F;O是为了实现对文件读写而封装的两套不同的用户程序编程接口，文件I&#x2F;O采用直接系统调用的方式实现对文件的读写；标准I&#x2F;O采用间接系统调用（库函数）的方式实现对文件的读写。 .madkydqbtirp{zoom: 50%;} Linux文件结构在Linux中，一切都是文件。通常程序可以像使用文件那样使用磁盘文件、串行口、打印机和其他设备。大多数情况下，只需要使用5个基本的函数——open、close、read、write和ioctl。 文件，除了本身包含的内容以外，还有名字和一些属性，即”管理信息“，包括文件的创建、修改日期和访问权限。这些属性被保存在文件的inode节点中，这是文件系统中的一个特殊的数据块，同时它还包含文件的长度和文件在磁盘上的存放位置。 文件的类型（1）普通文件(regular file)。这种文件是最常见的文件类型，其数据形式可以是文本或二进制数据。 （2）目录文件(directory file)。这种文件包含其他类型文件的名字以及指向与这些文件有关的信息的指针。对一个目录文件具有读许可权的任一进程都可以读该目录文件的内容，但只有内核才有写目录文件的权限。 （3）字符设备文件(character special file)。这种文件被视为对字符设备的一种抽象，它代表的是应用程序对硬件设备的访问接口，Linux应用程序通过对该文件进行操作来实现对设备的访问。 （4）块设备文件(block special file)。这种文件类似于字符设备文件，只是它用于磁盘设备。Linux系统中的所有设备或者抽象为字符设备文件，或者为块设备文件。 （5）管道文件(pipe)。这种文件用于进程间的通信，有时也将其称为命名管道。 （6）套接字文件(socket)。这种文件用于进程间的网络通信，也可用于在一台宿主机上的进程之间的本地通信。 （7）符号链接文件(symbolic link)。这种文件指向另一个文件。 字符类型 说明 b 块设备文件 c 字符设备文件 d 目录 - 普通文件 l 链接文件 s 套接字文件 p 管道文件 在以上7种文件类型中，字符设备文件和块设备文件一般在学习linux驱动中使用，管道文件一般在进程通信中使用，套接字文件一般在Linux网络编程中使用，故这里暂时只对目录文件和符号链接文件进行说明。 目录文件目录也是文件，它是一种特殊类型的文件。不过在现代的Linux中，即使是超级用户可能也不再被允许直接对目录进行写操作了。 目录是用于保存其他文件的节点号和名字的文件。目录文件中的每个数据项都是指向某个文件节点的链接，删除文件名就等于删除与之对应的链接。文件的节点号可以通过ln -i命令查看，也可以通过使用ln命令在不同的目录中创建指向同一个文件的链接。 删除目录中的一个文件，实质是删除该文件所对应的目录项，此时指向该文件的链接数减1。但是，该文件中的数据可能仍然能够通过其他指向该文件的链接访问到。如果，指向该文件的链接数变为0（比如使用ls -l命令后，输出内容中访问权限后面的那个数字），就表示该节点以及其指向的数据不再被使用，磁盘上的相应位置的存储空间会被标记为可用空间。 目录中包含文件，也包含子目录，这构成了文件系统的层次结构。根目录&#x2F;位于目录层次最顶端，下面的各级目录例如&#x2F;bin、&#x2F;etc、&#x2F;lib等子目录包含着系统中的所有文件。对于现实中的硬件设备，Linux文件系统为这些设备提供接口的文件一般放在&#x2F;dev子目录中。 .fiydhjghzwce{zoom: 50%;} 符号链接文件符号链接文件类似于Windows系统的快捷方式，只保留目标文件的地址，而不用占用存储空间。使用链接文件和使用目标文件的效果是一样的。符号链接文件指定不同的访问权限，以控制对文件的共享和保证安全性。 Linux中有两种类型的链接：硬链接和软链接。 硬链接是利用Linux系统中为每个文件分配的物理编号i节点建立链接。因此，硬链接不能跨越文件系统。硬链接的文件属性基本与源文件是基本一致的，可以进行同步更新。这种方式类似于Windows系统中将文件复制一份。 软链接是利用文件的路径名建立链接。通常建立软链接使用绝对路径而不是相对路径，以最大限度保证可移植性。软链接更像是Windows中创建快捷方式。软链接权限不会改变源文件（目标文件）的权限。 硬链接和软链接的不同之处在于：源文件删除后，软链接无法定位到源文件，所以会显示没有文件；硬链接类似于复制，删除源文件，硬链接依然可以访问。假如删除源文件后，重新创建一个同名文件，软链接将恢复；硬链接则不再有效。因为文件的i节点已经改变。 需要注意的是，修改硬链接的目标文件名，硬链接依然有效，软链接将断开；对一个已存在的链接文件执行移动或删除操作，有可能导致链接的断开。 文件和设备硬件设备在Linux中通常被映射为文件，比较重要的设备文件有3个：&#x2F;dev&#x2F;console、&#x2F;dev&#x2F;tty、&#x2F;dev&#x2F;null。 &#x2F;dev&#x2F;console：该设备是系统控制台，错误和诊断的信息通常会被发送到这个设备。每个UNIX系统都会有一个指定的终端或显示屏用来接收控制台消息。 &#x2F;dev&#x2F;tty：如果一个进程有控制终端，那么该设备文件就是这个终端（例如键盘、显示屏）的别名。若是系统自动运行的进程和脚本就没有控制终端，无法打开&#x2F;dev&#x2F;tty。 &#x2F;dev&#x2F;null：该文件是空设备文件，所有写向这个设备的输出都将被丢弃。若读该设备会立刻返回一个文件尾标志，在cp命令中可以利用它做复制空文件的源文件。常把不需要的输出重定向到&#x2F;dev&#x2F;null。 &#x2F;dev设备中的其他设备包括：硬盘软盘、通信端口、磁带驱动器、CD-ROM、声卡等设备的名字随系统的不同而不同，Linux发行版通常提供超级用户使用的应用程序，来管理普通用户无法访问的设备，例如挂载文件系统的mount命令。 设备被分为字符设备和块设备。两者区别在于访问设备时是否需要一次读写一整块。一般情况下，块设备是那些支持某些类型文件系统的设备，例如硬盘。 系统调用说明API 应用程序接口API(Application Programming Interface) ，是程序员在用户空间下可以直接使用的函数接口，是一些预定义的函数，比如常用的read()、malloc()、free()、abs()函数等，这些函数都具有一定功能，说明了如何获得一个给定的服务，跟内核没有必然的联系。。 系统调用 操作系统负责管理和分配所有的计算机资源，为了更好地服务于应用程序，操作系统提供了一组特殊接口——系统调用接口层。系统调用接口层（System Call Iinterface，SCI）介于应用层与内核层之间（系统调用接口层不属于内核层，但它是由内核函数实现的）。为了安全考虑，应用程序不可以直接访问硬件资源。在单片机开发中，由于不需要操作系统，因此开发人员可以编写代码直接访问硬件；而在嵌入式系统中，通常需要操作系统，程序访问硬件资源的方式就发生了改变。 系统调用：使用少量的函数对文件和设备进行访问和控制。系统调用执行的流程如下： （1）应用程序代码调用封装的func()函数，该函数是一个包装的系统调用的函数。 （2）func()函数负责准备向内核传递参数，并触发软中断int 0x80切换到内核。 （3）CPU被软中断打断后，执行中断处理函数，即系统调用处理函数（system_call）。 （4）system_call调用系统调用服务例程（sys_func），真正开始处理该系统调用。 区别 api是函数的定义，规定了这个函数的功能，跟内核无直接关系。而系统调用是通过中断向内核发请求，实现内核提供的某些服务。 程序员调用的是API（API函数），然后通过与系统调用共同完成函数的功能。 因此，API是一个提供给应用程序的接口，一组函数，是与程序员进行直接交互的。系统调用则不与程序员进行交互的，它是根据API函数，通过一个软中断机制向内核提交请求，以获取内核服务的接口。 write系统调用系统调用write的作用是把缓冲区buf的前nbytes个字节写入与文件描述符fildes关联的文件中。它返回实际写入的字节数。如果文件描述符有错或者底层的设备驱动程序对数据块长度比较敏感，该返回值可能会小于nbytes。如果这个函数返回0，就表示未写入任何数据：如果它返回的是-1，就表示在writei调用中出现了错误，错误代码保存在全局变量errno里。 12#include &lt;unistd.h&gt;size t write(int fildes, const void *buf, size_t nbytes) 例子： 12345678#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;int main()&#123; if((write(1,&quot;Here is some data &quot;,18)) != 18) write(2,&quot;A write error has occurred on file descriptor 1 &quot;,46); exit (0);&#125; .qxevxyxxhmuq{zoom:67%;} read系统调用系统调用read的作用是：从与文件描述符fildes相关联的文件里读入nbytes个字节的数据，并把它们放到数据区buf中。它返回实际读入的字节数，这可能会小于请求的字节数。如果read调用返回0，就表示未读入任何数据，己到达了文件尾。同样，如果返回的是-1，就表示read调用出现了错误。 12#include &lt;unistd.h&gt;size_t read(int fildes, void *buf, size_t nbytes); open系统调用简单地说，open建立了一条到文件或设备的访问路径。如果调用成功，它将返回一个可以被read、writ和其他系统调用使用的文件描述符。这个文件描述符是唯一的，它不会与任何其他运行中的进程共享。如果两个程序同时打开同一个文件，它们会分别得到两个不同的文件描述符。如果它们都对文件进行写操作，那么它们会各写各的，它们分别接着上次离开的位置继续往下写。它们的数据不会交织在一起，而是彼此互相覆盖。两个程序对文件的读写位置（偏移值）不同。可以通过使用文件锁功能来防止出现冲突，在后面会介绍该功能。 12345678#include &lt;fcntl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;int open(const char *path, int oflags);int open(const char *path, int oflags, mode_t mode);#严格来说，在遵循POSIX规范的系统上，使用open系统调用并不需要包括头文件sys/types.h和sys/stat.h，但在某些UNIX系统上，它们可能是必不可少的。 of1ags参数是通过必需文件访问模式与其他可选模式相结合的方式来指定的，open调用必须指定表中所示的文件访问模式之一。 .aiofroeofoee{zoom:67%;} open调用还可以在oflags参数中包括下列可选模式的组合(用“按位或 | ”操作)。 O_APPEND:把写入数据追加在文件的末尾。 O_TRUNC:把文件长度设置为零，丢弃已有的内容。 O_CREAT:如果需要，就按参数mode中给出的访问模式创建文件。 O_EXCL:与O_CREAT一起使用，确保调用者创建出文件。Open调用是一个原子操作，也就是说，它只执行一个函数调用。使用这个可选模式可以防止两个程序同时创建同一个文件。如果文件己经存在，open调用将失败。其他可以使用的oflags值请参考open调用的手册页。 当使用带有O_CREAT标志的open调用来创建文件时，你必须使用有3个参数格式的open调用。第三个参数mode是几个标志按位或后得到的，这些标志在头文件sys&#x2F;stat.h.中定义，如下所示。 S_IRUSR:读权限，文件属主。 S_IWUSR:写权限，文件属主。 S_IXUSR:执行权限，文件属主。 S_IRGRP:读权限，文件所属组。 S_IWGRP:写权限，文件所属组。 S_IXGRP:执行权限，文件所属组。 S_IROTH:读权限，其他用户。 S_IW0TH:写权限，其他用户。 S_IXOTH:执行权限，其他用户。 看下面的例子： 1open (&quot;myfile&quot;,O_CREAT,S_IRUSR|S_IXOTH); 有几个因素会对文件的访问权限产生影响。首先，指定的访问权限只有在创建文件时才会使用；其次，用户掩码(由shell的umask命令设定)会影响到被创建文件的访问权限。open调用里给出的mode值将与当时的用户掩码的反值做AND操作。举例来说，如果用户掩码被设置为001，并且指定了SIOH模式标志，那么其他用户对创建的文件不会拥有执行权限，因为用户掩码中指定了不允许向其他用户提供执行权限。因此，open和creat调用中的标志实际上是发出设置文件访问权限的请求，所请求的权限是否会被设置取决于当时umask的值。 close系统调用你可以使用close调用终止文件描述符fildes与其对应文件之间的关联。文件描述符被释放并能够重新使用。close调用成功时返回0，出错时返回-1. 123#include &lt;unistd.h&gt;int close(int fildes); 注意，检查close调用的返回结果非常重要。有的文件系统，特别是网络文件系统，可能不会在关闭文件之前报告文件写操作中出现的错误，这是因为在执行写操作时，数据可能未被确认写入。 ioctl系统调用ioctl调用有点像是个大杂烩。它提供了一个用于控制设备及其描述符行为和配置底层服务的接口。原型如下： 12#include &lt;unistd.h&gt;int ioctl(int fildes, int cmd, ...); 其他系统调用lseek系统调用lseek系统调用对文件描述符fildes的读写指针进行设置。也就是说，你可以用它来设置文件的下一个读写位置。读写指针既可被设置为文件中的某个绝对位置，也可以把它设置为相对于当前位置或文件尾的某个相对位置。 1234#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;off_t lseek(int fildes, off_t offset, int whence); offset参数用来指定位置，而whence参数定义该偏移值的用法。whence可以取下列值之一。 SEEK_SET: offset是一个绝对位置。 SEEK_CUR: offset是相对于当前位置的一个相对位置。 SEEK_END: offset是相对于文件尾的一个相对位置。 lseek返回从文件头到文件指针被设置处的字节偏移值，失败时返回-1。参数offset的类型off_t是一个与具体实现有关的整数类型，它定义在头文件sys&#x2F;types.h中。 fstat、stat和lstat系统调用fstat系统调用返回与打开的文件描述符相关的文件的状态信息，该信息将会写到一个buf结构中，buf的地址以参数形式传递给fstat。下面是它们的原型： 1234567#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;int fstat(int fildes, struct stat *buf);int stat(const char *path, struct stat *buf);int lstat(const char *path, struct stat *buf); 注意：包含头文件sys/types.h是可选的，但由于一些系统调用的定义针对那些某天可能会做出调整的标准类型使用了别名，所以但在程序中使用系统调用时，我们还是推荐将这个头文件包含进去。 相关函数stat和lstat返回的是通过文件名查到的状态信息。它们产生相同的结果，但当文件是一个符号链接时，lstat返回的是该符号链接本身的信息，而stat返回的是该链接指向的文件的信息。stat结构的成员在不同的类UNIX系统上会有所变化，但一般会包括表中所示的内容。 .ejjserjenolw{zoom:67%;} dup和dup2系统调用dup系统调用提供了一种复制文件描述符的方法，使我们能够通过两个或者更多个不同的描述符来访问同一个文件。这可以用于在文件的不同位置对数据进行读写。dup系统调用复制文件描述符fildes，返回一个新的描述符。dup2系统调用则是通过明确指定目标描述符来把一个文件描述符复制为另外一个。它们的原型如下： 1234#include &lt;unistd.h&gt;int dup(int fildes);int dup2(int fildes, int fildes2); 文件维护相关调用chmod系统调用可以通过chmod系统调用来改变文件或目录的访问权限。这构成了shell程序chmod的基础。该函数原型如下： 123#include &lt;sys/stat.h&gt;int chmod(const char *path,mode_t mode); path参数指定的文件被修改为具有mode参数给出的访问权限。参数mode的定义与open系统调用中的一样，也是对所要求的访问权限进行按位OR操作。除非程序被赋予适当的特权，否则只有文件的属主或超级用户可以修改它的权限。 chown系统调用超级用户可以使用chown系统调用来改变一个文件的属主。 1234#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int chown(const char *path, uid_t owner, gidt group); 这个调用使用的是用户ID和组D的数字值(通过getuid和getgid调用获得)和一个用于限定谁可以修改文件属主的系统值。如果已经设置了适当的特权，文件的属主和所属组就会改变。 unlink、link和symlink系统调用可以使用unlink系统调用来删除一个文件。unlink系统调用删除一个文件的目录项并减少它的链接数。它在成功时返回0，失败时返回-1。如果想通过调用这个函数来成功别除文件，就必须拥有该文件所属目录的写和执行权限。 12345#include &lt;unistd.h&gt;int unlink(const char *path);int link(const char *pathl,const char *path2);int symlink(const char *path1,const char *path2); 如果一个文件的链接数减少到零，并且没有进程打开它，这个文件就会被别除。事实上，目录项总是被立刻删除，但文件所占用的空间要等到最后一个进程（如果有的话）关闭它之后才会被系统回收。程序使用的就是这个调用。文件上其他的链接表示这个文件还有其他名字，这通常是由ln程序创建的。你可以使用link系统调用在程序中创建一个文件的新链接。 mkdir和rmdir系统调用可以使用mkdir和rmdir系统调用来建立和删除目录。 1234#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;int mkdir(const char *path,mode_t mode); mkdir系统调用用于创建目录，它相当于mkdir程序。mkdir调用将参数path作为新建目录的名字。目录的权限由参数mode设定，其含义将按open系统调用的O_CREAT选项中的有关定义设置。当然，它还要服从umask的设置情况。 123#include &lt;unistd.h&gt;int rmdir(const char *path); rmdir系统调用用于删除目录，但只有在目录为空时才行。rmdir程序就是用这个系统调用来完成工作的。 chdir系统调用和getcwd函数程序可以像用户在文件系统里那样来浏览目录。就像你在shell里使用cd命令来切换目录一样，程序使用的是chdir系统调用。 123#include &lt;unistd.h&gt;int chdir(const char *path); 程序可以通过调用getcwd函数来确定自己的当前工作目录。 123#include &lt;unistd.h&gt;char *getcwd(char *buf,size_t size); getcwd函数把当前目录的名字写到给定的缓冲区buf里。如果目录名的长度超出了参数size给出的缓冲区长度(一个ERANGE错误)，它就返回NULL。如果成功，它返回指针buf。 如果在程序运行过程中，目录被删除(EINVAL错误)或者有关权限发生了变化（EACCESS错误），getcwd也可能会返回NULL. 目录扫描相关调用Linux系统上一个常见问题就是扫描目录，也就是确定一个特定目录下存放的文件。在shell程序设计中，这很容易做到——只需让shell做一次表达式的通配符扩展。在过去，UNIX操作系统的各种变体都允许用户通过编程访问底层文件系统结构。你仍然可以把目录当作一个普通文件那样打开，并直接读取目录数据项，但不同的文件系统结构及其实现已经使这种方法没什么可移植性了。现在，一整套标准的库函数已经被开发出来，使得目录的扫描工作变得简单多了。 与目录操作有关的函数在dirent.h头文件中声明。它们使用一个名为DIR的结构作为目录操作的基础。被称为目录流的指向这个结构的指针(DIR*)被用来完成各种目录操作，其使用方法与用来操作普通文件的文件流(FILE*)非常相似。目录数据项本身则在dirent结构中返回，该结构也是在dirent.h头文件里声明的，这是因为用户不应直接改动DIR结构中的数据字段。 dirent结构中包含的目录项内容包括以下部分。 ino_t dino: 文件的inode节点号。 char d_name[ ]: 文件的名字。 下面将介绍下面这几个函数： opendir、closedir readdir telldir seekdir closedir opendir函数opendiri函数的作用是打开一个目录并建立一个目录流。如果成功，它返回一个指向DIR结构的指针，该指针用于读取目录数据项。 1234#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;DIR *opendir(const char *name); opendir在失败时返回一个空指针。注意，目录流使用一个底层文件描述符来访问目录本身，所以如果打开的文件过多，opendir可能会失败。 readdir函数readdir函数返回一个指针，该指针指向的结构里保存着目录流dirp中下一个目录项的有关资料。后续的readdir调用将返回后续的目录项。如果发生错误或者到达目录尾，readdir将返回NULL。POSIX兼容的系统在到达目录尾时会返回NULL,但并不改变erno的值，只有在发生错误时才会设置errno。 1234#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;struct dirent *readdir(DIR *dirp); 注意，如果在readdir函数扫描目录的同时还有其他进程在该目录里创建或删除文件，readdir将不保证能够列出该目录里的所有文件（和子目录）。 telldir函数telldir函数的返回值记录着一个目录流里的当前位置。你可以在随后的seekdir调用中利用这个值来重置目录扫描到当前位置。 1234#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;long int telldir(DIR *dirp); seekdir函数seekdir函数的作用是设置目录流dirp的目录项指针。loc的值用来设置指针位置，它应该通过前一个telldir调用获得。 1234#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;void seekdir(DIR *dirp, long int loc); closedir函数closedir函数关闭一个目录流并释放与之关联的资源。它在执行成功时返同0，发生错误时返回-1。 12345#include &lt;sys/types.h&gt;#include &lt;dirent.h&gt;int closedir(DIR *dirp); 错误处理调用前面介绍的许多系统调用和函数都会因为各种各样的原因而失败。它们会在失败时设置外部变量errno的值来指明失败的原因。许多不同的函数库都把这个变量用做报告错误的标准方法。值得重申的是，程序必须在函数报告出错之后立刻检查errno变量，因为它可能被下一个函数调用所覆盖，即使下一个函数自身并没有出错，也可能会覆盖这个变量。 错误代码的取值和含义都列在头文件errno.h里，如下所示。 EPERM:操作不允许。 ENOENT:文件或目录不存在。 EINTR:系统调用被中断。 EIO:I&#x2F;O错误。 EBUSY:设备或资源忙。 EEXIST:文件存在。 EINVAL:无效参数。 EMFILE:打开的文件过多。 ENODEV:设备不存在。 EISDIR:是一个目录。 ENOTDIR:不是一个目录。 有两个非常有用的函数可以用来报告出现的错误，它们是strerror和perror. strerror函数strerror函数把错误代码映射为一个字符串，该字符串对发生的错误类型进行说明。这在记录错误条件时十分有用。 该函数原型如下： 123#include &lt;string.h&gt;char *strerror(int errnum); 它可能在标准错误输出中给出如下的输出结果： program: Too many open files perror函数perror函数也把errno变量中报告的当前错误映射到一个字符串，并把它输出到标准错误输出流。该字符串的前面先加上字符串s（如果不为空）中给出的信息，再加上一个冒号和一个空格。 该函数原型如下： 123#include &lt;stdio.h&gt;void perror(const char *s); 高级主题：fcntl和mmap该部分较少使用。 fcntl系统调用fcntl系统调用对底层文件描述符提供了更多的操纵方法。 1234#include &lt;fcntl.h&gt;int fcntl(int fildes, int cmd);int fcntl(int fildes, int cmd, long arg); 利用fcntl系统调用，你可以对打开的文件描述符执行各种操作，包括对它们进行复制、获取和设置文件描述符标志、获取和设置文件状态标志，以及管理建议性文件锁等。 对不同操作的选择是通过选取命令参数cmd不同的值来实现的，其取值定义在头文件fcntl.h中。根据所选择命令的不同，系统调用可能还需要第三个参数arg。 fcntl(fildes, F_DUPFD, newfd): 这个调用返回一个新的文件描述符，其数值等于或大于整数newfd。新文件描述符是描述符fildes的一个副本。根据已打开文件数目和newfd值的情况，它的效果可能和系统调用dup(fildes)完全一样。 fcntl(fildes, F_GETFD): 这个调用返回在fcntl.h头文件里定义的文件描述符标志，其中包括FD_CLOEXEC，它的作用是决定是否在成功调用了某个exec系列的系统调用之后关闭该文件描述符。 fcntl(fildes, F_SETFD, flags): 这个调用用于设置文件描述符标志，通常仅用来设置FD_CLOEXEC。 fcntl(fildes, F_GETFL)和fcntl(fildes, F_SETFL, flags): 这两个调用分别用来获取和设置文件状态标志和访问模式。你可以利用在fcntl.h头文件中定义的掩码O_ACCMODE来提取出文件的访问模式。其他标志包括那些当open调用使用O_CREAT打开文件时作为第三参数出现的标志。注意，你不能设置所有的标志，特别是不能通过fcntl设置文件的权限。 mmap函数UNX提供了一个有用的功能以允许程序共享内存，Liux内核从2.0版本开始已经把这一功能包括进来。map（内存映射）函数的作用是建立一段可以被两个或更多个程序读写的内存。一个程序对它所做出的修改可以被其他程序看见。 这要通过使用带特殊权限集的虚拟内存段来实现。对这类虚拟内存段的读写会使操作系统去读写磁盘文件中与之对应的部分。 mmap函数创建一个指向一段内存区域的指针，该内存区域与可以通过一个打开的文件描述符访问的文件的内容相关联。 123#include &lt;sys/mman.h&gt;void *mmap(void *addr, size_t len, int prot, int flags, int fildes, off_t off); 通过传递off参数来改变经共享内存段访问的文件中数据的起始偏移值。 打开的文件描述符由fildes参数给出。 可以访问的数据量（即内存段的长度）由len参数设置。 你可以通过addr参数来请求使用某个特定的内存地址。如果它的取值是零，结果指针就将自动分配。这是推荐的做法，否则会降低程序的可移植性，因为不同系统上的可用地址范围是不一样的。 Prot参数用于设置内存段的访问权限。它是下列常数值的按位OR结果。 PROT_READ: 允许读该内存段。 PROT_WRITE: 允许写该内存段。 PROT_EXEC: 允许执行该内存段。 PROT_NONE: 该内存段不能被访问。 flags参数控制程序对该内存段的改变所造成的影响，可以使用的选项如下。 MAP_PRIVATE: 内存段是私有的，对它的修改只对本进程有效。 MAP_SHARED: 把对该内存段的修改保存到磁盘文件中。 MAP_FIXED: 该内存段必须位于addr指定的地址处。 msync函数的作用是：把在该内存段的某个部分或整段中的修改写回到被映射的文件中（或者从被映射文件里读出）。 123#include &lt;sys/mman.h&gt;int msync(void *addr, size_t len, int flags); 内存段需要修改的部分由作为参数传递过来的起始地址addr和长度len确定。flags参数控制着执行修改的具体方式，可以使用的选项如下。 MS_ASYNC: 采用异步写方式 MS_SYNC: 采用同步写方式 MS_INVALIDATE: 从文件中读回数据 munmap函数的作用是释放内存段： 123#include &lt;sys/mman.h&gt;int munmap(void *addr, size_t len); &#x2F;proc文件系统Linux提供了一个特殊的文件系统procfs,它通常以&#x2F;proc目录的形式呈现。该目录中包含了许多特殊文件用来对驱动程序和内核信息进行更高层的访问。只要应用程序有正确的访问权限，它们就可以通过读写这些文件来获得信息或设置参数。 &#x2F;proc目录中的文件会随系统的不同而不同，当Linux&#x2F;版本中有更多的驱动程序和设施支持procfs文件系统时，该目录中就会包含更多的文件。在这里，将介绍一些&#x2F;proc目录中常用的文件，并简单讨论它们的用途。 .ocmripgsjdmp{zoom: 50%;} 在多数情况下，只需直接读取这些文件就可以获得状态信息。 例如，&#x2F;proc&#x2F;cpuinfo给出的是cpu的详细信息： .qypyfzmgbqnr{zoom: 50%;} 类似地，&#x2F;proc&#x2F;meminfo和&#x2F;proc&#x2F;version分别给出的是内存使用情况和内核版本信息。 你可以通过特定内核函数获得更多的信息，它们位于&#x2F;proc目录的子目录中。例如，你可以通过&#x2F;proc&#x2F;net&#x2F;sockstat文件获得网络套接字的使用统计。 proc目录中的有些条目不仅可以被读取，而且可以被修改。例如，系统中所有运行的程序同时能打开的文件总数是Linux内核的一个参数。它的当前值可通过读取&#x2F;proc&#x2F;sys&#x2F;fs&#x2F;fi1e-max文件得到。 &#x2F;proc目录中以数字命名的子目录用于提供正在运行的程序的信息。 Linux标准I&#x2F;O编程标准I&#x2F;O库概述针对输入输出操作直接使用底层系统调用的一个问题是它们的效率非常低： 使用系统调用会影响系统的性能。与函数调用相比，系统调用的开销要大些，因为在执行系统调用时，Linux必须从运行用户代码切换到执行内核代码，然后再返回用户代码。减少这种开销的一个好方法是，在程序中尽量减少系统调用的次数，并且让每次系统调用完成尽可能多的工作。例如，每次读写大量的数据而不是每次仅读写一个字符。 硬件会限制对底层系统调用一次所能读写的数据块大小。 为了给设备和磁盘文件提供更高层的接口，Linux发行版(和UNIX)提供了一系列的标准函数库。它们是一些由函数构成的集合，你可以把它们应用到自己的程序中，比如提供输出缓冲功能的标准&#x2F;O库。你可以高效地写任意长度的数据块，库函数则在数据满足数据块长度要求时安排执行底层系统调用。这就极大降低了系统调用的开销。 库函数有一个与之对应的标准头文件，例如与标准I&#x2F;O库对应的头文件是stdio.h。下图是对前面讨论的总结，它显示了Linux系统中各种文件函数与用户、设备驱动程序、内核和硬件之间的关系。 .eftqjmupnudj{zoom:67%;} 标准I&#x2F;O库(stdio)及其头文件stdio.h为底层I&#x2F;O系统调用提供了一个通用的接口。这个库现在已经成为ANSI标准C的一部分，而前面见到的系统调用却还不是。标准I&#x2F;O库提供了许多复杂的函数用于格式化输出和扫描输入。它还负责满足设备的缓冲需求。 在很多方面，你使用标准&#x2F;O库的方式和使用底层文件描述符一样。你需要先打开一个文件以建立一个访问路径。这个操作的返回值将作为其他I&#x2F;O库函数的参数。在标准I&#x2F;O库中，与底层文件描述符对应的是流(stream)，它被实现为指向结构FILE的指针。 注意，不要把这里的文件流与C++语言中的输入输出流(iostream)以及AT&amp;T UNIX System V Release3中引入的进程间通信中的STREAMS模型相混淆，STEAMS模型不在本书的讨论范围之内。要想进一步了解STREAMS,请查阅X/Open规范(http:/www.opengroup.org)和随System V)版本一起提供的AT&amp;T STREAMS Programming Guide(《AT&amp;T STREAMS程序设计指南》）。 在启动程序时，有3个文件流是自动打开的。它们是stdin、stdout和stderr。它们都是在stdio.h头文件里定义的，分别代表着标准输入、标准输出和标准错误输出，与底层文件描述符0、1和2相对应。 下面主要介绍标准&#x2F;O库中的下列库函数： fopen、fclose fread、fwrite fflush- fseek- fgetc、getc、getchar fputc、putc、putchar fgets、gets printf、fprintf和sprintf scanf、fscanf和sscanf fopen函数fopen库函数类似于底层的open系统调用。它主要用于文件和终端的输入输出。如果需要对设备进行明确的控制，那最好使用底层系统调用，因为这可以避免用库函数带来的一些潜在问题，如输入输出缓冲。 该函数原型如下： 12#include &lt;stdio.h&gt;FILE *fopen(const char *filename, const char *mode); fopen:打开由filename参数指定的文件，并把它与一个文件流关联起来。mode参数指定文件的打开方式，它取下列字符串中的值。 “r”或”rb”:以只读方式打开。 “w”或”wb”:以写方式打开，并把文件长度截短为零。 “a”或”ab”:以写方式打开，新内容追加在文件尾。 “r+”或”rb+”或”r+b”:以更新方式打开（读和写）。 “w+”或”wb+”或”w+b”:以更新方式打开，并把文件长度截短为零。 “a+”或”ab+”或”a+b”:以更新方式打开，新内容追加在文件尾。 字母b表示文件是一个二进制文件而不是文本文件。 请注意，UNIX和Linux并不像MS-DOS那样区分文本文件和二进制文件。UNIX和Linux把所有文件都看作为二进制文件。另一个需要注意的地方是mode参数，它必须是一个字符串，而不是一个字符。所以总是应该使用双引号，而不是单引号。 fopen在成功时返回一个非空的FILE*指针，失败时返回ULL值，NULL值在头文件stdio.h里定义。可用的文件流数量和文件描述符一样，都是有限制的。实际的限制是由头文件stio.h中定义的FOPEN_MAX来定义的，它的值至少为8，在Linux系统中，通常是16。 fread函数fread库函数用于从一个文件流里读取数据。数据从文件流stream读到由ptr指向的数据缓冲区里。fread和fwrite都是对数据记录进行操作，size参数指定每个数据记录的长度，计数器nitems给出要传输的记录个数。它的返回值是成功读到数据缓冲区里的记录个数（而不是字节数）。当到达文件尾时，它的返回值可能会小于nitems，甚至可以是零。 该函数原型如下： 123#include &lt;stdio.h&gt;size_t fread(void *ptr, size_t size, size_t nitems, FILE *stream); fwrite函数fwrite库函数与fread有相似的接口。它从指定的数据缓冲区里取出数据记录，并把它们写到输出流中。它的返回值是成功写入的记录个数。 该函数原型如下： 123#include &lt;stdio.h&gt;size_t fwrite (const void *ptr, size_t size, size_t nitems, FILE *stream); 注意，不推荐把fread和fwrite用于结构化数据。部分原因在于用fwrite写的文件在不同的计算机体系结构之间可能不具备可移植性。 fclose函数fclose库函数关闭指定的文件流stream,使所有尚未写出的数据都写出。因为stdio库会对数据进行缓冲，所以使用fclose是很重要的。如果程序需要确保数据已经全部写出，就应该调用fclose函数。虽然当程序正常结束时，会自动对所有还打开的文件流调用fcIose函数，但这样做就没有机会检查由fclose报告的错误了。 该函数原型如下： 123#include &lt;stdio.h&gt;int fclose(FILE *stream); fflush函数fflush库函数的作用是把文件流里的所有未写出数据立刻写出。例如，可以用这个函数来确保在试图读入一个用户响应之前，先向终端送出一个交互提示符。使用这个函数还可以确保在程序继续执行之前重要的数据都已经被写到磁盘上。有时在调试程序时，还可以用它来确认程序是正在写数据而不是被挂起了。注意，调用fclose函数隐含执行了一次flush操作，所以你不必在调用fclose之前调用fflush。 该函数原型如下： 123#include &lt;stdio.h&gt;int fflush(FILE *stream); fseek函数fseek函数是与lseek系统调用对应的文件流函数。它在文件流里为下一次读写操作指定位置。offset和whence参数的含义和取值与前面的lseek系统调用完全一样。但lseek返回的是一个off_t数值，而fseek返回的是一个整数：0表示成功，-1表示失败并设置errno指出错误。 该函数原型如下： 123#include &lt;stdio.h&gt;int fseek(FILE *stream, long int offset, int whence); fgetc、getc和getchar函数fgetc函数从文件流里取出下一个字节并把它作为一个字符返回。当它到达文件尾或出现错误时，它返回EOF，必须通过ferror或feof来区分这两种情况。 这些函数的原型如下： 12345#include &lt;stdio.h&gt;int fgetc(FILE *stream);int getc(FILE *stream);int getchar(); getc函数的作用和fgetc一样，但它有可能被实现为一个宏，如果是这样，stream参数就可能被计算不止一次，所以它不能有副作用(例如，它不能影响变量)。此外，你也不能保证能够使用getc的地址作为一个函数指针。getchar函数的作用相当于getc(stdin)，它从标准输入里读取下一个字符。 fputc、putc和putchar函数futc函数把一个字符写到一个输出文件流中。它返回写入的值，如果失败，则返回EOF。 12345#include &lt;stdio.h&gt;int fputc(int c,FILE *stream);int putc(int c,FILE *stream);int putchar(int c); 类似于fgetc和getc之间的关系，putc函数的作用也相当于fputc,但它可能被实现为一个宏。putchar函数相当于putc(c,stdout)，它把单个字符写到标准输出。注意，putchar和getchar都是把字符当作int类型而不是char类型来使用的。这就允许文件尾(EOF)标识取值-1，这是一个超出字符数字编码范围的值。 fgets和gets函数fgets函数从输入文件流stream里读取一个字符串。 1234#include &lt;stdio.h&gt;char *fgets(char *s, int n, FILE *stream);char *gets(char *s); fgets把读到的字符写到s指向的字符串里，直到出现下面某种情况：遇到换行符，己经传输了n-1个字符，或者到达文件尾。它会把遇到的换行符也传递到接收字符串里，再加上一个表示结尾的空字节\\0。一次调用最多只能传输n-1个字符，因为它必须把空字节加上以结束字符串。 当成功完成时，fgets返回一个指向字符串s的指针。如果文件流己经到达文件尾，fgets会设置这个文件流的EOF标识并返回一个空指针。如果出现读错误，fgets返回一个空指针并设置errno以指出错误的类型。 gets函数类似于fgets,只不过它从标准输入读取数据并丢弃遇到的换行符。它在接收字符串的尾部加上一个null字节。 注意：gets对传输字符的个数并没有限制，所以它可能会溢出自己的传输缓冲区。因此，应该避免使用它并用fgets来代替。许多安全问题都可以追溯到在程序中使用了可能造成各种缓冲区溢出的函数，gets就是一个这样的函数，所以千万要小心！ printf、fprintf和sprintf函数1234#include &lt;stdio.h&gt;int printf(const char *format, ...);int sprintf (char *s, const char *format, ...);int fprintf(FILE *stream, const char *format,...); printf函数把自己的输出送到标准输出。fprintf函数把自己的输出送到一个指定的文件流。sprintf函数把自己的输出和一个结尾空字符写到作为参数传递过来的字符串s里。这个字符串必须足够容纳所有的输出数据。 普通字符在输出时不发生变化。转换控制符让printf取出传递过来的其他参数并对它们的格式过行编排。转换控制符总是以%字符开头。下面是一些常用的转换控制符。 %d, %i: 以十进制格式输出一个整数。 %o, %x: 以八进制或十六进制格式输出一个整数。 %c: 输出一个字符。 %s: 输出一个字符串。 %f: 输出一个（单精度）浮点数。 %e: 以科学计数法格式输出一个双精度浮点数。 %g：以通用格式输出一个双精度浮点数。 scanf、fscanf和sscanf函数scanf系列函数的工作方式与printf系列函数很相似，只是前者的作用是从一个文件流里读取数据，并把数据值放到以指针参数形式传递过来的地址处的变量中。它们也使用一个格式字符串来控制输入数据的转换，它所使用的许多转换控制符都与printf系列函数的一样。 12345#include &lt;stdio.h&gt;int scanf(const char *format, ...);int fscanf(FILE *stream,const char *format,...);int sscanf(const char *s, const char *format, ...); scanf函数读入的值将保存到对应的变量里去，这些变量的类型必须正确，并且它们必须精确匹配格式字符串。否则，内存数据就可能会遭到破坏，从而使程序崩溃。编译器是不会对此做出错误提示的，但如果你运气够好，你可能会看到一个警告信息！ scanf系列函数的format格式字符串里同时包含着普通字符和转换控制符，就像printf函数中一样。但在scanf系列函数中，那些普通字符是用于指定在输入数据里必须出现的字符。 其他流函数stdio函数库里还有一些其他的函数使用流参数或标准流stdin、stdout和stderr,如下所示。 fgetpos: 获得文件流的当前（读写）位置。 fsetpos: 设置文件流的当前（读写）位置。 ftell: 返回文件流当前（读写）位置的偏移值。 rewind: 重置文件流里的读写位置。 freopen: 重新使用一个文件流。 setvbuf: 设置文件流的缓冲机制。 remove: 相当于unlink函数，但如果它的path参数是一个目录的话，其作用就相当于rmdir函数。 文件流错误为了表明错误，许多stdio库函数会返回一个超出范围的值，比如空指针或EOF常数。此时，错误由外部变量errno指出： 123# include &lt;errno.h&gt;extern int errno; 注意，许多函数都可能改变errno的值。它的值只有在函数调用失败时才有意义。你必须在函数表明失败之后立刻对其进行检查。你应该总是在使用它之前将它先复制到另一个变量中，因为像fprintf这样的输出函数本身就可能改变errno的值。 你也可以通过检查文件流的状态来确定是否发生了错误，或者是否到达了文件尾。 12345#include &lt;stdio.h&gt;int ferror(FILE *stream);int feof(FILE *stream);void clearerr(FILE *stream) ferror函数测试一个文件流的错误标识，如果该标识被设置就返回一个非零值，否则返回零。 feof函数测试一个文件流的文件尾标识，如果该标识被设置就返回非零值，否则返回零。我们可以像下面这样使用它： if(feof (some_stream)) clearerr函数的作用是清除由stream指向的文件流的文件尾标识和错误标识。它没有返回值，也未定义任何错误。你可以通过使用它从文件流的错误状态中恢复。例如，在“磁盘己满”错误解决之后，继续开始写入文件流。 文件流和文件描述符每个文件流都和一个底层文件描述符相关联。你可以把底层的输入输出操作与高层的文件流操作混合使用，但一般来说，这并不是一个明智的做法，因为数据缓冲的后果难以预料。 1234#include &lt;stdio.h&gt;int fileno(FILE *stream);FILE *fdopen(int fildes, const char *mode); 你可以通过调用fileno函数来确定文件流使用的是哪个底层文件描述符。它返回指定文件流使用的文件描述符，如失败就返回-1。如果你需要对一个己经打开的文件流进行底层访问时（例如，对它调用fstat)，这个函数将很有用。 你可以通过调用fdopen函数在一个己打开的文件描述符上创建一个新的文件流。实质上，这个函数的作用是为一个已经打开的文件描述符提供stio缓冲区，这样解释可能更容易理解一些。 fdopen函数的操作方式与fopen函数是一样的，只是前者的参数不是一个文件名，而是一个底层的文件描述符。如果你已经通过open系统调用创建了一个文件（可能是出于为了更好地控制其访问权限的目的），但又想通过文件流来对它进行写操作，这个函数就很有用了。fdopen函数的mode参数与fopen函数的完全一样，但它必须符合该文件在最初打开时所设定的访问模式。fdopen返回一个新的文件流，失败时返回NULL。 Linux 进程编程进程间通信每种系统IPC进程间通信方式不十分一致，Linux综合了多个UNIX系统，主要有7种方式： file 文件 pipe 管道 singal 信号 System V IPC 机制 semophore 信号量 semophore 共享内存 message queue 消息队列 socket 套接字 pipe管道当从一个进程连接数据流到另一个进程时，使用管道pipe。 例如shell中输入命令：cmd1 | cmd2，该命令经历以下过程： cmd1的标准输入来自终端键盘。 cmd1的标准输出传递给cmd2，作为它的标准输入。 cmd2的标准输出连接到终端屏幕。 管道使用1234#include &lt;stdio.h&gt;FILE *popen(const char *command, const char *open_mode);int pclose(FILE *stream_to_close); popen函数允许一个程序将另外一个程序作为新进程来启动，他们之间可以传递数据。需要注意，一个管道只能单向传输信息，若想实现双向通信，需要使用两个管道。 参数command为要运行的程序名和相应参数 参数open_mode取值为“r”时，调用popen的程序能够接收另外那个进程输出的数据，只需要使用标准I&#x2F;O库stdio中的函数（如fread函数）解析popen返回的FILE文件流即可；取值为“w”时，调用程序能够使用fwrite函数发送数据到另外那个进程，该进程可以从标准输入流中解析接收到的数据，一般来说进程并不知道接收到的数据是不是其他进程发送的，它只是简单地从标准输入流中接收并解析。 pclose函数负责关闭popen开启的文件流，并返回文件流关闭的退出码。pclose会一直等待popen完成后才执行，若调用程序在pclose执行前使用wait语句，那么退出状态会丢失，这时候返回-1，同时errno设置为ECHILD。 先进先出管道：FIFOs为了在不相关的两个程序（即不是由共同祖先进程创建的）间进行数据传递，可以使用FIFOs，也称为命名管道named pipes。命名管道是一种特殊类型的文件（Linux中一切皆文件），在文件系统中有文件名，但行为和没有命名的管道类似。 可以使用命令行或者在程序中创建，命令行方法为输入mkfifo filename，在程序中创建方法如下。 12345#include &lt;sys/types.h&gt;#include &lt;syd/stat.h&gt;int mkfifo(const char *filename, mode_t mode);int mknod(const char *filename, mode_t mode | S_IFIFO, (dev_t) 0); mknod函数能创建许多特殊类型的文件，但唯一具有可移植性的方法是使用一个dev_t类型的0值，并将访问模式与S_IFIFO按位“或”。 1、使用open打开FIFO文件 使用open打开FIFO文件的主要限制是不能以O_RDWR的模式，因为管道是单向使用的，同样若想双向传递数据，应该使用两个FIFO。 打开FIFO文件和普通文件的区别是open函数第二个参数open_flag的O_NONBLOCK。使用该模式不仅会改变open函数的调用方式，还会改变open根据返回的文件描述符进行的读写请求方式。4种合法的结合形式如下： open(const char *path, O_RDONLY); open(const char *path, O_RDONLY | O_NONBLOCK); open(const char *path, O_WRONLY); open(const char *path, O_WRONLY | O_NONBLOCK); 信号信号是UNIX和Linux系统响应某些条件而产生的一个事件。接收到该信号的进程会相应地采取一些行动。我们用术语生成(raise)表示一个信号的产生，使用术语捕获(catch)表示接收到一个信号。信号是由于某些错误条件而生成的，如内存段冲突、浮点处理器错误或非法指令等。它们由shell和终端处理器生成来引起中断，它们还可以作为在进程间传递消息或修改行为的一种方式，明确地由一个进程发送给另一个进程。无论何种情况，它们的编程接口都是相同的。信号可以被生成、捕获、响应或（至少对于一些信号）忽略。 信号的名称是在头文件signal.h中定义的。它们以SIG开头，见表。 如果进程接收到上面这些信号中的一个，但事先没有安排捕获它，进程将会立刻终止。通常，系统将生成核心转储文件core，并将其放在当前目录下。该文件是进程在内存中的映像，它对程序的调试很有用处。 其他信号： 发送信号进程可以通过调用kill函数向包括它本身在内的其他进程发送一个信号。如果程序没有发送该信号的权限，对kill函数的调用就将失败，失败的常见原因是目标进程由另一个用户所拥有。这个函数和同名的shell命令完成相同的功能，它的定义如下所示： 1234#include &lt;sys/types.h&gt;#include &lt;signal.h&gt;int kill(pid_t pid, int sig); 信号向我们提供了一个有用的闹钟功能。进程可以通过调用alam函数在经过预定时间后发送一个SIGALRM信号。 123#include &lt;unistd.h&gt;unsigned int alarm(unsigned int seconds); pause函数能将当前程序挂起直到有一个信号出现为止。 123#include &lt;unistd.h&gt;int pause(void); sigaction函数。上面的相关函数在传统的UNIX编程中较常见，而X&#x2F;Open和UNIX规范实现了更加强大的sigaction接口。 123#include &lt;signal.h&gt;int sigaction(int sig, const struct sigaction *act, struct sigaction *oact); sigaction结构至少包括以下成员：void (*) (int) sa_handler、sigset_t sa_mask、int sa_flags。sa_handler为函数指针，指向收到信号sig后将调用的信号处理函数；sa_mask为信号集，在调用sa_handler指向的函数前，会先将其加入到信号屏蔽字中，其包含了将被阻塞且不会传递给该进程的信号。 IPC机制：信号量、共享内存和消息队列信号量12345#include &lt;sys/sem.h&gt;int semctl(int sem_id, int semm_num, int command, ...);int semget(key_t key, int num_sems, int sem_flags);int semop(int sem_id, struct sembuf *sem_ops, size_t num_sem_ops); semget函数用于创建一个新信号量或取得一个已有信号量的键。程序对所有信号量的访问都是间接的，它先提供一个信号量键，再由系统生成一个相应的信号量标识符。只有semget函数能直接使用信号量键，其他信号量函数都是使用semget函数返回的信号量标识符。参数key是信号量键，不相关的进程可以通过它访问同一个信号量；参数num_ssems指定需要的信号量数目，取值一般为1；参数sem_flags和open函数的标志相似。 semop函数用于改变信号量的值。 参数sem_id是semget返回的信号量标识符 参数sem_ops是指向一个结构数组的指针，该结构数组包含以下成员struct sembuf&#123;short sem_num; short sem_op; short sem_flg;&#125;。成员sem_num为信号量编号，除非需要使用一组信号量，否则取值一般为0；成员sem_op为一次操作需要改变的数值，通常用到-1和+1两个值，-1为p操作表示它等待信号量变为可用，+1为v操作，此时它发送信号表示信号量现在可用；成员sem_flg一般被设置为SEM_UNDO，操作系统将跟踪当前进程对这个信号量的修改情况，若进程在没有释放该信号量的情况下终止，操作系统将自动释放该进程持有的信号量。 semctl函数用来直接控制信号量信息。 参数sem_id为semget返回的信号量标识符。 参数sem_num同上所述。 参数command表示将要采取的动作。它可以设置许多值，常用的有两个：SETVAL表示将信号量初始化为一个已知的值，该值通过union semun结构中的val成员设置；IPC_RMID表示删除一个已经无需继续使用的信号量标识符。 若还有第四个参数，它是union semun结构，至少包含成员：union semum&#123;int val; struct semid_ds *buf; unsigned short *array&#125; 共享内存共享内存允许不相关的两个进程访问同一个逻辑内存。不过它未提供同步机制，在第一个进程结束对共享内存的写操作前，并无自动的机制可以阻止第二个进程对其进行读写。 123456#innclude sys/shm.h&gt;int shmget(key_t key, size_t size, int shmflg);void *shmat(int shm_id, const void *shm_addr, int shmflg);int shmctl(int shm_id, int cmd, struct shmid_ds *buf);int shmdt(const void *shm_addr); shmget函数用来创建共享内存，其返回值为一个共享内存标识符，标识符用于后续共享内存的其他函数。参数key为共享内存段命名；参数size为以字节为单位指定需要共享的内存容量；参数shmflg包含9个比特权限标志。 shmat函数，返回值为指向共享内存的地址指针。第一次创建共享内存段时，它不能被任何进程访问，要想对其访问，必须将其连接到一个进程的地址空间中，该工作由shmat函数完成。参数shm_id为shmget函数返回的标识符；参数shm_addr指定共享内存连接到当前进程中的地址位置，一般为空指针，由系统选择共享内存出现的地址；参数shmflg为一组位标志，两个可能的取值为SHM_RND（与shm_addr参数一起使用，用来控制共享内存连接的地址）和SHM_RDONLY（使连接的内存只读）。 shmdt函数用来将共享内存从当前进程中分离，使得当前进程不可再使用该共享内存。参数为shmat函数返回的地址指针。 shmctl函数对共享内存进行控制。 参数shm_id为shmget返回的标识符； 参数command为采取的动作，取值分别为IPC_STAT、IPC_SET和IPC_RMID。 参数buf为shmid_ds结构的指针，该结构包含成员：struct shmid_ds&#123;uid_t shm_perm.uid; uid_t shm_perm.gid; mode_t shm_perm.mode;&#125; 消息队列消息队列和命名管道FIFO有相似之处，但少了在打开和关闭管道方面的复杂性。 123456#include &lt;sys/msg.h&gt;int msgget(key_t key, int msgflg);int msgsnd(int msqid, const void *msg_ptr, size_t msg_sz, int msgflg);int msgctl(int msqid, int cmd, struct msqid_ds *buf);int msgrcv(int msqid, void *msg_ptr, size_t msg_sz, long int msgtype, int msgflg); msgget函数用来创建一个消息队列。参数key为消息队列键；参数msgflg为9个权限标志。 msgsnd函数用来把消息加到消息队列中。消息的结构需要注意“长度必须小于系统规定的上限”和“必须以长整型成员变量开始”这两个限制，消息的结构定义为：struct my_message &#123;long int message_type; /*data*/&#125;。参数msqid为msgget函数返回的标识符；参数msg_ptr为指向待发送消息的指针，注意消息的结构以长整型开始；参数msg_sz为指向消息的长度，长度不能包含长整型消息类成员变量长度；参数msgflg控制在当前消息队列满或队列消息到达系统范围的限制时将要发生的事情。 msgrcv函数用来从一个消息队列中获取消息。参数msqid、msg_ptr和msg_sz如上所述；参数msgtype可以实现一种简单形式的接收优先级，若值为0则获取队列中第一个可用消息，若值大于0则获取具有相同类型的第一个消息，若值小于0则获取消息类型等于或小于msgtype绝对值的第一个消息；参数msgflg用于控制当队列中没有相应类型的消息可接收时将发生的动作。 msgctl函数。 socket套接字前面几种进程通信方式，只有在同一台机器上的进程才能使用。socket套接字是管道概念的一个扩展，可以使同一台机器上的不同进程进行通信，也可以使不同机器上的进程之间进行通信，所以套接字还包括了计算机网络中的通信。 套接字创建与运行1、套接字属性 套接字三个属性：域(domiain)、类型(type)和协议(protocol)。套接字还用地址作为名字，地址格式随域（协议族protocol family）不同而不同，每个协议族又可以用一个或多个地址族定义地址格式。 域。域指定套接字通信中使用的网络介质，常见的域为AF_INET（AF_INET6表示Ipv6），用于网络套接字，它指Internet网络，其底层协议——网际协议IP使用IP地址来指定网络中的计算机。IP地址表示因特网中的服务器计算机，IP端口表示机器上某个特定的服务，外部程序通过IP地址和端口号的组合进行服务访问（标准服务有标准端口号，可以不用协商好端口号）。域为AF_UNIX用于本地套接字，其底层协议是文件输入&#x2F;输出，地址为文件名。 套接字类型。域可能有多种通信方式，每种方式也有其不同特性。域为AF_INET时，其底层因特网协议则提供了以下两种通信机制：**流(stream)和数据报(datagram)**。流套接字由类型SOCK_STREAM指定，其在AF_INET域中通过TCP&#x2F;IP连接实现，详情参考TCP协议；数据报套接字由类型SOCK_DGRAM指定，其在AF_INET域中通过UDP&#x2F;IP连接实现，对发送的数据报有长度限制，详情参考UDP协议。 套接字协议。若底层传输机制允许不止一个协议来提供套接字类型，就可以为套接字选择一个特定的协议。一般对于网络套接字和文件系统套接字，默认即可。 2、创建套接字 1234#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol); socket函数调用返回一个描述符，描述符用于read和write调用进行数据发送和接收，而close用于关闭套接字连接；其参数如前面所述，通信所用协议一般由domain和type决定，protocol设置为0表示使用默认协议。 3、套接字地址 每个域有自己的地址格式。对于AF_UNIX域，地址由结构sockaddr_un描述，其定义在头文件“sys&#x2F;un.”h中： 12345##include &lt;sys/un.h&gt;struct sockaddr_un&#123; sa_family_t sun_family;\t//域 char sun_path[]; //路径名&#125;; 对于AF_INET域，地址由结构sockaddr_in指定，其定义在头文件“netinet.h”中： 1234567891011#include &lt;netinet/in.h&gt;struct sockaddr_in&#123; short int sin_family; //域 unsigned short int sin_port;//端口号 struct in_addr sin_addr;\t//IP地址&#125;;//其中in_addr结构如下struct in_addr&#123; unsigned long int s_addr;\t//4字节组成32位的值&#125;; 4、命名套接字 若让其他进程能够调用创建好的套接字，服务器程序需要给该套接字命名，这样AF_UNIX套接字会关联到一个文件系统的路径名，AF_INET套接字会关联到一个IP端口号。 123#include &lt;sys/socket.h&gt;int bind(int socket, const strcut sockaddr *address, size_t address_len); 参数socket为具体创建套接字的描述符；参数address使用通用地址类型(struct sockaddr *)，将上面介绍的两种具体地址类型进行转换，使地址与未命名的套接字进行绑定；参数address_len为地址结构的长度。 5、创建套接字队列 服务器程序须创建一个队列来保持未处理的连接请求，这使用listen系统调用完成。 123#include &lt;sys/socket.h&gt;int listen(int scoket, int backlog); 参数backlog设置队列的长度，对未处理连接的数目进行限制，常用值为5。 6、接受连接 服务器程序创建并命名了套接字后，可以通过accept系统调用等待客户建立对该套接字的连接。 123#include &lt;sys/socket.h&gt;int accept(int socket, struct sockaddr *address, size_t *address_len); 套接字必须先用bind命名，并用listen调用分配队列。连接的客户地址存放于address指向的结构中，若不关心客户地址，则address为空指针。 accept函数将创建一个新套接字来与客户进行通信，并返回新套接字的描述符，新套接字的类型和服务器监听套接字类型相同。若队列中没有未处理的连接，accept将阻塞（程序暂停）直到有客户建立连接为止。 7、请求连接 客户端通过connect调用，来将一个未命名的套接字和服务器的监听套接字进行连接，从而建立通信。 123#include &lt;sys/socket.h&gt;int connect(int socket, const struct sockaddr *address, size_t address_len); 8、关闭套接字 通过close函数来终止服务器和客户端上的套接字连接。 9、字节序问题 通过套接字接口传递的端口号和地址都是二进制数字，不同计算机使用不同的字节序来表示整数。例如，Intel处理器将32为整数分为4个连续的字节，并按照小端字节序（高字节高内存，低字节低内存），而IBM则相反使用大端字节序，若两个处理数据不同的计算机以逐个字节的方式来复制，那么得到的最终数值就会不一致。 为了使其通过网络传输的多字节整数的值一致，需要定义一个网络字节序，服务器和客户端都必须在传输之前将主机内部整数表示方式转换为网络字节序，这个通过以下函数完成。 123456#include &lt;netinet/in.h&gt;unsigned long int htonl(unsigned long int hostlong);unsigned short int htons(unsigned short int hostshort);unsigned long int ntohl(unsigned long int netlong);unsigned short int ntohs(unsigned short int netshort); 以上函数将16位和32位整数进行字节序转换，函数名是相应操作的简写，例如htonl表示“host to network,long”，若主机字节序和网络字节序相同，则为空操作。 网络信息主机IP地址可以调用主机数据库函数来获取，若没有查询的主机或地址相关的数据项，则返回空指针。 12345678910111213#include &lt;netdb.h&gt;struct hostent *gethostbyaddr(const void *addr, size_t len, int type);struct hostent *gethostbyname(const char *name);//其中函数返回的指针指向的结构体包括如下成员struct hostent&#123; char *h_name; //主机名字 char **h_aliase;\t//别名列表 int h_addrtype; //地址类型 int h_length; //地址长度的字节数 char **h_addr_list;\t//地址列表（网络顺序）&#125;; 与服务及其关联端口号相关信息，可以通过服务信息函数获取。其中proto参数指定连接的协议，取值为tcp或udp。 1234567891011#include &lt;netdb.h&gt;struct servent *getservbyname(const char *name, const char *proto);struct servent *getservbyport(int port, const char *proto);//结构servent至少包含以下成员struct servent&#123; char *s_name; //服务名称 char **s_aliases;\t//别名列表 int s_port; //IP端口号 char *s_proto; //服务的协议类型tcp或udp&#125;; 主机计算机数据库信息，可以调用gethostbyname函数，结果可以使用inet_ntoa将返回的地址从网络字节序转换为可以打印的字符串，字符串格式为“点分四元组”格式；而gethostname函数则是获取当前主机的名字，主机名字将被写入name指针指向的字符串中，若主机名太长，namelength会截断主机名。 12345#include &lt;arpa/inet.h&gt;char *inet_ntoa(struct in_addr in);#include &lt;unistd.h&gt;int gethostname(char *name, int namelength); 因特网守护进程UNIX系统通常以超级服务器的方式来提供多项网络服务。超级服务器程序(因特网守护进程xinetd或inetd)同时监听许多端口地址上的连接。当有客户连接到某项服务时，守护程序就运行相应的服务器。这使得针对各项网络服务的服务器不需要一直运行着，它们可以在需要时启动。 因特网守护进程在现代Linux系统中是通过xinetd来实现的。xinetd实现方式取代了原来的UNIX程序inetd，尽管你仍然会在一些较老的Linux系统中以及其他的类UNIX系统中看到inetd的应用。 我们通常是通过一个图形用户界面来配置xinetd以管理网络服务，但我们也可以直接修改它的配置文件。它的配置文件通常是&#x2F;etc&#x2F;xinetd.conf和&#x2F;etc&#x2F;xinetd.d目录中的文件。每一个由xinetd提供的服务都在&#x2F;etc&#x2F;xinetd.d目录中有一个对应的配置文件。xinetd将在其启动时或被要求的情况下读取所有这些配置文件。 套接字选项可以使用许多选项来控制套接字连接的行为，使用setsockopt函数控制这些选项。 123#include &lt;sys/socket.h&gt;int setsockopt(int socket, int level, int option_name, const void *option_value, size_t option_len); 其中参数level表示可以在协议层次的不同级别对选项进行设置。例如套接字级别设置为SOL_SOCKET，底层协议级别(如TCP、UDP)设置为该协议的编号（通过netinet&#x2F;in.h头文件或函数getprotobyname获取）。 选项名称和功能参考手册。 select调用与多客户在编写Linux程序时，经常会遇到需要检查好几个输入的状态才能确定下一步行动的情况。例如像终端仿真器的通信程序，需要有效同时读取键盘和串行口，若是在一个单用户的系统中，运行一个“忙等待”循环还可以接受，它不停扫描设备是否有数据，如果有数据到达就读取它，但就是很消耗CPU的时间。 select系统调用允许程序同时在多个底层文件描述符上等待输入的到达。这意味着终端仿真程序可以一直阻塞到有事情可做为止。类似地，服务器也可以通过同时在多个打开的套接字上等待请求到来的方法来处理多客户。 select调用用于测试文件描述符集合中，是否有一个文件描述符已处于可读或可写状态或错误状态，它将阻塞以等待某个文件描述符进入上述这些状态。select系统调用原型如下： 1234#include &lt;sys/types.h&gt;#include &lt;sys/time.h&gt;int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout); select函数返回状态变化的描述符总数，会在以下情况返回：readfds有描述符可读、writefds有描述符可写或者errorsfds有描述符遇到错误条件，若以上3种情况都不发生，则超过timeout时间后会返回。参数nfds指定需测试的文件描述符数目，数量从0到(nfds-1)；其他三个参数readfds、writefds和errorfds可以被设置为空指针，表示不执行相应的测试；参数timeout用于防止无限期阻塞，若它是一个空指针并且套接字没有任何活动，这个调用将一直阻塞下去。 select函数对数据结构fd_set进行的操作，它是由打开的文件描述符构成的集合，有一组定义好的宏可以用来控制这些集合。FD_ZERO用于将fd_set初始化为空集合；FD_SET和FD_CLR分别用于在集合中设置和清除由参数fd传递的文件描述符；FD_ISSET函数用于当select返回时，可以测试描述符集合readfds、writefds和errorfds，找出需要注意的描述符。 1234567#include &lt;sys/types.h&gt;#include &lt;sys/time.h&gt;void FD_ZERO(fd_set *fdset);void FD_CLR(int fd, fd_set *fdset);void FD_SET(int fd, fd_set *fdset);void FD_ISSET(int fd, fd_set *fdset); 超时值由timeval结构控制： 123456#include &lt;sys/time.h&gt;struct timeval&#123; time_t tv_sec;\t//秒，类型time_t被定义为一个整数 long tv_usec;\t//微秒&#125; 数据报与UDP当客户需要发送一个短小的查询请求给服务器，并且期望接收到一个短小的响应时，我们一般就使用由UDP提供的服务。如果服务器处理客户请求的时间足够短，服务器就可以通过一次处理一个客户请求的方式来提供服务，从而允许操作系统将客户进入的请求放入队列。这简化了服务器程序的编写。 因为UDP提供的是不可靠服务，所以你可能发现数据报或响应会丢失。如果数据对于你来说非常重要，就需要小心编写UDP客户程序，以检查错误并在必要时重传。实际上，UDP数据报在局域网中是非常可靠的。 为了访问由UDP提供的服务，你需要像以前一样使用套接字和close系统调用，但你需要用两个数据报专用的系统调用sendto和recvfrom来代替原来使用在套接字上的read和write调用。 123int sendto(int sockfd, void *buffer, size_t len, int flags, struct sockaddr *from, socklen_t *fromlen);int recvfrom(int sockfd, void *buffer, size_t len, int flgs, struct sockaddr *from, socklen_t *fromlen); flag参数一般设置为0。 Linux 多线程编程Linux tcp&#x2F;ip网络编程Linux系统信息获取当为Linux(或UNIX和类UNIX系统)编写程序时，必须考虑到程序将在一个多任务环境中运行。这意味着在同一时间会有多个程序运行，它们共享内存、磁盘空间和CPU周期等机器资源。甚至同一程序也会有多个实例同时运行。最重要的是，这些程序能够互不干扰，能够了解它们的环境，并且能正确运行，不产生冲突(例如，试图与其他程序同时写同一个文件)。 程序能通过系统环境获得其相关运行条件的信息： 向程序传递参数 环境变量 查看时间 临时文件 获得有关用户和主机的信息 生成和配置日志信息 了解系统各项资源的限制 程序参数当一个用C语言编写的Linux或UNIX程序运行时，它是从main函数开始的。对程序而言，main函数的声明如下所示： int main(int argc, char *argv[]) shell将命令行输入的参数分解成单词并放入argv数组，argv[0]为程序名自身，若输入参数有n个，则共有n+1个实际参数。例如：$ myprog left right &#39;and center&#39; 程序myprog将从main函数开始，main带的参数是： argv: 4 argv: &#123;&quot;myprog&quot;, &quot;left&quot;, &quot;right&quot;, &quot;and center&quot;&#125; 一般在程序中，命令行参数设置有一定的原则： 所有命令行开关都应以一个短横线 ‘-’ 开头，后面可以是数字或字母：-r -l。 若某选项需要值，该值应作为独立的参数紧跟在该选项后面：-xx value。 不带后续参数的选项可以在一个短横线后归并到一起：-lstr。 最好能为单字符开关增加一个更长的、更有意义的开关名：–help。 getopt函数为了更好遵循上面的原则，Linux提供了getopt函数，它支持需要关联和非关联值的选项。 12345#include &lt;unistd.h&gt;int getopt(int argc, char *const argv[ ], const char *optstring);extern char *optarg;extern int optind, opterr, optopt; getopt函数将传递给程序的main函数的argc和argv作为参数，同时接受一个选项指定符字符串optstring，该字符串告诉getopt哪些选项可用，以及它们是否有关联值。optstring只是一个字符列表，每个字符代表一个单字符选项。如果一个字符后面紧跟一个冒号(：)，则表明该选项有一个关联值作为下一个参数。bash中的getopts命令执行类似的功能。 例如，我们可以用下面的调用来处理上面的例子： getopt (argc, argv, &quot;if:lr&quot;); 它允许几个简单的选项：-i、-l、-r和-f，其中-f选项后要紧跟一个文件名参数。使用相同的参数，但以不同的顺序来调用命令将改变程序的行为。 getopt的返回值是argv数组中的下一个选项字符（如果有的话）。循环调用getopt就可以依次得到每个选项。getopt有如下行为。 如果选项有一个关联值，则外部变量optarg指向这个值。如果选项处理完毕，getopt返回-1，特殊参数 ‘–’ 将使getopt停止扫描选项。 如果遇到一个无法识别的选项，getopt返回一个问号(？)，并把它保存到外部变量optopt中。 如果一个选项要求有一个关联值(例如例子中的-f)，但用户并未提供这个值，getopt通常将返回一个问号(？)。如果我们将选项字符串的第一个字符设置为冒号(：)，那么getopt将在用户未提供值的情况下返回冒号(：)而不是问号(？)。 外部变量optind被设置为下一个待处理参数的索引。getopt利用它来记录自己的进度。程序很少需要对这个变量进行设置。当所有选项参数都处理完毕后，optind将指向argv数组尾部可以找到其余参数的位置。 有些版本的getopt会在第一个非选项参数处停下来，返回-1并设置optind的值。而其他一些版本，如Linux提供的版本，能够处理出现在程序参数中任意位置的选项。注意，在这种情况下，getopt实际上重写了argv数组，把所有非选项参数都集中在一起，从argv[optind]位置开始。对GNU版本的getopt而言，这一行为是由环境变量POSIXLY_CORRECT控制的，如果它被设置，getopt就会在第一个非选项参数处停下来。此外，还有些getopt版本会在遇到未知选项时打印出错信息。注意，根据POSIX规范的规定，如果opterr变量是非零值，getopt就会向stderr打印一条出错信息。 getopt_long函数许多Linux应用程序也接受比我们在前面例子中所用的单字符选项含义更明确的参数。GNU C函数库包含getopt的另一个版本，称作getopt_long，它接受以双划线(-)开始的长参数。 环境变量UNIX规范为各种应用定义了许多标准环境变量，包括终端类型、默认的编辑器、时区等。C语言程序可以通过putenv和getenv函数来访问环境变量。 putenv函数和getenv函数环境由一组格式为“名字&#x3D;值”的字符串组成。 1234#include &lt;stdlib.h&gt;char *getenv(const char *name);int putenv(const char *string); getenv函数以给定的名字搜索环境中的一个字符串，并返回与该名字相关的值。如果请求的变量不存在，它就返回null。如果变量存在但无关联值，它将运行成功并返回一个空字符串，即该字符串的第一个字节是null。由于getenv返回的字符串是存储在getenv提供的静态空间中，所以如果想进一步使用它，你就必须将它复制到另一个字符串中，以免它被后续的getenv调用所覆盖。 putenv函数以一个格式为“名字&#x3D;值”的字符串作为参数，并将该字符串加到当前环境中。如果由于可用内存不足而不能扩展环境，它会失败并返回-1。此时，错误变量errno将被设置为ENOMEM。 在下面的实验中，你将编写一个程序来打印所选的任意环境变量的值。如果给程序传递第二个参数，你还将设置环境变量的值。 注意：环境仅对程序本身有效。你在程序里做的改变不会反映到外部环境中，这是因为变量的值不会从子进程（你的程序）传播到父进程(shell)。 environ变量程序可以通过environ变量（一个以null结尾的字符串数组）直接访问这个字符串数组，其声明如下： 123#include &lt;stdlib.h&gt;extern char **environ 例子，遍历并输出系统的环境变量： 1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;extern char **environ;int main()&#123; char **env = environ; while(*env) &#123; printf(&quot;%s &quot;,*env); env++; &#125; exit(0);&#125; 时间和日期time函数时间通过一个预定义的类型time_t来处理。这是一个大到能够容纳以秒计算的日期和时间的整数类型。在Linux系统中，它是一个长整型，与处理时间值的函数一起定义在头文件time.h中。 123#include &lt;time.h&gt;time_t time(time_t *tloc); 可以通过调用time函数得到底层的时间值，它返回的是从纪元开始至今的秒数。如果tloc不是一个空指针，time函数还会把返回值写入tloc指针指向的位置。 difftime函数以从1970年开始计算的秒数来表示时间和日期，对测算某些事情持续的时间是很有用的。可以把它考虑为简单地把两次调用time得到的值相减。然而ISO&#x2F;ANSI C标准委员会经过审议，并没有规定用time_t类型来测量任意时间之间的秒数，他们发明了一个函数difftime，该函数用来计算两个time_t值之间的秒数并以double类型返回它。 123#include &lt;time.h&gt;double difftime(time_t timel, time_t time2); gmtime函数为了提供（对人类）更有意义的时间和日期，需要把时间值转换为可读的时间和日期。有一些标准函数可以帮我们做到这一点。gmtime函数把底层时间值分解为一个结构，该结构包含一些常用的成员： 123#include &lt;time.h&gt;struct tm *gmtime(const time_t timeval); tm结构被定义为至少包含表中所示的成员。 不过，这儿有个小问题。如果在格林尼治标准时间(GMT)之外的时区运行这个程序，或者所在的地方像本例中那样采用了夏令时，你会发现时间（可能还有日期）是不对的。这是因为gmtime按GMT返回时间(现在GMT被称为世界标准时间，或UTC)Linux和UNIX这样做是为了同步全球各地的所有程序和系统。不同时区同一时刻创建的文件都会有相同的创建时间。要看当地时间，你需要使用localtime函数。 localtime函数使用localtime函数能输出当地时区的时间信息。 12#include &lt;time.h&gt;struct tm *localtime(const time_t *timeval); mktime函数使用mktime函数可以将localtime输出值转化为原始的时间。 12#include &lt;time.h&gt;time_t mktime(struct tm *timeptr); astime和ctime函数为了更“友好”地显示时间和日期，可以使用这两个函数。 1234#include &lt;time.h&gt;char *astime(const struct tm *timeptr);char *ctime(const time_t *timeval); asctime函数返回一个字符串，它表示由tm结构timeptr所给出的时间和日期。这个返回的字符串有类似下面的格式，它总是这种长度为26个字符的固定格式： Sun Jun 9 12:34:56 2007 \\0 ctime函数等效于调用下面这个函数，它以原始时间值为参数，并将它转换为一个更易读的本地时间： asctime(localtime(timeval)) strftime函数和strptime函数为了对时间和日期字符串的格式有更多控制，Linux和现代的类UNIX系统提供了strftime函数。它很像是一个针对时间和日期的sprintf函数，工作方式也很类似： 123#include &lt;time.h&gt;size_t strftime(char *s, size_t maxsize, const char *format, struct tm *timeptr); strftime函数格式化timeptr指针指向的tm结构所表示的时间和日期，并将结果放在字符串s中。字符串被指定（至少）maxsize个字符长。format字符串用于控制写入字符串s的字符。与printf一样，它包含将被传给字符串的普通字符和用于格式化时间和日期元素的转换控制符。转换控制符见表。 为了读取日期，你可以使用strptime函数，该函数以一个代表日期和时间的字符串为参数，并创建表示同一日期和时间的tm结构： 123#include &lt;time.h&gt;char *strptime(const char *buf, const char *format, struct tm *timeptr); format字符串的构建方式和strftime的format字符串完全一样。strptime在字符串扫描方面类似于sscanf函数，也是查找可识别字段，并把它们写入对应的变量中。只是这里是根据format字符串来填充tm结构的成员。不过，strptimel的转换控制符与strftime的相比，限制要稍微松一些，因为strptime中的星期几和月份用缩写和全称都行，两者都匹配strptime中的a控制符，此外，strftime对小于10的数字总以0开头，而strptimel则把它看作是可选的。 strptime返回一个指针，指向转换过程处理的最后一个字符后面的那个字符。如果碰到不能转换的字符，转换过程就在该处停下来。调用程序需要检查是否己从传递的字符串中读入了足够多的数据，以确保tm结构中写入了有意义的值。 临时文件很多情况下，程序会利用一些文件形式的临时存储手段。这些临时文件可能保存着一个计算的中间结果，也可能是关键操作前的文件备份。例如，一个数据库应用程序在删除记录时就可能使用临时文件。该文件收集需要保留的数据库条目，然后在处理结束后，这个临时文件就变成新的数据库，原来文件则被删除。 临时文件的这种用法很常见，但也有一个隐藏的缺点。必须确保应用程序为临时文件选取的文件名是唯一的。否则，因为Linux是一个多任务系统，另一个程序就可能选择同样的文件名，从而导致两个程序互相干扰。 tmpna函数用tmpnam函数可以生成一个唯一的文件名： 123#include &lt;stdio.h&gt;char *tmpnam(char *s); tmpnam函数返回一个不与任何己存在文件同名的有效文件名。如果字符串s不为空，文件名也会写入它。对tmpnaml的后续调用会覆盖存放返回值的静态存储区，所以如果tmpnam要被多次调用，就有必要给它传递一个字符串参数了。这个字符串的长度至少要有L_tmpnam(通常为20)个字符。tmpnam可以被一个程序最多调用TMP_MAX次（至少为几千次），每次它都会返回一个不同的文件名。 tmpfile函数如果遇到需要立刻使用临时文件的情况，你可以用tmpfile函数在给它命名的同时打开它。这点非常重要，因为另一个程序可能会创建出一个与tmpnam返回的文件名同名的文件。tmpfile函数则完全避免了这个问题的发生： 123#include &lt;stdio.h&gt;FILE *tmpfile(void); tmpfile函数返回一个文件流指针，它指向一个唯一的临时文件。该文件以读写方式打开（通过w+方式的fopen)，当对它的所有引用全部关闭时，该文件会被自动删除。 如果出错，tmpfile返回空指针并设置errno的值。 mktemp函数和mkstemp函数UNIX有另一种生成临时文件名的方式，就是使用mktemp和mkstemp函数。Linux也支持这两个函数，它们与tmpnam类似，不同之处在于可以为临时文件名指定一个模板，模板可以让你对文件的存放位置和名字有更多的控制： 1234#include &lt;stdlib.h&gt;char *mktemp(char *template);int mkstemp(char *template); mktemp函数以给定的模板为基础创建一个唯一的文件名。template参数必须是一个以6个x字符结尾的字符串。mktemp即函数用有效文件名字符的一个唯一组合来替换这些x字符。它返回一个指向生成的字符串的指针，如果不能生成一个唯一的名字，它就返回一个空指针。 mkstemp函数类似于tmpfile，它也是同时创建并打开一个临时文件。文件名的生成方法和mktemp一样，但是它的返回值是一个打开的、底层的文件描述符。 应该在程序中使用“创建并打开”函数tmpfile和mkstemp，而不要使用tmpnam和mktemp。 用户信息除了init程序以外，所有的linux程序都是由其他程序或用户启动的。Linux运行的每个程序都是以某个用户的名义在运行，每个用户登录进入Linux系统时会有一个用户标识符UID，所以运行的程序会有一个关联的UID。 UID有自己的类型uid_t，定义在sys&#x2F;types.h中，是一个小整数。有些UID是系统预定义的，其他则是系统管理员在添加新用户时创建的。一般情况下，用户的UID值都大于100。 getuid和getlogin函数12345#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;uid_t getuid(void);char *getlogin(void); getuid函数返回程序关联的UID，它通常是启动程序的用户的UID。getlogin函数返回与当前用户关联的登录名。 系统文件&#x2F;etc&#x2F;passwd包含一个用户账号数据库。它由行组成，每行对应一个用户，包括用户名、加密口令、用户标识符(UID)、组标识符(GID)、全名、家目录和默认shell。下面是一个示例行： neil:zBqxfgedfpk:500:100:Neil atthew:/home/neil:/bin/bash 如果编写一个程序，它能确定启动它的用户的UID，那么你就可以对它进行扩展，让它查找密码文件以找到用户的登录名和全名。 但我们并不推荐这种做法，因为为了提高系统的安全性，现代的类UNIX系统都不再使用简单的密码文件了。许多系统，包括Linux，都有一个使用shadow密码文件的选项，原来的密码文件中不再包含任何有用的加密口令信息（这些信息通常存放在&#x2F;etc&#x2F;shadow文件中，这是一个普通用户不能读取的文件）。为此，人们定义了一组函数来提供一个标准而有效的获取用户信息的编程接口。 getpwuid和getpwnam函数12345#include &lt;sys/types.h&gt;#include &lt;pwd.h&gt;struct password *getpwuid(uid_t uid);struct password *getpwnam(const char *name); 密码数据库结构password定义在头文件pwd.h中，包含以下成员： 有些UNIX系统可能对用户全名字段使用一个不同的名字。例如某些系统上是pw_gecos，其他系统是pw_comment。 getpwuid和getpwnam函数都返回一个指针，该指针指向某个用户对应的password结构。这个用户通过getpwuid的UID参数或通过getpwnam的用户登录名来确定。出错时，它们返回一个空指针并设置errno。 getpwent函数如果要扫描密码文件中的所有信息，可以使用getpwent函数。它的作用是依次取出文件数据项： 123456#include &lt;pwd.h&gt;#include &lt;sys/types.h&gt;void endpwent(void);struct password *getpwent(void);void setpwent(void); getpwent函数依次返回每个用户的信息数据项。当到达文件尾时，它返回一个空指针。 如果已经扫描了足够多的数据项，可以使用endpwent函数来终止处理过程。 setpwent函数重置读指针到密码文件的开始位置，这样下一个getpwent函数重新开始一个新的扫描。 其他函数用户和组标识符还可以被其他一些不太常用的函数获得： 123456789#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;uid_t geteuid(void);gid_t getgid(void);gid_t getegid(void);#只有超级用户才能调用setuid和setgid函数int setuid(uid_t uid);int setgid(gid_t gid); 主机信息正如程序可以查找用户信息一样，程序也可以获得运行它的计算机的有关细节。 gethostname函数123#include &lt;unistd.h&gt;int gethostname(char *name, size_t namelen); gethostname函数把机器的网络名写入name字符串。该字符串至少有namelen个字符长。成功时，gethostname返回0，否则返回-1。 uname函数123#include &lt;sys/utsname.h&gt;int uname(struct utsname *name); uname函数主机信息写入name参数指向的结构。utsname结构定义在头文件sys&#x2F;utsname.h中，至少包括以下成员： uname成功时返回一个非负整数，否则返回-1并设置errno来指出错误。 日志许多应用程序需要记录它们的活动。系统程序经常需要向控制台或日志文件写消息。这些消息可能指示错误、警告或是与系统状态有关的一般信息。 syslog函数虽然系统消息的格式和存储方式不尽相同，但产生消息的方法却是标准的。UNIX规范通过syslog函数为所有程序产生日志信息提供了一个接口： 12#include &lt;syslog.h&gt;void syslog(int priority, const char *message, arguments...); syslog函数向系统的日志设施（facility）发送一个日志信息。每条信息都有一个priority参数，该参数是一个严重级别与一个设施值的按位或。其中，严重级别控制日志信息的处理方式，设施值记录日志信息的来源。 定义在头文件syslog.h中的设施值包括LOG_USER（默认值）——它指出消息来自一个用户应用程序，以及LOG_LOCAL0、LOG_LOCAL1直到LOG_LOCAL7，它们含义由本地管理员指定。 严重级别按优先级递减排列： 根据系统配置，LOG_EMERG信息可能会广播给所有用户，LOG_ALERT信息可能会EMAIL给管理员，LOG_DEBUG信息可能会被忽略，而其他信息则写入日志文件。 syslog创建的日志信息包含消息头和消息体。消息头根据设施值及日期和时间创建。消息体根据syslog的message参数创建，该参数的作用类似printf中的格式字符串。syslog的其他参数根据message字符串中printf风格的转换控制符而定。 此外，转换控制符%m可用于插入与错误变量errno当前值对应的出错消息字符串，对于记录错误消息很有用。 例：syslog(LOG_ERR | LOG_USER, &quot;oops-%m &quot;); 其他函数在头文件syslog.h中还定义了一些能够改变日志记录行为的其他函数。 12345#include &lt;syslog.h&gt;void closelog(void);void openlog(const char *ident, int logopt, int facility);int setlogmask(int maskpri); 你可以通过调用openlog函数来改变日志信息的表示方式。它可以设置一个字符串ident，该字符串会添加在日志信息的前面。你可以通过它来指明是哪个程序创建了这条信息。facility参数记录一个将被用于后续syslog调用的默认设施值，其默认值是LOG_USER。logopt参数对后续syslog调用的行为进行配置，它是0个或多个表中参数的按位或。 openlog函数会分配并打开一个文件描述符，并通过它来写日志。你可以调用closelog函数来关闭它。注意，在调用syslog.之前无需调用openlog,因为syslog会根据需要自行打开日志设施。 你可以使用setlogmask函数来设置一个日志掩码，并通过它来控制日志信息的优先级。优先级未在日志掩码中置位的后续syslog调用都将被丢弃。所以你可以通过这个方法关闭LOG_DEBUG消息而不用改变程序主体。 你可以用LOG_MASK(priority)为日志信息创建一个掩码，它的作用是创建一个只包含一个优先级的掩码。你还可以用LOG_UPTO(priority)来创建一个由指定优先级之上的所有优先级（包括指定优先级）构成的掩码。 资源和限制Linux系统上运行的程序会受到资源限制的影响。它们可能是硬件方面的物理性限制（例如内存）、系统策略的限制(例如，允许使用的CPU时间)或具体实现的限制（如整数的长度或文件名中所允许的最大字符数）。UNIX规范定义了一些可由应用程序决定的限制。 头文件limits.h中定义了许多代表操作系统方面限制的显式常量，如表所示。 注意：NAME_MAX是特定于文件系统的。为了写可移植性更好的代码，你应该使用pathconf函数。详细信息请参考pathconf的手册页。 头文件sys&#x2F;resource.h提供了资源操作方面的定义，其中包括对程序长度、执行优先级和文件资源等方面限制进行查询和设置的函数： 1234567#include &lt;sys/resource.h&gt;int getpriority(int which, id_t who);int setpriority(int which, id_t who, int priority);int getrlimit(int resource, struct rlimit *r_limit);int setrlimit (int resource, const struct rlimit *r_limit);int getrusage(int who, struct rusage *r_usage); id_t是一个整数类型，它用于用户和组标识符。在头文件sys&#x2F;resource.h中定义的rusage结构用来确定当前程序已耗费了多少CPU时间，它至少包含如下两个成员。 struct timeval ru_utime: 使用的用户时间 struct timeval ru_stime: 使用的系统时间 ***暂略！ Linux数据管理数据管理的3个方面。 动态内存管理：可以做什么以及Liux不允许做什么。 文件锁定：协调锁、共享文件的锁定区域和避免死锁。 dbm数据库：一个大多数Linux系统都提供的、基本的、不基于SQL的数据库函数库。 内存管理Linux为应用程序提供了一个简洁的视图，它能反映一个巨大的可直接寻址的内存空间。 此外，Linux还提供了内存保护机制，它避免了不同的应用程序之间的互相干扰。 如果机器被正确配置并且有足够的交换空间，Linux还允许应用程序访问比实际物理内存更大的内存空间。 内存分配使用标准C语言函数库中的malloc调用来分配内存： 1234567#include &lt;stdlib.h&gt;void *malloc(size_t size);//为一个结构数组分配内存，返回结果为第一个元素的指针void *calloc(size_t number_of_elements, size_t element_size);//改变之前分配的内存块的大小，使用该函数后应使用返回的新的内存指针void *realloc(void *existing_memory, size_t new_size); 刚开始时，内核只是通过使用空闲的物理内存来满足应用程序的内存请求，但是当物理内存耗尽时，它便会开始使用所谓的交换空间(swap space)。在Linux系统中，交换空间是一个在安装系统时分配的独立的磁盘区域。如果熟悉Windows操作系统的话，Linux交换空间的作用有点像隐藏的Windows交换文件。但与Windows不同，Linux的交换空间中没有局部堆、全局堆或可丢弃内存段等需要在代码中操心的内容——Linux内核会为你完成所有的管理工作。 内核会在物理内存和交换空间之间移动数据和程序代码，使得每次读写内存时，数据看起来总像是已存在于物理内存中，而不管在你访问它们之前，它们究竟是在哪里。用更专业的术语来说，Linux实现了一个“按需换页的虚拟内存系统”。用户程序看到的所有内存全是虚拟的，也就是说，它并不真正存在于程序使用的物理地址上。Linux将所有的内存都以页为单位进行划分，通常每一页的大小为4096字节。每当程序试图访问内存时，就会发生虚拟内存到物理内存的转换，转换的具体实现和耗费的时间取决于你所使用的特定硬件情况。当所访问的内存在物理上并不存在时，就会产生一个页面错误并将控制权交给内核。 Linux内核会对访问的内存地址进行检查，如果这个地址对于程序来说是合法可用的，内核就会确定需要向程序提供哪一个物理内存页面。然后，如果该页面之前从未被写入过，内核就直接分配它，如果它己经被保存在硬盘的交换空间上，内核就读取包含数据的内存页面到物理内存（可能需要把一个已有页面从内存中移出到硬盘）。接着，在完成虚拟内存地址到物理地址的映射之后，内核允许用户程序继续运行。Linux应用程序并不需要操心这一过程，因为所有的具体实现都已隐藏在内核中了。最终，当应用程序耗尽所有的物理内存和交换空间，或者当最大栈长度被超过时，内核将拒绝此后的内存请求，并可能提前终止程序的运行。 内存释放动态使用内存的程序应该总是通过free调用，来把不用的内存释放给malloc内存管理器。这样做可以将分散的内存块重新合并到一起，并由malloc函数库而不是应用程序来管理它。如果一个运行中的程序（进程）自己使用并释放内存，则这些自由内存实际上仍然处于被分配给该进程的状态。 在幕后，Linux将程序员使用的内存块作为一个物理页面集来管理，通常内存中的每个页面为4K字节。但如果一个内存页面未被使用，Linux内存管理器就可以将其从物理内存置换到交换空间中（术语叫换页），从而减轻它对资源使用的影响。如果程序试图访问位于已置换到交换空间中的内存页中的数据，那么Linux会短暂地暂停程序，将内存页从交换空间再次置换到物理内存，然后允许程序继续运行，就像数据一直存在于内存中一样。 123#include &lt;stdlib.h&gt;void free(void *ptr_to memory); 调用free时使用的指针参数必须是指向由malloc、calloc或realloc调用所分配的内存 请记住：一旦调用free释放了一块内存，它就不再属于这个进程。它将由malloc函数库负责管理。在对一块内存调用free之后，就绝不能再对其进行读写操作了。 文件锁定文件锁定是多用户、多任务操作系统中一一个非常重要的组成部分。程序经常需要共享数据，而这通常是通过文件来实现的。因此，对于这些程序来说，建立某种控制文件的方式就非常重要了。只有这样，文件才可以通过一种安全的方式更新，或者说，当一个程序正在对文件进行写操作时，文件就会进入一个暂时状态，在这个状态下，如果另外一个程序尝试读这个文件，它就会自动停下来等待这个状态的结束。 第一种方法——创建锁文件。Linux提供了多种特性来实现文件锁定。其中最简单的方法就是以原子操作的方式创建锁文件，所谓“原子操作”就是在创建锁文件时，系统将不允许任何其他的事情发生。这就给程序提供了一种方式来确保它所创建的文件是唯一的，而且这个文件不可能被其他程序在同一时刻创建。 第二种方法——区域锁定。这种方法更高级一些，它允许程序锁定文件的一部分，从而可以独享对这一部分内容的访问。有两种不同的方式可以实现第二种形式的文件锁定。将只对其中的一种做详细介绍，因为两种方式非常相似——第二种方式只不过是程序接口稍微不同而己。 方法一：创建锁文件许多应用程序只需要能够针对某个资源创建一个锁文件即可。然后，其他程序就可以通过检查这个文件来判断它们自己是否被允许访问这个资源。 注意，锁文件仅仅只是充当一个指示器的角色，程序间需要通过相互协作来使用它们。用术语来说，锁文件只是建议锁，而不是强制锁，在后者中，系统将强制锁的行为。 为了创建一个用作锁指示器的文件，你可以使用在fcntl.h头文件中定义的open系统调用，并带上O_CREAT和O_EXCL标志。这样能够以一个原子操作同时完成两项工作：确定文件不存在，然后创建它。 方法二：区域锁定用创建锁文件的方法来控制对诸如串行口或不经常访问的文件之类的资源的独占式访问，是一个不错的选择，但它并不适用于访问大型的共享文件。假设你有一个大文件，它由一个程序写入数据，但却由许多不同的程序同时对这个文件进行更新。当一个程序负责记录长期以来连续收集到的数据，而其他一些程序负责对记录的数据进行处理时，这种情况就可能发生。处理程序不能等待记录程序结束，因为记录程序将一直不停地运行，所以它们需要一些协调方法来提供对同一个文件的并发访问。 你可以通过锁定文件区域的方法来解决这个问题，文件中的某个特定部分被锁定了，但其他程序可以访问这个文件中的其他部分。这被称为文件段锁定或文件区域锁定。Linux提供了至少两种方式来实现这一功能：使用fcntl系统调用和使用lockf调用。 我们将主要介绍fcntl接口，因为它是最常使用的接口。lockf和fcntl非常相似，在Linux中，它一般作为fcntl的备选接口。但是，fcntl和lockf的锁定机制不能同时工作：它们使用不同的底层实现，因此决不要混合使用这两种类型的调用，而应坚持使用其中的一种。 12#include &lt;fcntl.h&gt;int fcntl(int fildes, int command, ···); fcntl对一个打开的文件描述符进行操作，并能根据command参数的设置完成不同的任务。它为我们提供了3个用于文件锁定的命令选项：F_GETLK、F_SETLK和F_SETLKW。 当使用这些命令选项时，fcntl的第三个参数必须是一个指向flock结构的指针，所以实际的函数原型应为：int fcntl(int fildes, int command, struct flock *flock_structure); flock_structure（文件锁）结构依赖具体的实现，但它至少包含下述成员： short l_type short l_whence off_t l_start off_t l_1en pid_t l_pid l_type成员的取值定义在头文件fcntl.h中，如表所示。 l_whence、l_start和l_len成员定义了文件中的一个区域，即一个连续的字节集合。l_whence的取值必须是SEEK_SET、SEEK_CUR、SEEK END(在头文件unistd.h中定义)中的一个。它们分别对应于文件头、当前位置和文件尾。l_whence定义了l_start的相对偏移值，其中，l_start是该区域的第一个字节。l_whence通常被设为SEEK_SET，这时l_start就从文件的开始计算。l_len参数定义了该区域的字节数。 l_pid参数用来记录持有锁的进程。 文件中的每个字节在任一时刻只能拥有一种类型的锁：共享锁、独占锁或解锁。fcntl调用可用的命令和选项的组合相当多： 1、F_GETLK命令 第一个命令是F_GETLK。它用于获取fildes（第一个参数）打开的文件的锁信息。它不会尝试去锁定文件。调用进程把自己想创建的锁类型信息传递给fcntl，使用F_GETLK命令的fcntl就会返回将会阻止获取锁的任何信息。 flock结构中使用的值如表所示。 2、F_SETLK命令 这个命令试图对fildes指向的文件的某个区域加锁或解锁。flock结构中使用的值（与F_GETLK命令中用到的不同之处）如表所示。 与F_GETLK一样，要加锁的区域由flock结构中的l_start、l_whence和l_len的值定义。如果加锁成功，fcntl将返回一个非-1的值：如果失败，则返回-1。这个函数总是立刻返回。 3、F_SETLKW命令 F_SETLKW命令与上面介绍的FSETLK命令作用相同，但在无法获取锁时，这个调用将等待直到可以为止。一旦这个调用开始等待，只有在可以获取锁或收到一个信号时它才会返回。 程序对某个文件拥有的所有锁都将在相应的文件描述符被关闭时自动清除。在程序结束时也会自动清除各种锁。 其他锁方法还有另外一种锁定文件的方法：lockf函数。它也通过文件描述符进行操作。其原型为： 123#include &lt;unistd.h&gt;int lockf(int fildes, int function, off_t size_to_lock); function参数的取值如下所示。 F_ULOCK:解锁。 F_LOCK:设置独占锁。 F_TLOCK:测试并设置独占锁。 F_TEST:测试其他进程设置的锁。 size_to_lock参数是操作的字节数，它从文件的当前偏移值开始计算。 lockf有一个比fcntl函数更简单的接口，这主要是因为它在功能性和灵活性上都要比fcntl函数差一些。为了使用这个函数，必须首先搜寻你想锁定的区域的起始位置，然后以要锁定的字节数为参数来调用它。 与文件锁定的fcntl方法一样，lockf设置的所有锁都是建议锁，它们并不会真正地阻止你读写文件中的数据。对锁的检测是程序的责任。混合使用fcntl锁和lockf锁的效果未被定义，因此你必须决定使用哪种类型的锁定方法并坚持用下去。 锁定状态下的读写操作当对文件区域加锁之后，你必须使用底层的read和write调用来访问文件中的数据，而不要使用更高级的fread和fwrite调用，这是因为fread和fwrite会对读写的数据进行缓存。 文件锁的竞争死锁在讨论锁定时如果未提到死锁的危险，那么这个讨论就不能算是完整的。假设两个程序想要更新同一个文件。它们需要同时更新文件中的字节1和字节2。程序A选择首先更新字节2，然后再更新字节1；程序B则是先更新字节1，然后才是字节2。两个程序同时启动。程序A锁定字节2，而程序B锁定字节1。然后程序A尝试锁定字节1，但因为这个字节已经被程序B锁定，所以程序A将在那里等待。接着程序B尝试锁定字节2，但因为这个字节已经被程序A锁定，所以程序B也将在那里等待。 这种两个程序都无法继续执行下去的情况，就被称为死锁(deadlock或deadly embrace)。这个问题在数据库应用程序中很常见，当许多用户频繁访问同一个数据时就很容易发生死锁。大多数的商业关系型数据库都能够检测到死锁并自动解开，但Liux内核不行。这时就需要采取一些外部干涉手段，例如强制终止其中一个程序来解决这个问题。 程序员必须对这种情况提高警惕。当有多个程序都在等待获得锁时，你就需要非常小心地考虑是否会发生死锁。在本例中，死锁是非常容易避免的：两个程序只需要使用相同的顺序来锁定它们需要的字节或锁定一个更大的区域即可。 开发工具make和makefile多个源文件带来的问题：对于一个含多个头文件的程序，假设只修改其中一个头文件，此时只影响局部包含该头文件的源文件，若希望仅重新编译该部分程序的文件，而不用将整个工程的文件重新编译，可以使用make工具解决该问题。 makefile文件：make命令内置了很多智能机制，但是需要根据工程编写一个makefile文件来告诉make去构造该工程应用程序的编译。 makefile语法makefile文件由一组依赖关系和规则构成。每个依赖关系由一个目标（即将要创建的文件）和一组该目标所依赖的源文件组成。而规则描述了如何通过这些依赖文件创建目标。一般来说，目标是一个单独的可执行文件。 make命令会读取makefile文件的内容，它先确定目标文件或要创建的文件，然后比较该目标所依赖的源文件的日期和时间以决定该采用哪条规则来构造目标。通常在创建最终的目标文件之前，它需要先创建一些中间目标。make命令会根据makefile文件来确定目标文件的创建顺序以及正确的规则调用顺序。 make程序本身有许多选项，其中最常用的3个选项如下所示。 -k: 它的作用是让make命令在发现错误时仍然继续执行，而不是在检测到第一个错误时就停下来。你可以利用这个选项在一次操作中发现所有未编译成功的源文件。 -n: 它的作用是让make命令输出将要执行的操作步骤，而不真正执行这些操作。 -f : 它的作用是告诉make命令将哪个文件作为makefile文件。如果未使用这个选项，标准版本的make命令将首先在当前目录下查找名为makefile的文件，如果该文件不存在，它就会查找名为Makefilel的文件。如果是在Linux系统中，使用的可能是GNU Make，这个版本的make命令将在搜索makefile文件和Makefile文件之前，首先查找名为GNUmakefilel的文件。按惯例，许多Linux程序员使用文件名Makefile，因为如果一个目录下都是以小写字母为名称的文件，则Makefi1e文件将在目录的文件列表中第一个出现。建议不要使用文件名GNUmakefile，因为它是特定于make命令的GNU实现的。 为了指示make命令创建一个特定的目标（通常是一个可执行文件），你可以把该目标的名字作为make命令的一个参数。如果不这么做，make命令将试图创建列在makefile文件中的第一个目标。许多程序员都会在自己的makefile文件中将第一个目标定义为all，然后再列出其他从属目标。这个约定可以明确地告诉make命令，在未指定特定目标时，默认情况下应该创建哪个目标，建议坚持使用这一约定。 1依赖关系 依赖关系定义了最终应用程序里的每个文件与源文件之间的关系。在makefile文件中，这些规则的写法是：先写目标的名称，然后紧跟着一个冒号，接着是空格或制表符tab，最后是用空格或制表符tab隔开的文件列表（这些文件用于创建目标文件）。 例如下面的示例，表示目标myapp依赖于main.o、2.o和3.o，而main.o依赖于main.c和a.h，等等。 1234myapp: main.o 2.o 3.omain.o: main.c a.h2.o: 2.c a.h b.h3.o: 3.c b.h c.h 这组依赖关系形成一个层次结构，它显示了源文件之间的关系。可以很容易地看出，如果文件b.h发生改变，就需重新编译2.o和3.o，而由于2.o和3.o发生了改变，还需要重新创建目标myapp。 如果想一次创建多个文件，可以利用伪目标all。假设应用程序由二进制文件myapp和使用手册myapp.1组成。可以用下面这行语句进行定义： 1all: myapp myapp.1 再次强调，如果未指定一个all目标，则make命令将只创建它在文件makefile中找到的第一个目标。 2规则 makefile文件的第二部分内容是规则，它们定义了目标的创建方式。 对于该部分，空格和制表符tab是有区别的。 规则所在的行必须以制表符tab开头，用空格是不行的； 如果makefile文件中的某行以空格结尾，它也可能会导致make命令执行失败； 如果缺少了制表符tab，make命令就不会正常工作，所以发现这个错误很容易。 12345678myapp: main.o 2.o 3.o\tgcc -o myapp main.o 2.o 3.omain.o: main.c a.h\tgcc -c main.c2.o: 2.c a.h b.h\tgcc -c 2.c3.o: 3.c b.h c.h\tgcc -c 3.c makefile注释makefile文件中的注释以#号开头，一直延续到这一行的结束。和C语言源文件中的注释一样。 makefile的宏问题 1 对于管理包含非常多源文件的大型项目来说，按照上面的makefile构建会显得过于庞大并缺乏弹性。因此，makefile文件允许使用宏，以一种更通用的格式来书写它们。 通过语句MACRONAME&#x3D;value在makefile文件中定义宏 引用宏的方法是使用$(MACRONAME)或${MACRONAME}。make的某些版本还接受$MACRONAME的用法。 如果想把一个宏的值设置为空，可以令等号(&#x3D;)后面留空。 问题 2 Makefilel文件的另一问题是，它假设编译器的名字是gcc，而在其他UNIX系统中，编译器的名字可能是cc或c89。如果想将makefile文件移植到另一版本的UNIX系统中，或在现有系统中使用另一个编译器，为了使其工作，将不得不修改makefile文件中许多行的内容。宏是用来收集所有这些与系统相关内容的好方法，通过使用宏定义，可以方便地修改这些内容。 宏通常都是在makefile文件中定义的，但也可以在调用make命令时在命令行上给出宏定义，例如命令make CC&#x3D;c89。命令行上的宏定义将覆盖在makefile文件中的宏定义。当在makefile文件之外使用宏定义时，要注意宏定义必须以单个参数的形式传递，所以应避免在宏定义中使用空格或应像下面这样给宏定义加上引号：make “cc&#x3D;c89”。 示例： 12345678910111213141516171819202122all: myapp#Which compilerCC = gcc#Where are include files keptINCLUDE =#Options for developmentCFLAGS = -g -Wall -ansi#Options for release#CFLAGS = -o -Wall -ansimyapp: main.o 2.o 3.o\t$(CC) -o myapp main.o 2.o 3.omain.o: main.c a.h\t$(CC) -I $(INCLUDE) $(CFLAGS) -c main.c2.o: 2.c a.h b.h\t$(CC) -I $(INCLUDE) $(CFLAGS) -c 2.c3.o: 3.c b.h c.h\t$(CC) -I $(INCLUDE) $(CFLAGS) -c 3.c make命令内置了一些特殊的宏定义，通过使用它们，可以让makefile文件变得更加简洁： 在makefi1e文件中，可能还会看到下面两个有用的特殊字符，它们出现在命令之前。 -：告诉make命令忽略所有错误。例如，如果想创建一个目录，但又想忽略任何错误（比如目录已存在），就可以在mkdir命令的前面加上一个减号。 @: 告诉make在执行某条命令前不要将该命令显示在标准输出上。如果想用echo命令给出一些说明信息，这个字符将非常有用。 多个目标文件通常制作不止一个目标文件或者将多组命令集中到一个位置来执行是很有用的。可以通过扩展makefile文件来达到这一目的。 下面的例子中在makefile文件中增加一个clean选项来删除不需要的目标文件，增加一个install选项来将编译成功的应用程序安装到另一个目录下： 123456789101112131415161718192021222324252627282930313233343536373839404142all: myapp#Which compilerCC = gcc######################################################################Where to installINSTDIR = /usr/local/bin######################################################################Where are include files keptINCLUDE =#Options for developmentCFLAGS = -g -Wall -ansi#Options for release#CFLAGS = -o -Wall -ansimyapp: main.o 2.o 3.o\t$(CC) -o myapp main.o 2.o 3.omain.o: main.c a.h\t$(CC) -I $(INCLUDE) $(CFLAGS) -c main.c2.o: 2.c a.h b.h\t$(CC) -I $(INCLUDE) $(CFLAGS) -c 2.c3.o: 3.c b.h c.h\t$(CC) -I $(INCLUDE) $(CFLAGS) -c 3.c\t#####################################################################clean:\t-rm main.o 2.o 3.oinstall: myapp\t@if [ -d $(INSTDIR) ];\t\\ then\t\\ cp myapp $(INSTDIR);\t\\ chmod a+x $(INSTDIR)/myapp;\t\\ chmod og-w $(INSTDIR)/myapp;\t\\ echo &quot;Installed in $(INSTDIR)&quot;;\t\\ else\t\\ echo &quot;Sorry, $(INSTDIR) does not exist&quot;;\t\\\tfi################################################################## 内置规则事实上，make命令本身带有大量的内置规则，它们可以极大地简化makefile文件的内容，尤其在拥有许多源文件时更是如此。 后缀和模式规则用make管理函数库对于大型项目，一种比较方便的做法是用函数库来管理多个编译产品。函数库实际上就是文件，它们通常以。a(a是英文archive的首字母)为后缀名，在该文件中包含了一组目标文件。make命令用一个特殊的语法来处理函数库，这使得函数库的管理工作变得非常容易。 用于管理函数库的语法是lib(file.o),它的含义是目标文件file.o是存储在函数库lib.a中的。make命令用一个内置规则来管理函数库，该规则的常见形式如下所示： makefile文件和子目录对于大型的项目，有时希望能把构成一个函数库的几个文件从主文件中分离出来，并将它们保存到一个子目录中。使用make命令完成这一工作的方法有两个。 第一个方法是，可以在子目录中编写出第二个makefile文件，它的作用是编译该子目录下的源文件，并将它们保存到一个函数库中，然后将该库文件复制到上一级的主目录中。在主目录中的makefile文件包含一条用于制作函数库的规则，该规则会调用第二个makefile.文件，如下所示： 12mylib.a:\t(cd mylibdirectory;$(MAKE)) ​ 这就是说，你必须总是执行命令make mylib.a。当make命令调用这条规则来创建函数库时，它将切换到子目录mylibdirectory中，然后调用一个新的make命令来管理函数库。由于make会针对每个命令调用一个新的shell,而使用第二个makefile文件的make命令本身又并没有执行cd命令，但它又必须在一个不同的目录下创建函数库，为解决这一问题，我们用括号将这两个命令括起来，从而确保它们只被一个单独的shell处理。 第二个方法是，在原来的makefile文件中添加一些宏。新添加的宏通过在我们己见过的宏的尾部追加一个字母得到，字母D代表目录，字母F代表文件名。然后你就可以用下面的规则来替换内置的.c.o后缀规则： 12.c.o:\t$(CC) $(CFLAGS) -c $(@D) /$(&lt;F) -o $(@D)/$(@F) 这条规则的作用是：编译子目录中的源文件并将目标文件放在该子目录中。然后，你用如下的依赖关系和规则来更新当前目录下的函数库： 12mylib.a: mydir/2.o mydir/3.o\tar -rv mylib.a $? GNU make和gcc","tags":["linux"]},{"title":"linux-基础命令使用","path":"/2024/02/26/linux-基本命令使用/","content":"Linux系统基础资料：https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/index.html 0.Linux帮助命令在linux终端，面对命令不知道怎么用，或不记得命令的拼写及参数时，我们需要求助于系统的帮助文档； linux系统内置的帮助文档很详细，通常能解决我们的问题，我们需要掌握如何正确的去使用它们； 在只记得部分命令关键字的场合，我们可通过man -k来搜索； 需要知道某个命令的简要说明，可以使用whatis；而更详细的介绍，则可用info命令； 查看命令在哪个位置，我们需要使用which； 而对于命令的具体参数及使用方法，我们需要用到强大的man； whatis与info命令简要说明命令的作用（显示命令所处的man分类页面）: 1$whatis command 正则匹配: 1$whatis -w &quot;loca*&quot; 更加详细的说明文档: 1$info command man命令查询命令command的说明文档: 12$man commandeg：man date 使用page up和page down来上下翻页。 在man的帮助手册中，将帮助文档分为了9个类别，对于有的关键字可能存在多个类别中， 我们就需要指定特定的类别来查看；（一般我们查询bash命令，归类在1类中）； man页面所属的分类标识(常用的是分类1和分类3) 123456789(1)、用户可以操作的命令或者是可执行文件(2)、系统核心可调用的函数与工具等(3)、一些常用的函数与数据库(4)、设备文件的说明(5)、设置文件或者某些文件的格式(6)、游戏(7)、惯例与协议等。例如Linux标准文件系统、网络协议、ASCⅡ，码等说明内容(8)、系统管理员可用的管理条令(9)、与内核有关的文件 前面说到使用whatis会显示命令所在的具体的文档类别，我们学习如何使用它 1234567eg:$whatis printfprintf (1) - format and print dataprintf (1p) - write formatted outputprintf (3) - formatted output conversionprintf (3p) - print formatted outputprintf [builtins] (1) - bash built-in commands, see bash(1) 我们看到printf在分类1和分类3中都有；分类1中的页面是命令操作及可执行文件的帮助；而3是常用函数库说明；如果我们想看的是C语言中printf的用法，可以指定查看分类3的帮助： 123$man 3 printf$man -k keyword 查询关键字 根据命令中部分关键字来查询命令，适用于只记住部分命令的场合； eg：查找GNOME的config配置工具命令: 1$man -k GNOME config| grep 1 对于某个单词搜索，可直接使用&#x2F;word来使用: &#x2F;-a; 多关注下SEE ALSO 可看到更多精彩内容 which与whereis命令查看程序的binary文件所在路径: 1$which command eg:查找make程序安装路径: 12$which make/opt/app/openav/soft/bin/make install 查看程序的搜索路径: 1$whereis command 当系统中安装了同一软件的多个版本时，不确定使用的是哪个版本时，这个命令就能派上用场； 1.文件及目录管理文件创建、删除和修改 创建新文件（夹）：touch、mkdir 1234#创建新文件touch 新文件名1 新文件名2...#创建新文件夹mkdir 新文件夹1 新文件夹2... 删除：rm、rmdir 12345678#删除文件rm 文件名1 文件名2...#删除空文件夹rmdir 空文件夹名1 空文件夹名2...#删除整个文件夹，包含里面所有内容rm -rf 文件夹名1 文件夹名2...#删除日志 rm \\*log (等价: $find ./ -name “*log” -exec rm &#123;&#125; ;) 移动和重命名：mv 123456#移动文件mv 文件名 目标路径#移动文件夹，需在文件夹名后面加&#x27;/&#x27;mv 文件夹名/ 目标路径#重命名文件/文件夹mv 原文件名/文件夹名 新文件名/文件夹名 复制：cp (cp -r ) 123456#复制文件cp 待复制文件(夹)名 目标路径#复制文件夹，文件夹名后加&#x27;/&#x27;cp 带复制文件夹名/ 目标路径#若含子文件夹则需加-rcp -r 带复制文件夹名/ 目标路径 文件颜色颜色–详解： 绿色文件———-可执行文件，可执行的程序 红色文件———–压缩文件或者包文件 蓝色文件———-目录 白色文件———-普通，如文本文件，配置文件，源码文件等 浅蓝色文件———-链接文件，主要是使用ln命令建立的文件 红色闪烁———-表示链接的文件有问题 黄色文件———-表示设备文件 灰色文件———-表示其它文件 目录显示及切换目录内容显示 显示当前目录下的文件 ls 按时间排序，以列表的方式显示目录项 ls -lrt 显示当前目录路径：pwd 目录切换 找到文件&#x2F;目录位置：cd 切换到上一个工作目录： cd - 切换到home目录： cd or cd ~ 显示当前路径: pwd 更改当前工作路径为path: cd path 查找目录及文件名 find1234567891011121314151617181920212223242526272829303132333435#1.按文件名find 路径 -name &quot;文件名&quot;#搜寻文件或目录:$find ./ -name &quot;core*&quot; | xargs file#查找目标文件夹中是否有obj文件:$find ./ -name &#x27;*.o&#x27;#2.按文件类型find 路径 -type 类型#类型：普通文件f、目录d、符号链接l、块设备文件b、字符设备文件c、socket文件s、管道文件p #3.按照文件大小find 路径 -size 范围#范围：+表示大于 -表示小于 等于不需要符号#大小：M(必须大写) k(必须小写) c(表示字符)find / -size +0k -size -10k#4.按照文件日期#按照创建日期查找find 路径 -ctime -n/+n\t#-n:n天以内，+n：n天以外#按照修改日期查找find 路径 -mtime -n/+n#按照访问日期查找find 路径 -atime -n/+n#5.高级查找#-execfind 路径 查找方式 -exec shell命令 &#123;&#125; \\;#递归当前目录及子目录删除所有.o文件:$find ./ -name &quot;*.o&quot; -exec rm &#123;&#125; \\;#-ok，该方法与-exec相比更加安全，其存在确认过程find 路径 查找方式 -ok shell命令 &#123;&#125; \\;#管道方式find 路径 查找方式 | xargs shell命令 文件定位locate1234#find是实时查找，如果需要更快的查询，可试试locate；locate会为文件系统建立索引数据库，如果有文件更新，需要定期执行更新命令来更新索引库:$updatedb#寻找包含有string的路径:$locate string 文件内容查看及查找查看文件内容12345678910111213141516#查看文件：cat vi head tail more#显示时同时显示行号:$cat -n#按页显示列表内容:$ls -al | more#只看前10行:$head - 10 **#显示文件第一行:$head -1 filename#显示文件倒数第五行:$tail -5 filename#查看两个文件间的差别:$diff file1 file2#动态显示文本最新信息:$tail -f crawler.log 查找文件内容grep&#x2F;egrep12345678910111213141516#grep查找grep 参数 &quot;内容&quot; 查找目录或文件#参数：#-r 若是目录，则可以递归查找#-n:可以显示该查找内容所在的行号#-i:可以忽略大小写进行查找#-v:不显示含有某字符串#grep和find命令结合使用find ./ -name &quot;*.cpp&quot; | xargs grep -n &quot;main&quot;#egrep支持更多扩展，使用egrep查询文件内容:egrep &#x27;03.1\\/CO\\/AE&#x27; TSF_STAT_111130.log.012egrep &#x27;A_LMCA777:C&#x27; TSF_STAT_111130.log.035 &gt; co.out2 文件权限及修改1、命令ls12345#默认只显示可见文件名称，-a显示所有文件，-l显示可见文件的权限#显示所有文件及权限ls -al#显示指定文件的权限ls 指定文件名 -l 2、权限内容 权限结构：设备类型+所属用户权限+所属组权限+其他用户权限。 第一位为设备类型。各类型如下： -rw-rw-r---:普通文件 crw-rw----c:字符设备 brw-rw----b:块设备 drwxrwxr-xd:目录文件 srw-rw-r--s:套接字 lrwxrwxrwxl：连接文件（软连接） 后面每三位为一组权限，顺序依次为”所属用户权限+所属组权限+其他用户权限“。 r：读 w：写 x：可执行 3、权限修改 改变文件的拥有者 chown 改变文件读、写、执行等属性 chmod 递归子目录修改： chown -R tuxapp source&#x2F; 增加脚本可执行权限： chmod a+x myscript 12345678#修改文件权限。7转化成二进制位111，表示rw权限；三个7则一次表示所属用户、组及其他用户权限。chmod 777 文件名#改变文件所属用户chown 用户名 文件名#改变文件所属组chown .组 文件名#改变文件所属用户及组chown 用户名 .组 文件名 给文件增加别名1234#硬连接；删除一个，将仍能找到；ln cc ccAgain #符号链接(软链接)；删除源，另一个无法使用；（后面一个ccTo 为新建的文件）ln -s cc ccTo 管道 批处理命令连接执行，使用 | 串联: 使用分号 ; 前面成功，则执行后面一条，否则，不执行:&amp;&amp; 前面失败，则后一条执行: || 12345ls /proc &amp;&amp; echo suss! || echo failed.#与上述相同效果的是:if ls /proc; then echo suss; else echo fail; fi 重定向123456789101112131415161718192021222324#1.&gt; 和 &gt;&gt;#&gt;是重定向(覆盖)到一个文件，&gt;&gt;是追加内容到一个文件.如果文件不存在，那么这两个命令都会首先创建这个文件。#2. 1&gt; 和 2&gt; #1&gt; 将正确的输出重定向到某个文件;2&gt; 将错误的输出重定向到某个文件#将错误输出和正确输出保存到同一个文件：command 1&gt; a.txt 2&gt;&amp;1#或者command &gt; a.txt 2&gt;&amp;1#3.1&gt;&gt; 和 2&gt;&gt;#将错误的和正确的信息重定向追加到同一个文件command 1&gt;&gt; a.txt 2&gt;&amp;1#正确的结果想追加，错误的结果覆盖。command 1&gt;&gt; right.txt 2&gt; wrong.txt#4.&lt;#&lt; 可以将原本由标准输入改为由指定地方输入#建一个hh文件，里面写入hello world#执行 &gt;&gt; txt.py &lt; hh，就可以把hh里面的内容写入到txt.py#清空文件::&gt; a.txt 设置环境变量12#启动帐号后自动执行的是 文件为 .profile，然后通过这个文件可设置自己的环境变量；安装的软件路径一般需要加入到path中:PATH=$APPDIR:/opt/app/soft/bin:$PATH:/usr/local/bin:$TUXDIR/bin:$ORACLE_HOME/bin;export PATH Bash快捷输入或删除12345快捷键:Ctl-U 删除光标到行首的所有字符,在某些设置下,删除全行Ctl-W 删除当前光标到前边的最近一个空格之间的字符Ctl-H backspace,删除光标前边的字符Ctl-R 匹配最相近的一个文件，然后输出 综合应用查找record.log中包含AAA，但不包含BBB的记录的总数: 1cat -v record.log | grep AAA | grep -v BBB | wc -l 总结 2.文本处理find 文件查找一般搜索查找txt和pdf文件: 1find . \\( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \\) -print 正则方式查找.txt和pdf: 1find . -regex &quot;.*\\(\\.txt|\\.pdf\\)$&quot; -iregex： 忽略大小写的正则 否定参数 ,查找所有非txt文本: 1find . ! -name &quot;*.txt&quot; -print 指定搜索深度,打印出当前目录的文件（深度为1）: 1find . -maxdepth 1 -type f 定制搜索 按类型搜索 1find . -type d -print //只列出所有目录 -type f 文件 &#x2F; l 符号链接 &#x2F; d 目录 find支持的文件检索类型可以区分普通文件和符号链接、目录等，但是二进制文件和文本文件无法直接通过find的类型区分出来； file命令可以检查文件具体类型（二进制或文本）: 1234$file redis-cli # 二进制文件redis-cli: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.9, not stripped$file redis.pid # 文本文件redis.pid: ASCII text 所以,可以用以下命令组合来实现查找本地目录下的所有二进制文件: 1ls -lrt | awk &#x27;&#123;print $9&#125;&#x27;|xargs file|grep ELF| awk &#x27;&#123;print $1&#125;&#x27;|tr -d &#x27;:&#x27; 按时间搜索 -atime 访问时间 (单位是天，分钟单位则是-amin，以下类似）-mtime 修改时间 （内容被修改）-ctime 变化时间 （元数据或权限变化） 最近第7天被访问过的所有文件: 1find . -atime 7 -type f -print 最近7天内被访问过的所有文件: 1find . -atime -7 -type f -print 查询7天前被访问过的所有文件: 1find . -atime +7 type f -print 按大小搜索： w字 k M G 寻找大于2k的文件: 1find . -type f -size +2k 按权限查找: 1find . -type f -perm 644 -print //找具有可执行权限的所有文件 按用户查找: 1find . -type f -user weber -print// 找用户weber所拥有的文件 找到后的后续动作 删除 删除当前目录下所有的swp文件: 1find . -type f -name &quot;*.swp&quot; -delete 另一种语法: 1find . type f -name &quot;*.swp&quot; | xargs rm 执行动作（强大的exec） 将当前目录下的所有权变更为weber: 1find . -type f -user root -exec chown weber &#123;&#125; \\; 注：{}是一个特殊的字符串，对于每一个匹配的文件，{}会被替换成相应的文件名； 将找到的文件全都copy到另一个目录: 1find . -type f -mtime +10 -name &quot;*.txt&quot; -exec cp &#123;&#125; OLD \\; 结合多个命令 如果需要后续执行多个命令，可以将多个命令写成一个脚本。然后 -exec 调用时执行脚本即可: 1-exec ./commands.sh &#123;&#125; \\; -print的定界符默认使用’ ’作为文件的定界符； -print0 使用’\\0’作为文件的定界符，这样就可以搜索包含空格的文件； grep 文本搜索xargs 命令行参数转换sort 排序uniq 消除重复行用tr进行转换cut 按列切分文本paste 按列拼接文本wc 统计行和字符的工具sed 文本替换利器awk 数据流处理工具迭代文件中的行、单词和字符 迭代文件中的每一行 2.迭代一行中的每一个单词 迭代每一个字符 3.磁盘管理查看磁盘空间查看磁盘空间利用大小: 1df -h -h: human缩写，以易读的方式显示结果（即带单位：比如M&#x2F;G，如果不加这个参数，显示的数字以B为单位） 1234567$df -h/opt/app/todeav/config#df -hFilesystem Size Used Avail Use% Mounted on/dev/mapper/VolGroup00-LogVol002.0G 711M 1.2G 38% //dev/mapper/vg1-lv2 20G 3.8G 15G 21% /opt/applog/dev/mapper/vg1-lv1 20G 13G 5.6G 70% /opt/app 查看当前目录所占空间大小: 1du -sh -h 人性化显示 -s 递归整个目录的大小 12$du -sh653M 查看当前目录下所有子文件夹排序后的大小: 123for i in `ls`; do du -sh $i; done | sort或者：du -sh `ls` | sort 打包&#x2F; 压缩在linux中打包和压缩和分两步来实现的； 打包 打包是将多个文件归并到一个文件: 1tar -cvf etc.tar /etc &lt;==仅打包，不压缩！ -c :打包选项 -v :显示打包进度 -f :使用档案文件 注：有的系统中指定参数时不需要在前面加上-，直接使用tar xvf 示例：用tar实现文件夹同步，排除部分文件不同步: 1tar --exclude &#x27;*.svn&#x27; -cvf - /path/to/source | ( cd /path/to/target; tar -xf -) 压缩 1$gzip demo.txt 生成 demo.txt.gz 解包&#x2F;解压缩解包 1tar -xvf demo.tar -x 解包选项 若解压后缀为 .tar.gz的文件，则分两步： 1 先解压缩，生成**.tar: 1$gunzip demo.tar.gz 2 解包: 12$tar -xvf demo.tar$bzip2 -d demo.tar.bz2 bz2解压: 1tar jxvf demo.tar.bz2 如果tar 不支持j，则同样需要分两步来解包解压缩，使用bzip2来解压，再使用tar解包: 12bzip2 -d demo.tar.bz2tar -xvf demo.tar -d decompose,解压缩 tar解压参数说明： -z 解压gz文件 -j 解压bz2文件 -J 解压xz文件 4.进程管理查询进程查询正在运行的进程信息 1$ps -ef eg:查询归属于用户colin115的进程 12$ps -ef | grep colin115$ps -lu colin115 查询进程ID（适合只记得部分进程字段） 1234567$pgrep 查找进程eg:查询进程名中含有re的进程[/home/weber#]pgrep -l re2 kthreadd28 ecryptfs-kthrea29515 redis-server 以完整的格式显示所有的进程 1$ps -ajx 显示进程信息，并实时更新 1$top 查看端口占用的进程状态： 1lsof -i:3306 查看用户username的进程所打开的文件 1$lsof -u username 查询init进程当前打开的文件 1$lsof -c init 查询指定的进程ID(23295)打开的文件： 1$lsof -p 23295 查询指定目录下被进程开启的文件（使用+D 递归目录）： 1$lsof +d mydir1/ 终止进程杀死指定PID的进程 (PID为Process ID) 1$kill PID 杀死相关进程 1kill -9 3434 杀死job工作 (job为job number) 1$kill %job 进程监控查看系统中使用CPU、使用内存最多的进程； 12$top(-&gt;)P 输入top命令后，进入到交互界面；接着输入字符命令后显示相应的进程状态： 对于进程，平时我们最常想知道的就是哪些进程占用CPU最多，占用内存最多。以下两个命令就可以满足要求: 123P：根据CPU使用百分比大小进行排序。M：根据驻留内存大小进行排序。i：使top不显示任何闲置或者僵死进程。 分析线程栈使用命令pmap，来输出进程内存的状况，可以用来分析线程堆栈； 1234567891011$pmap PIDeg:[/home/weber#]ps -fe| grep redisweber 13508 13070 0 08:14 pts/0 00:00:00 grep --color=auto redisweber 29515 1 0 2013 ? 02:55:59 ./redis-server redis.conf[/home/weber#]pmap 2951529515: ./redis-server redis.conf08048000 768K r-x-- /home/weber/soft/redis-2.6.16/src/redis-server08108000 4K r---- /home/weber/soft/redis-2.6.16/src/redis-server08109000 12K rw--- /home/weber/soft/redis-2.6.16/src/redis-server 综合运用将用户colin115下的所有进程名以av_开头的进程终止: 1ps -u colin115 | awk &#x27;/av_/ &#123;print &quot;kill -9 &quot; $1&#125;&#x27; | sh 将用户colin115下所有进程名中包含HOST的进程终止: 1ps -fe| grep colin115|grep HOST |awk &#x27;&#123;print $2&#125;&#x27; | xargs kill -9; 5.性能监控工具监控CPU查看CPU使用率 12345678910$sar -ueg:$sar -u 1 2[/home/weber#]sar -u 1 2Linux 2.6.35-22-generic-pae (MyVPS) 06/28/2014 _i686_ (1 CPU)09:03:59 AM CPU %user %nice %system %iowait %steal %idle09:04:00 AM all 0.00 0.00 0.50 0.00 0.00 99.5009:04:01 AM all 0.00 0.00 0.00 0.00 0.00 100.00 后面的两个参数表示监控的频率，比如例子中的1和2，表示每秒采样一次，总共采样2次； 查看CPU平均负载 1$sar -q 1 2 sar指定-q后，就能查看运行队列中的进程数、系统上的进程大小、平均负载等； 查询内存查看内存使用状况 sar指定-r之后，可查看内存使用状况; 12345$sar -r 1 209:08:48 AM kbmemfree kbmemused %memused kbbuffers kbcached kbcommit %commit kbactive kbinact09:08:49 AM 17888 359784 95.26 37796 73272 507004 65.42 137400 15076409:08:50 AM 17888 359784 95.26 37796 73272 507004 65.42 137400 150764Average: 17888 359784 95.26 37796 73272 507004 65.42 137400 150764 查看内存使用量 1$free -m 查询页面交换查看页面交换发生状况 页面发生交换时，服务器的吞吐量会大幅下降；服务器状况不良时，如果怀疑因为内存不足而导致了页面交换的发生，可以使用sar -W这个命令来确认是否发生了大量的交换； 1$sar -W 1 3 查询硬盘使用查看磁盘空间利用情况 1$df -h 查询当前目录下空间使用情况 1du -sh -h是人性化显示 s是递归整个目录的大小 查看该目录下所有文件夹的排序后的大小 123for i in `ls`; do du -sh $i; done | sort或者du -sh `ls` 综合应用当系统中sar不可用时，可以使用以下工具替代：linux下有 vmstat、Unix系统有prstat eg： 查看cpu、内存、使用情况： vmstat n m （n 为监控频率、m为监控次数） 123456[/home/weber#]vmstat 1 3procs -----------memory---------- ---swap-- -----io---- -system-- ----cpu----r b swpd free buff cache si so bi bo in cs us sy id wa0 0 86560 42300 9752 63556 0 1 1 1 0 0 0 0 99 01 0 86560 39936 9764 63544 0 0 0 52 66 95 5 0 95 00 0 86560 42168 9772 63556 0 0 0 20 127 231 13 2 84 0 使用watch 工具监控变化 当需要持续的监控应用的某个数据变化时，watch工具能满足要求； 执行watch命令后，会进入到一个界面，输出当前被监控的数据，一旦数据变化，便会高亮显示变化情况； eg：操作redis时，监控内存变化： 123456789$watch -d -n 1 &#x27;./redis-cli info | grep memory&#x27;(以下为watch工具中的界面内容，一旦内存变化，即实时高亮显示变化）Every 1.0s: ./redis-cli info | grep memory Mon Apr 28 16:10:36 2014used_memory:45157376used_memory_human:43.07Mused_memory_rss:47628288used_memory_peak:49686080used_memory_peak_human:47.38M 6.网络工具查询网络服务和端口netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。 列出所有端口 (包括监听和未监听的): 1netstat -a 列出所有 tcp 端口: 1netstat -at 列出所有有监听的服务状态: 1netstat -l 使用netstat工具查询端口: 123456$netstat -antp | grep 6379tcp 0 0 127.0.0.1:6379 0.0.0.0:* LISTEN 25501/redis-server$ps 25501 PID TTY STAT TIME COMMAND25501 ? Ssl 28:21 ./redis-server ./redis.conf lsof（list open files）是一个列出当前系统打开文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等； 在查询网络端口时，经常会用到这个工具。 查询7902端口现在运行什么程序: 1234567891011#分为两步#第一步，查询使用该端口的进程的PID； $lsof -i:7902 COMMAND PID USER FD TYPE DEVICE SIZE NODE NAME WSL 30294 tuapp 4u IPv4 447684086 TCP 10.6.50.37:tnos-dp (LISTEN)#查到30294#使用ps工具查询进程详情：$ps -fe | grep 30294tdev5 30294 26160 0 Sep10 ? 01:10:50 tdesl -k 43476root 22781 22698 0 00:54 pts/20 00:00:00 grep 11554 网络路由查看路由状态: 1$route -n 发送ping包到地址IP: 1$ping IP 探测前往地址IP的路由路径: 1$traceroute IP DNS查询，寻找域名domain对应的IP: 1$host domain 反向DNS查询: 1$host IP 镜像下载直接下载文件或者网页: 1wget url 常用选项: –limit-rate :下载限速 -o：指定日志文件；输出都写入日志； -c：断点续传 ftp&#x2F;sftp&#x2F;lftp&#x2F;sshSSH登陆: 1$ssh ID@host ssh登陆远程服务器host，ID为用户名。 ftp&#x2F;sftp文件传输: 1$sftp ID@host 登陆服务器host，ID为用户名。sftp登陆后，可以使用下面的命令进一步操作： get filename # 下载文件 put filename # 上传文件 ls # 列出host上当前路径的所有文件 cd # 在host上更改当前路径 lls # 列出本地主机上当前路径的所有文件 lcd # 在本地主机更改当前路径 lftp同步文件夹(类似rsync工具): 12lftp -u user:pass hostlftp user@host:~&gt; mirror -n 网络复制将本地localpath指向的文件上传到远程主机的path路径: 1$scp localpath ID@host:path 以ssh协议，遍历下载path路径下的整个文件系统，到本地的localpath: 1$scp -r ID@site:path localpath 7.用户管理工具用户添加用户1$useradd -m username 该命令为用户创建相应的帐号和用户目录&#x2F;home&#x2F;username； 用户添加之后，设置密码： 密码以交互方式创建: 1$passwd username 删除用户1$userdel -r username 不带选项使用 userdel，只会删除用户。用户的家目录将仍会在&#x2F;home目录下。要完全的删除用户信息，使用-r选项； 帐号切换 登录帐号为userA用户状态下，切换到userB用户帐号工作: 1$su userB 进入交互模型，输入密码授权进入； 用户的组将用户加入到组默认情况下，添加用户操作也会相应的增加一个同名的组，用户属于同名组； 查看当前用户所属的组: 1$groups 一个用户可以属于多个组，将用户加入到组: 1$usermod -G groupNmame username 变更用户所属的根组(将用加入到新的组，并从原有的组中除去）: 1$usermod -g groupName username 查看系统所有组系统的所有用户及所有组信息分别记录在两个文件中：&#x2F;etc&#x2F;passwd , &#x2F;etc&#x2F;group 默认情况下这两个文件对所有用户可读： 查看所有用户及权限: 1$more /etc/passwd 查看所有的用户组及权限: 1$more /etc/group 用户权限使用ls -l可查看文件的属性字段，文件属性字段总共有10个字母组成，第一个字母表示文件类型，如果这个字母是一个减号”-”,则说明该文件是一个普通文件。字母”d”表示该文件是一个目录，字母”d”,是dirtectory(目录)的缩写。 后面的9个字母为该文件的权限标识，3个为一组，分别表示文件所属用户、用户所在组、其它用户的读写和执行权限； 例如: 12[/home/weber#]ls -l /etc/group-rwxrw-r-- colin king 725 2013-11-12 15:37 /home/colin/a 表示这个文件对文件拥有者colin这个用户可读写、可执行；对colin所在的组（king）可读可写；对其它用户只可读； 更改读写权限使用chmod命令更改文件的读写权限，更改读写权限有两种方法，一种是字母方式，一种是数字方式 字母方式: 1$chmod userMark(+|-)PermissionsMark userMark取值： u：用户 g：组 o：其它用户 a：所有用户 PermissionsMark取值： r:读 w：写 x：执行 例如: 12$chmod a+x main 对所有用户给文件main增加可执行权限$chmod g+w blogs 对组用户给文件blogs增加可写权限 数字方式： 数字方式直接设置所有权限，相比字母方式，更加简洁方便； 使用三位八进制数字的形式来表示权限，第一位指定属主的权限，第二位指定组权限，第三位指定其他用户的权限，每位通过4(读)、2(写)、1(执行)三种数值的和来确定权限。如6(4+2)代表有读写权，7(4+2+1)有读、写和执行的权限。 例如: 1$chmod 740 main 将main的用户权限设置为rwxr----- 更改文件或目录的拥有者1$chown username dirOrFile 使用-R选项递归更改该目下所有文件的拥有者: 1$chown -R weber server/ 环境变量bashrc与profile都用于保存用户的环境信息，bashrc用于交互式non-loginshell，而profile用于交互式login shell。 &#x2F;etc&#x2F;profile，&#x2F;etc&#x2F;bashrc 是系统全局环境变量设定 &#x2F;.profile，&#x2F;.bashrc用户目录下的私有环境变量设定 当登入系统获得一个shell进程时，其读取环境设置脚本分为三步: 首先读入的是全局环境变量设置文件&#x2F;etc&#x2F;profile，然后根据其内容读取额外的文档，如&#x2F;etc&#x2F;profile.d和&#x2F;etc&#x2F;inputrc 读取当前登录用户Home目录下的文件&#x2F;.bash_profile，其次读取&#x2F;.bash_login，最后读取~&#x2F;.profile，这三个文档设定基本上是一样的，读取有优先关系 读取~&#x2F;.bashrc &#x2F;.profile与&#x2F;.bashrc的区别: 这两者都具有个性化定制功能 ~&#x2F;.profile可以设定本用户专有的路径，环境变量，等，它只能登入的时候执行一次 ~&#x2F;.bashrc也是某用户专有设定文档，可以设定路径，命令别名，每次shell script的执行都会使用它一次 例如，我们可以在这些环境变量中设置自己经常进入的文件路径，以及命令的快捷方式： 1234567891011121314.bashrcalias m=&#x27;more&#x27;alias cp=&#x27;cp -i&#x27;alias mv=&#x27;mv -i&#x27;alias ll=&#x27;ls -l&#x27;alias lsl=&#x27;ls -lrt&#x27;alias lm=&#x27;ls -al|more&#x27;log=/opt/applog/common_dirunit=/opt/app/unittest/common.bash_profile. /opt/app/tuxapp/openav/config/setenv.prod.sh.linuxexport PS1=&#x27;$PWD#&#x27; 通过上述设置，我们进入log目录就只需要输入cd $log即可； 8.系统管理及IPC资源管理系统管理查询系统版本查看Linux系统版本: 12$uname -a$lsb_release -a 查看Unix系统版本：操作系统版本: 1$more /etc/release 查询硬件信息查看CPU使用情况: 1$sar -u 5 10 查询CPU信息: 1$cat /proc/cpuinfo 查看CPU的核的个数: 1$cat /proc/cpuinfo | grep processor | wc -l 查看内存信息: 1$cat /proc/meminfo 显示内存page大小（以KByte为单位）: 1$pagesize 显示架构: 1$arch 设置系统时间显示当前系统时间: 1$date 设置系统日期和时间(格式为2014-09-15 17:05:00): 123$date -s 2014-09-15 17:05:00$date -s 2014-09-15$date -s 17:05:00 设置时区: 12选择时区信息。命令为：tzselect根据系统提示，选择相应的时区信息。 强制把系统时间写入CMOS（这样，重启后时间也正确了）: 1$clock -w 显示当前系统时间: 1$date 设置系统日期和时间(格式为2014-09-15 17:05:00): 123$date -s 2014-09-15 17:05:00$date -s 2014-09-15$date -s 17:05:00 设置时区: 12选择时区信息。命令为：tzselect根据系统提示，选择相应的时区信息。 强制把系统时间写入CMOS（这样，重启后时间也正确了）: 1$clock -w IPC资源管理IPC资源查询查看系统使用的IPC资源: 1234567891011$ipcs------ Shared Memory Segments --------key shmid owner perms bytes nattch status------ Semaphore Arrays --------key semid owner perms nsems0x00000000 229376 weber 600 1------ Message Queues --------key msqid owner perms used-bytes messages 查看系统使用的IPC共享内存资源: 1$ipcs -m 查看系统使用的IPC队列资源: 1$ipcs -q 查看系统使用的IPC信号量资源: 1$ipcs -s 应用示例：查看IPC资源被谁占用 有个IPCKEY：51036 ，需要查询其是否被占用； 首先通过计算器将其转为十六进制: 51036 -&gt; c75c 如果知道是被共享内存占用: 12$ipcs -m | grep c75c0x0000c75c 40403197 tdea3 666 536870912 2 如果不确定，则直接查找: 123$ipcs | grep c75c0x0000c75c 40403197 tdea3 666 536870912 20x0000c75c 5079070 tdea3 666 4 检测和设置系统资源限制显示当前所有的系统资源limit 信息: 1ulimit – a 对生成的 core 文件的大小不进行限制: 1ulimit – c unlimited 其他工具tar工具在Linux平台，tar是主要的打包工具。tar命令通常用来把文件和目录压缩为一个文件（ tarball 或 tar, gzip 和 bzip）。 Tar选项： c – 创建压缩文件 x – 解压文件 v – 显示进度. f – 文件名. t – 查看压缩文件内容. j – 通过bzip2归档 z –通过gzip归档 r – 在压缩文件中追加文件或目录 W – 验证压缩文件 12#解压后文件名为原压缩包名字tar xvf 压缩包 locate定位文件linux会把系统内所有的文件都记录在一个数据库文件中，使用locate+文件名的方法会在linux系统维护的这个数据库中去查找目标，相比find命令去遍历磁盘查找的方式，效率会高很多，比较推荐使用这种方法。 因为该数据库默认是一天更新一次的，所有使用locate命令有可能找不到最近新建的文件。这时就需要手动更新数据库,命令很简单，直接在终端中输入sudo updatedb就可以进行更新，更新速度还是比较快的，所以在搜索文件的时候建议使用locate命令。 1locate 文件名 dd工具dd命令 1dd if=xxx of=xxx bs=num seek=num dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。注意：指定数字的地方若如下列字符结尾，则乘以相应的数字：b&#x3D;512；c&#x3D;1；k&#x3D;1024；w&#x3D;2。 参数注释： if&#x3D;文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if&#x3D;input file &gt; of&#x3D;文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of&#x3D;output file &gt; ibs&#x3D;bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。 obs&#x3D;bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。 bs&#x3D;bytes：同时设置读入&#x2F;输出的块大小为bytes个字节。 cbs&#x3D;bytes：一次转换bytes个字节，即指定转换缓冲区大小。 skip&#x3D;blocks：从输入文件开头跳过blocks个块后再开始复制。 seek&#x3D;blocks：从输出文件开头跳过blocks个块后再开始复制。 注意：一般只用当输出文件是磁盘或磁带时才有效，即备份到磁盘或磁带时才有效。 count&#x3D;blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。 conv&#x3D;conversion：用指定的参数转换文件。 ascii：转换ebcdic为ascii ebcdic：转换ascii为ebcdic ibm：转换ascii为alternate ebcdic block：把每一行转换为长度为cbs，不足部分用空格填充 unblock：使每一行的长度都为cbs，不足部分用空格填充 lcase：把大写字符转换为小写字符 ucase：把小写字符转换为大写字符 swab：交换输入的每对字节 noerror：出错时不中止 notrunc：不截短输出文件 sync：将每一个输入块填充到ibs个字节，不足部分用空（NUL）字符补齐。 &#x2F;dev&#x2F;null和&#x2F;dev&#x2F;zero的区别 &#x2F;dev&#x2F;null是一个伪文件，可以看做”黑洞”， 它等价于一个只写文件，全部写入它的内容都会永远丢失，而尝试从它那儿读取内容则什么也读不到。 &#x2F;dev&#x2F;zero是一个输入设备，该设备无穷尽地提供0，主要的用处是用来建立一个指定长度用于初始化的空文件，就像临时交换文件，可以用它来初始化文件。 wget工具wget是一个从网络上自动下载文件的自由工具。它支持HTTP，HTTPS和FTP协议，可以使用HTTP代理。 简单用法： 1wget https://地址 回收站12345trash-empty 清空回收站trash-empty days 删除回收站里面超过指定天数的文件foo文件会被放入回收站(trashcan)trash-list 列出回收站里面的文件restore-trash 恢复指定的文件 其他命令查看系统版本命令：1lsb_release -a Ubuntu系统扩容参考：https://blog.csdn.net/Lem0n_Tree/article/details/120705140 虚拟机修改磁盘大小，查看磁盘 1sudo fdisk -l 从上图看到，磁盘容量已经识别为100G，但分区表记录的容量仍然是50G（红色字体提示) 修复分区表 查看分区情况，会立即提示空间未全部使用，提示输入Fix修复分区表 1sudo parted -l 扩容分区 1sudo cfdisk 上下选中要扩容的分区，左右选择Resize后回车，会自动填写可用的总容量，也可以手动写入扩容后的总容量，回车后选择Write再次回车保存，退出。 这里是分配99G全部 保存输入yes后按q退出 扩容文件系统 此时可看到磁盘已经扩容，但文件系统大小仍然是扩容前的 12sudo pvslsblk 重置pv大小，再次查看大小容量已经变为更新了 12345sudo pvresize /dev/sda3sudo pvssudo pvdisplay#显示存在的卷组sudo vgdisplay free空间分配 12sudo lvextend -l +100%free /dev/mapper/ubuntu--vg-ubuntu--lv1 更新文件系统，查看已经成功扩容 12sudo resize2fs /dev/mapper/ubuntu--vg-ubuntu--lv1","tags":["linux"]},{"title":"C语言-关键字","path":"/2024/02/26/C语言-关键字/","content":"goto 无条件跳转 volatile 禁止编译器优化：编译器在编译过程中会对变量进行各种优化，包括缓存寄存器中的变量值，以提高程序执行速度。但是，在某些情况下，这种优化可能导致问题，特别是当变量的值由外部因素（例如硬件或其他线程）更改时。使用volatile 关键字可以告诉编译器不要进行这些优化，以确保变量的值在任何时刻都是最新的。 适用于多线程编程：在多线程环境中，多个线程可能同时访问和修改同一个变量。在这种情况下，使用volatile 可以确保线程在读取和写入volatile 变量时不会进行缓存，从而避免数据不一致的问题。 适用于嵌入式系统和硬件寄存器：在嵌入式系统编程中，经常需要访问硬件寄存器，这些寄存器的值可能会在任何时刻由硬件更改。使用volatile 可以确保编译器不会对这些寄存器的访问进行优化。 防止编译器删除无用的代码：在某些情况下，变量的值可能不会被用于计算结果，但它们的值仍然对程序的行为产生影响。使用volatile 可以防止编译器删除这些看似无用的代码。 union 对于联合体所有的成员都共享一块内存，而结构体是所有变量内存的叠加，需要考虑字节对齐问题，对于联合体来说，只要你修改里面的成员的数据就会修改其他成员的数据，而结构体的成员数据是不影响的 判断大小端问题 大端字节序：高字节存放在低位地址，低字节存放在高地址 小端字节序：低字节存放在低位，高字节存放在高位 计算占用空间大小问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647对于不同位的操作系统，个别数据类型数据大小不一样，Long 和unsigned long在32位中是4个字节在64位中是8个字节 计算的时候需要考虑字节对齐问题：1.\t所占空间必须是成员变量中字节最大的整数倍2.\t每个变量类型的偏移量必须是该变量类型的整数倍3.\t对于联合体，由于所有变量都是共用一块内存，还需注意数组占用最大内存例如：Typedef union &#123;double I;int k[5];char c;&#125; DATE;在联合体中成员变量最大为double为8个字节，所以最终大小必须是8的整数倍；又因为联合体是共占内存空间，即int*5=20字节，所以最终为24个字节Typedef struct data &#123;int cat;DATE cow; double dog;&#125;too;求sizeof(too);解：在结构体里面联合体为24，联合体的最大类型为8字节，所以联合体的起始位置必须满足偏移量为8的倍数，计算如下：Cat：1-4,DATE cow 8+24Double dog 32+8=40//联合体的计算公式：//最终的大小得是结构体中的类型的最大长度的整数倍，并且能容下所有类型union date&#123; char a; double b[3]; char c;&#125;;typedef union date DATE;/*结构体的计算：1.最终的大小得是结构体中的类型的最大长度的整数倍2.除了结构体中的联合体外，其他类型的偏移量必须是该类型的整数倍3.如果里面有联合体，该联合体的起始位置要满足该联合体的里面的最大长度类型的偏移量*/struct test&#123; char a;//1 DATE d;//8+24 char b;//33 char c; //34&#125;;//最终40typedef struct test TEST;int main()&#123; printf(&quot;%ld &quot;,sizeof(DATE));//24 printf(&quot;%ld &quot;,sizeof(TEST));//40 return 0;&#125; define &amp; typedef #define是C语言中定义的语法，是预处理指令，在预处理时进行简单而机械的字符串替换，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。 typedef是关键字，在编译时处理，有类型检查功能。它在自己的作用域内给一个已经存在的类型一个别名，但不能在一个函数定义里面使用typedef。用typedef定义数组、指针、结构等类型会带来很大的方便，不仅使程序书写简单，也使意义明确，增强可读性。 extern 变量声明：通过使用 extern，你可以在一个源文件中声明一个在另一个源文件中定义的全局变量，以便在当前源文件中使用它，而不需要重新定义。这对于在多个文件中共享全局变量非常有用。 1234// File1.cint globalVar; // 定义全局变量// File2.cextern int globalVar; // 声明在其他文件中定义的全局变量 函数声明：类似于变量，你也可以使用 extern 来声明在其他源文件中定义的函数。这允许你在当前文件中使用这些函数而无需重新定义它们。 1234// File1.cvoid someFunction(); // 定义函数// File2.cextern void someFunction(); // 声明在其他文件中定义的函数 解决多文件编程：extern 用于多文件编程中，特别是当你将程序拆分成多个源文件时，有助于确保这些文件之间的全局变量和函数能够正确共享。它允许你在一个文件中定义，而在其他文件中声明和使用这些全局实体。 避免重复定义：extern 声明允许你在一个文件中定义全局变量或函数，而在其他文件中声明，从而避免多次定义相同的变量或函数，这将导致链接错误。 register 建议寄存器存储：通过使用 register 关键字，程序员可以向编译器建议将某个变量存储在寄存器中。寄存器是位于中央处理单元（CPU）内部的存储区域，它的访问速度比内存要快得多。因此，将变量存储在寄存器中可以提高程序的执行速度。 1register int counter; // 建议编译器将 counter 存储在寄存器中 编译器决定：需要强调的是，register 只是一个建议，而非强制要求。编译器可以选择是否将变量存储在寄存器中。通常，编译器会根据代码的复杂性和寄存器的可用性来决定是否采纳这些建议。 限制使用：register 变量通常有一些限制，例如不能取地址或使用指针对其进行操作，因为寄存器变量不在内存中有地址。这也意味着 register 变量通常不能用于需要取地址的操作，如指针和数组的地址计算。 性能提升：使用 register 可以提高程序的性能，特别是在循环中对频繁访问的变量使用 register 可能会产生显著的性能提升。 const 创建常量变量：通过将 const 关键字应用于变量，你可以创建一个不可更改的常量。这意味着一旦给定值赋予这个变量，它的值将不再改变。 1const int max_value = 100; 防止无意的修改：使用 const 可以避免在代码中无意地修改常量的值。如果你尝试修改一个被声明为 const 的变量，编译器将生成错误或警告。 12const double pi = 3.14159;// 试图修改 pi 的值将导致编译错误 static 文件作用域变量：使用 static 可将全局变量的作用域限制在当前源文件中，防止其他文件访问或修改。 1static int globalVar = 5; // 限制作用域在当前文件中 静态局部变量：在函数内部使用 static 可使局部变量在函数调用之间保持其值。 1234void myFunction() &#123; static int counter = 0; // 保持在函数调用之间的值 counter++;&#125; 静态函数：使用 static 可将函数的作用域限制在当前源文件中，避免与其他文件的函数冲突。 123static void internalFunction() &#123; // 内部链接函数，只在当前文件中可见&#125; 模块局变量：通过将变量声明为 static，可以在不同的文件中创建具有持久性的变量，以避免冲突。 12345// File1.cstatic int globalVar = 42; // 只能在当前文件中访问// File2.cint anotherVar = 123; // 可以被其他文件访问的全局变量 核心 限制作用域 限制存储域 sizeof &amp; strlen() 区别 首先sizeof是关键字，strlen是函数，sizeof用来计算占用内存大小，strlen是用来计算字符串的长度，特别是对于需不需要包含\\0问题：Sizeof是需要给\\0计算空间的，strlen是不需要，sizeof是在编译的时候计算的，而strlen是在运行的时候计算 求指针大小 在32位机器下，对于sizeof(指针变量)都是4个字节，比如 Int *a; Sizeof(a); 求引用大小 Sizeof(char &amp;) &#x2F;&#x2F; 1 引用大小和数据类型有关 计算数组大小 123456int num[5]=&#123;1,2,3,4&#125;;printf(&quot;%ld &quot;,sizeof(num));//20char str[10]=&#123;&quot;hello&quot;&#125;;printf(&quot;%ld &quot;,strlen(str));//5printf(&quot;%ld &quot;,sizeof(str));//10 不使用sizeof求数据类型字节的大小 1#define mysieof(value) (char*)(&amp;value+1)-(char*)(&amp;value) strlen(“\\0”) &#x3D; ? sizeof(“\\0”) 12printf(&quot;%d &quot;,sizeof(&quot;\\0&quot;));//2 因为这里有\\0\\0printf(&quot;%d &quot;,strlen(&quot;\\0&quot;));//0 sizeof(a++) 1234int a = 2;printf(&quot;%d &quot;,sizeof(a++)); //4printf(&quot;%d &quot;,a);\t// a = 2// 注意：对于sizeof只会求所占内存大小，不会进行表达式运算 计算字符数组大小 123456char ch[] = &quot;hello&quot;;char str[10] = &#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;;printf(&quot;%d &quot;,sizeof(ch));//6printf(&quot;%d &quot;,strlen(ch));//5printf(&quot;%d &quot;,sizeof(str));//10printf(&quot;%d &quot;,strlen(str));//5 char *str1 &#x3D; “hello”和char str2[] &#x3D; “hello” 123456789char str[] = &quot;hello&quot;;char *str1 =&quot;hello&quot;;//区别一 数组名不可以自加,因为数组名是地址常量//str++;//str1++;//区别二 ,数组里面的元素可以修改，str1指向的地址的内容不可以修改 str[0] = &#x27;W&#x27;;*str1 = &#x27;w&#x27;;//段错误//总结： 数组名就相当于是指针常量，只可以修改里面的内容，不可以修改指向的地址，字符指针相当于是常量指针，不可以修改指向的地址的内容，可以修改地址","tags":["C语言"]},{"title":"C语言-预处理相关","path":"/2024/02/26/C语言-预处理相关/","content":"#error 12345678// 编译程序时，只要遇到#error就会生成一个编译错误提醒，并且停止编译，语法格式:#error error-message实例:#ifdef xxx#error “xxx has been defined”#else#endif #ifndef #define #endif 1234// 当项目中有多个c文件使用到同一个头文件是，在编译的时候会出现大量的变量，函数声明冲突，解决就是使用#ifndef _HEAR_H_#define _HEAR_H_#endif #define和const Define和const 都可以用于定义常量但以下区别(生效时间，内存占用情况，类型检查)： define只是单纯的文本替换，define常量的生命生命周期止于编译器，不存在分配内存，存在与程序的代码段 const生效于编译的阶段；define生效于预处理阶段 Const修饰的常量处于程序的数据段，在堆栈中分配空间 Const有数据类型检查，define没有 #define不可调试，const能调试 const定义的变量在C中不是真正的常量 Const 定义的常量不能作为数组的大小 typedef和#define 原理不同： 首先#define是预处理命令，在预处理阶段只是机械的替换带入字符串，并不会左类型检查， typedef是关键字，作用是给自己的作用域内给一个已经存在的类型起个别名 #define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而typedef有自己的作用域 对指针的操作不同 #define 表明一年 1#define YEAR (60 * 60 * 24 * 365)ul 标准宏MIN 1#define MIN(a, b) ((a) &lt; (b) ? (a) : (b)) 缺点 无法进行类型检查 运算优先级问题 无法调试 代码膨胀 无法操作类的私有数据成员 123456789101112131415161718192021222324252627#define m(a,b) a*b// #define m(a,b) (a)*(b)//避免出问题最好加上()int main()&#123; printf(&quot;%d &quot;,m(5,6)); printf(&quot;%d &quot;,m(5+1,6));//实际是这样的：5+1*6 return 0;&#125;#define sqort(a) ((a)*(a))// 实例1： int a = 5;int b = sqort(a++);//( (a++) * (a++) ) 先给括号赋值 5之后a再+1=6printf(&quot;%d &quot;,b);//30printf(&quot;%d &quot;,a);//7// 实例2：\tint a = 5;int b = sqort(++a);//(（++a）* (++a)) printf(&quot;%d &quot;,b);//49printf(&quot;%d &quot;,a);//7这里主要是考察++a和后加加的问题// 记住一点：++a返回的a的引用，a++返回的是a加之前的数值a的引用是要等最终的那个a才能确定的 #include 对于.#include&lt;头文件&gt;，表示是系统文件，编译会先从标准库路径下搜索，编译器设置的头文件路径–&gt;系统变量 对于#include”头文件”，当前头文件目录–&gt;编译器设置的头文件路径–&gt;系统变量 C代码编译过程 预处理（Preprocessing）： 预处理阶段是在实际编译之前的一个可选步骤，用于处理源代码中的预处理指令，比如 #include 和 #define。 预处理器将处理这些指令，并且可能会包含其他文件、进行宏替换等。 预处理的输出是一个经过处理的源文件，通常以.i或.ii为扩展名。 编译（Compiling）： 编译阶段将预处理后的源代码转换为汇编代码（Assembly Code）。 编译器（如GNU Compiler Collection中的gcc）将C源代码翻译成汇编语言。 输出是一个以.s为扩展名的汇编代码文件。 汇编（Assembling）： 汇编阶段将汇编代码转换为机器语言指令。 汇编器（如GNU Assembler中的as）将汇编代码翻译成机器码。 输出是一个以.o或.obj为扩展名的目标文件，包含了二进制指令。 链接（Linking）： 链接阶段将多个目标文件（例如，多个C文件分别编译得到的目标文件）合并为一个可执行文件。 链接器（如GNU的ld或gcc中的链接器部分）将各个目标文件中的函数和变量引用解析，并创建一个可执行文件。 链接的输出是一个可执行的二进制文件，可以在操作系统上运行。 在头文件中是否可以定义静态变量 不可以，因为静态变量是有记忆的，不会随函数结束而结束，所以，如果定义在头文件中，那么就会被多个文件开辟空间，浪费资源或者重新出错 #和##的作用 123456789101112131415// #利用宏参数字符串化#define ARGV(x) printf(&quot;&quot;#x&quot; is %s &quot;,#x) //表示把参数x解释为字符串int a = 5;ARGV(a); //a is a// ##运算符粘合剂 组合成一个变量，强制分隔#define targ( n ) X##n //表示X1......或Xnint main()&#123; int a = 5; // ARGV(a); int targ(1) = 10;//表示 X1 =10 printf(&quot;%d\\&quot;,X1);//10 return 0&#125;","tags":["C语言"]},{"title":"C语言-指针与数组相关","path":"/2024/02/26/C语言-指针与数组相关/","content":"指针 指针是一种编程概念，它是一个变量或数据类型，用于存储内存地址。指针允许程序直接访问和操作内存中的数据，而不仅仅是访问变量的值。指针通常在低级编程语言（如C和C++）中使用，以及某些高级编程语言中的底层编程任务中。 关键要点关于指针包括： 内存地址：指针存储一个内存地址，该地址指向计算机内存中的某个位置。 指向：指针可以指向内存中的数据，这可以是基本数据类型（如整数、字符）或复杂的数据结构（如数组、结构体）。 解引用：通过解引用指针，可以访问指针所指向的内存地址上的值。解引用操作使用 * 符号。 地址运算：指针可以进行地址运算，例如指针加法或减法，以访问相邻内存位置。 动态内存分配：指针在动态内存分配中非常有用，允许程序在运行时分配和释放内存，避免静态内存分配的限制。 传递参数：指针允许将变量的地址传递给函数，以便在函数内部修改变量的值。 好处 指针可以动态分配内存 在链表中可以方便修改链表的节点 解析字符串 相同类型的指针可以直接复制 调用Free释放内存后，指针还能用吗 Free释放掉内存后，只是把内存的使用权就被归还给系统，内存里面的东西可能被清除也可能是垃圾值，但是指向这个内存的指针还是指向这块内存，并不会NULL 指针不能加指针 指针之间可以做减法，但不能做加法 空指针是指指向地址为0的地方 数组 初始化 12345int a[][2]; //不允许int b[][2]=&#123;1,2,3,4&#125;; //可以int c[] = &#123;1,2,3&#125;; // 可以int c[]; //不可以int d[][]; //不允许，第二个[]必须填，不管有没有初始化 数组名num &#x2F; &amp;num的区别 对于一维数组来说 num+1是偏移到下个元素，&amp;num+1是偏移整个数组 对于二维数组来说 num+1是偏移一个一维数组，&amp;num+1是整个数组 数组下标是负数 12345678910int a[5] = &#123;0,1,2,3,4&#125;;int *p = &amp;a[4];for(int i=-4; i&lt;=0; i++)&#123; printf(%d %d &quot;, p[i], &amp;p[i])&#125;// 0 1310572// 1 1310576// 2 1310580…… 二维数组 int a[3][3]; int a[3][3];表示是个三行三列的二维数组 数组名表示数组首元素的地址，即第0行第0个地址 a+1表示地址偏移一个一维数组的地址，即三列int大小&#x3D;34 &#x3D; 12 a 表示去二维变一维，a就相当于一维数组的数组名，比如 *a +1 表示第0行下标为1的元素地址，只是偏移一个Int地址 若要表示a[2][2]的元素 即 ((a+2)+2) 指针的运算 123456789// 例子1：int *ptr;//假设指针指向的地址是0x 00 00 00 00Ptr++; //运算之后指针指向0x 00 00 00 04Char *p;P++;//地址偏移1// 注意:对于一级指针的++操作偏移量要看指针指向的是什么类型// 对应二级指针偏移量，对于32系统是4个字节，因为二级指针指向的类型就是指针，所以永远是一个指针类型的大小 1234567891011// 例子2：#include&lt;stdio.h&gt; int main() &#123; char a[20]=&quot;You_are_a_girl&quot;; char *p=a; char **ptr=&amp;p; printf(&quot;**ptr=%c &quot;,**ptr); ptr++; printf(&quot;**ptr=%c &quot;,**ptr); &#125;// 在这个例子中是无法确定二级指针++之后指向的地址内容，因为二级指针(ptr)指针指向的一级指针的地址，如果二级指针(ptr)++之后，那么就会指向一级指针的后4个字节(对于32位操作系统来说指针类型是4字节)，至于这个地址里面是啥无从得知 123456789101112131415161718// *p++ *(p++) (*p)++ *++p ++*p 的运算int num[] = &#123;1, 2, 3, 4&#125;;1. 后++先不用管，即先把地址里面的值给别人，再去++，可以是地址或值(看括号是否包住*p,是则是值++)，后++有三种如下：(*p)++ 地址前后都不会变化，变化的是地址里面的值，先赋值给别人，*P再++*(p++)和*p++一样 地址发生变化，先把*P赋值给别人，再++地址2.前++，先++操作，可以是++地址或者值，(++符号靠近p就是地址++，靠近*P就是值++)，再把值给别人*++p 地址发生改变，先把地址++，再把地址变化后的里面的值给别人++*p 地址不发生变化，*P的值++之后再赋值给别人注意:指针++,到底加几个字节要根据指针指向的类型决定，指针在32系统中永远是4个字节举例子：Int * a;//假设指针指向的地址0a++;//此时指针指向后移4个字节，即指向4Char *b;//假设指针指向的地址0b++；//此时指针指向后移1个字节，即指向1 12345// sizeof(数组名)和sizeof(&amp;数组)int Num[100];printf(&quot;%ld &quot;,sizeof(Num));//400printf(&quot;%ld &quot;,sizeof(&amp;Num));//8起始就是打印int *指针大小printf(&quot;%ld &quot;,sizeof(int *));//8 指针数组 12345// 首先是个数组，这个数组里的元素是指针int *p [4];int a[4]=&#123;1,2,3,4&#125;;p[0]=&amp;a[0];printf(&quot;%d &quot;,*p[0]); 123456789// 首先是个指针，这个指针指向数组例如：Int (*p) [4];//表示一个指向有4个int 元素的数组的指针，所以p+1，加的是4个intint num[8] =&#123;1,2,3,4,5,6,7,8&#125;;int (*p)[4] ;p = num;printf(&quot;%d &quot;,sizeof(p));//8 因为p是指针，64位系统8个字节printf(&quot;%p &quot;,p);//0x7ffe11d8a4e0 printf(&quot;%p &quot;,p+1);//0x7ffe11d8a4f0 //加的是指针指向的类型大小，这里指针指向的是有四个4int元素的数组，所以加的是16个字节 12345// 双指针int b[12] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;int (*p)[4];p = b;printf(&quot;%d &quot;, **(++p)); // 5 指针函数 1234// 函数的返回值是个指针类型int * fun(int x,int y)&#123; &#125; 函数指针 12345int (*pf)(float);// 函数指针调用函数事注意以下几点：1.\t函数类型必须和函数指针的类型一样，比如参数类型，返回值2.\t给函数指针赋值是可以&amp;也可以不要 指针和数组的区别 数据类型: 指针是一种数据类型，用于存储内存地址。指针可以指向不同数据类型的内存位置。 数组是一种数据结构，用于存储相同数据类型的一组连续内存单元。 大小: 指针的大小通常与系统架构相关，它存储一个内存地址，因此大小在不同系统上可能会有所不同。 数组的大小是由其包含的元素数量决定，每个元素的大小也是相同的。 初始化和赋值: 指针需要显式初始化为一个有效的内存地址，可以通过将其设置为某个变量的地址来初始化。 数组在声明时需要指定大小，而且在创建时会自动初始化，可以直接为数组元素赋值。 地址运算: 指针允许进行地址运算，例如指针加法或减法，以访问内存中的相邻位置。 数组的元素在内存中是连续存储的，因此可以通过索引来访问不同的元素。 传递给函数: 指针可以用于将变量的地址传递给函数，以便在函数内部修改变量的值。 数组在传递给函数时通常会退化为指针，因此函数接收到的是指向数组第一个元素的指针。 动态内存分配: 指针可用于动态内存分配，例如使用 malloc 或 new 来分配内存，然后通过指针访问分配的内存。 数组的大小通常在编译时确定，但C99标准引入了可变长度数组（VLA），允许在运行时指定数组大小。 指针和引用的区别 指针： 指针是一个变量，它存储另一个变量的内存地址。 指针可以为空（null），也可以重新分配给指向不同的变量。 指针需要使用解引用操作符 * 来访问所指向的值。 指针可以进行指针算术，如指针加法或减法。 指针可以指向不同类型的对象，但需要进行强制类型转换。 指针可能需要显式地管理内存，包括分配和释放内存。 引用： 引用是一个别名，它为已经存在的变量提供了另一个名称。 引用在创建时必须与现有变量绑定，无法改变绑定到不同的变量。 引用的语法更简洁，不需要解引用操作符，直接使用引用就可以访问所绑定的值。 引用不支持指针算术。 引用通常用于传递参数给函数，以便在函数内部修改参数的值。 引用不需要显式管理内存，不涉及内存分配和释放。 引用区别于指针的特性是 ： 不存在空引用（保证不操作空指针） 必须初始化（保证不是野指针） 一个引用永远指向他初始化的那个对象（保证指针值不变） 野指针 野指针：是指指针指向的地址是不确定的； 野指针（Dangling Pointer）通常是指指针变量存储了一个无效的内存地址，也就是它指向的内存区域可能已经被释放或不再有效。野指针的操作是不安全的，因为它们可能导致未定义的行为或程序崩溃。 野指针一般来说可以被重新赋值，但这并不会解决野指针的问题。重新赋值一个野指针只是改变了它的目标地址，但仍然可能会导致访问无效内存。在C和C++中，遵循以下最佳实践来处理野指针： 避免野指针：在使用指针前，确保它指向有效的内存区域。不要让指针指向已释放的内存或未分配的内存。 初始化指针：在声明指针时，始终将其初始化为NULL（C语言）或nullptr（C++语言）。这可以帮助你检测是否有野指针。 谨慎使用已释放的内存：如果确实要使用已释放的内存，确保在释放内存后不再访问它。 不要多次释放相同的内存：释放内存后，不要再次释放相同的内存块，否则会导致问题。 原因： 释放内存之后，指针没有及时置空 避免： 初始化置NULL 申请内存后判空 指针释放后置NULL 使用智能指针 12345int *p1 = NULL; //初始化置NULLp1 = (int *)calloc(n, sizeof(int)); //申请n个int内存空间同时初始化为0 assert(p1 != NULL); //判空，防错设计free(p1); p1 = NULL; //释放后置空 指针 &amp; const 1234const int* p; //常量指针-----&gt;指针指向的地址的内容不可以改变int const *p; //常量指针int * const p; // 指针常量--------&gt;指针指向的地址可以不改变const int * const p; //指向常量的常量指针 指针减指针 1234567891011121314// 地址相减 = （地址a -地址b）/sizeof（指针指向的类型）int a[3];a[0] = 0;a[1] = 1;a[2] = 2;int *p, *q;p = a;q = &amp;a[2];printf(&quot;%p &quot;,p);//0x7ffe80e38b0c printf(&quot;%p &quot;,q);//0x7ffe80e38b14 printf(&quot;%d &quot;,q-p);//2 ( q - p) /sizeof(int )// 那么就有a[q-p] = a[2] = 2 指针作为函数参数传递问题 1234567891011121314151617181920212223242526272829303132//函数1，交换两个数void swap1(int *p,int *q)&#123; int num = *p;\t*p =*q;\t*q = num;&#125;//函数2，让p指针指向a，想重新给p赋值为90，之后再交换p,qvoid swap(int *p,int *q)&#123; int a =90; p = &amp;a;\tint num = *p;\t*p =*q;\t*q = num;&#125;int main()&#123; int a =2,b =3; int * j = &amp;a; // 指针j指向a int * k =&amp;b; //指针 k 指向 b swap(j,k); //调用函数 printf(&quot;a =%d b= %d &quot;,a,b);// a = 2 b = 90; return 0;&#125;// 于函数swap1我们可以正常交换两个值，但是swap函数却不是我们想要的，我们想要的答案是 a = 3 b = 90;可是发现，a的值压根没变，这是为什么呢？// 在swap函数中，你将指针p指向了一个局部变量a，而这个局部变量在swap函数执行完毕后将被销毁。这会导致指针p指向一个不再有效的内存位置总结：如果在函数形参里的指针变量不修改指向，那么就会影响传递过来的指针 12345678910111213141516171819202122232425void fun(char *s) &#123; char a[10]; strcpy(a, &quot;STRING&quot;); s = a;//修改了形参指针指向，就不会影响传递过来指针&#125;void main() &#123; char *p = &quot;PROGRAM&quot;; fun(p); printf(&quot;%s &quot;, p); //PROGRAM&#125;// 拓展：通过二级指针操作void fun(char **s) &#123; char a[10]; strcpy(a, &quot;STRING&quot;); *s = a; // *s = &quot;string&quot;;&#125;int main() &#123; char *p = &quot;PROGRAM&quot;; fun(&amp;p); printf(&quot;%s &quot;, p); //打印空白 return 0;&#125;// 在这里我们通过把一级指针的地址传递给函数，函数二级形参来接受，那么*s表示的就是指针p指向的地址，可以看出这里直接就操作p的指针指向，所以如果 *s = “string”那么指针p就会指向”string”的地址 二维数组和数组指针 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int main()&#123; /*二维数组和数组指针*/ int (*p)[3]; int s[3][3]=&#123;1,4,7,4,9,6,2,7,9&#125;; p = s; printf(&quot;p addr is = %p &quot;,p);//0x7ffde8cdf0a0 printf(&quot;s addr is = %p &quot;,s);//0x7ffde8cdf0a0 /*可以发现p+1和s+1是一样的都是加一个一维数组*/ printf(&quot;p + 1 addr is = %p &quot;,p + 1);//0x7ffde8cdf0ac printf(&quot;s + 1 addr is = %p &quot;,s + 1);//0x7ffde8cdf0ac /*可以发现使用p表示二维数组的元素和二维数组名表示元素是一样的用法*/ printf(&quot;*(*(p + 1)) is = %d &quot;,*(*(p + 1)));//*(*(p + 1)) is = 4 printf(&quot;*(*(s + 1)) is = %d &quot;,*(*(s + 1)));//*(*(s + 1)) is = 4 printf(&quot;*(p[1]+0) is = %d &quot;,*(p[1]+0));//*(p[1]+0) is = 4 printf(&quot;*(s[1]+1) is = %d &quot;,*(s[1]+1));//*(s[1]+1) is = 9 return 0;&#125;// 一维数组：int num[2]; printf(&quot;%p &quot;,num); //0x7fffe2a8cde8printf(&quot;%p &quot;,num+1); //0x7fffe2a8cdec printf(&quot;%p &quot;,&amp;num+1); //0x7fffe2a8cdf0 // 可以看出：num +1 加的是一个Int&amp;num + 1加的是整个数组// 二维数组;int num[2][2];printf(&quot;%p &quot;,num); //0x7ffe18f73560 printf(&quot;%p &quot;,num+1); //0x7ffe18f73568 printf(&quot;%p &quot;,&amp;num+1); //0x7ffe18f73570 // 可以看出：num +1 加的是一个一维&amp;num + 1加的是整个数组 // 例子 int main() &#123; int num[2][3]=&#123;1,2,3,4,5,6&#125;; int (*p)[3]; p = num; printf(&quot;%p &quot;,p);//0x7ffffad71df0 printf(&quot;%p &quot;,p+1);//0x7ffffad71dfc printf(&quot;%p &quot;,num[0]+1);//0x7ffffad71df4 printf(&quot;%p &quot;,*p+1);//0x7ffffad71df4 // 注意这里&amp;p+1 printf(&quot;%p &quot;,&amp;num+1);//0x7ffffad71e08 printf(&quot;%d &quot;,**p);//1&#125;","tags":["C语言"]},{"title":"C语言-内存相关","path":"/2024/02/26/C语言-内存/","content":"C语言——内存相关内存分配方式栈内存分配（Stack Allocation） 栈内存是一种自动分配和释放的内存，用于存储局部变量和函数调用的上下文信息。 变量在函数内部声明时，存储在栈内存中。栈的特性是后进先出（LIFO），所以最后进入栈的变量会最先被释放。 1234void someFunction() &#123; int x; // 在栈上分配内存 // 函数执行完毕后，x 的内存会被自动释放&#125; 堆内存分配（Heap Allocation） 堆内存是一种动态分配和释放的内存，用于存储程序运行时需要动态分配的数据。 使用malloc()、calloc()、realloc() 等函数在堆上分配内存，并使用 free() 函数释放堆内存。 123int *ptr = (int *)malloc(sizeof(int)); // 在堆上分配内存// 使用完毕后，需要手动释放内存free(ptr); 全局变量和静态变量分配（Static and Global Variables） 全局变量和静态变量存储在静态存储区，它们在程序的整个生命周期内存在。 全局变量在所有函数之外声明，而静态变量在函数内部使用 static 关键字声明。 1234int globalVar; // 全局变量，在静态存储区分配内存void someFunction() &#123; static int staticVar; // 静态变量，在静态存储区分配内存&#125; 堆和栈的区别 生存周期: 栈：栈上的变量的生命周期通常局限于函数的执行期间。当函数返回时，栈上的局部变量会被销毁，内存被释放。 堆：堆上分配的内存的生命周期可以长于任何特定函数调用，通常由程序员来管理。内存只有在显式释放时才会被回收。 大小限制: 栈：栈的大小通常受限于编译器或操作系统的设置，较小。因此，栈适合存储相对较小的数据结构。 堆：堆的大小通常受系统内存的限制，可以分配较大的内存块，适合存储大型数据结构。 访问速度: 栈：栈上的内存访问速度较快，因为它是线性分配，且栈上的数据通常存储紧凑。 堆：堆上的内存访问速度较慢，因为它是动态分配的，数据可能分散存储在内存中。 分配方式: 栈：栈上的内存分配和释放是自动的，不需要程序员干预。 堆：堆上的内存需要程序员手动分配和释放，使用 malloc()、free() 等函数 栈在c语言中的作用 用来保存临时变量，临时变量包括函数参数，函数内部定义的临时变量 多线程编程的基础就是栈，每个线程多最少有自己的专属的栈，用来保存本线程运行时各个函数的临时变量 c++的内存管理在c++中虚拟内存分为代码段、数据段、bss段、堆、共享区、栈 代码段:包括只读存储去和文本区，其中只读存储区字符串常量，文本区存储程序的机械代码 数据段：全局变量、静态变量（全局、局部） BSS段：未初始化的全局变量和静态变量（全局、局部），以及所有被初始化为0的全局变量和静态变量 堆:调用new&#x2F;malloc申请的内存空间，地址由低地址向高地址扩张 栈：局部变量、函数的返回值，函数的参数，地址由高地址向低地址扩张 内存泄漏简单来说就是申请了内存，不使用之后并没有释放内存，或者说，指向申请的内存的指针突然又去指向别的地方，导致找不到申请的内存， 影响 随着程序运行时间越长，占用内存越多，最终用完内存，导致系统崩溃 减少内存泄漏 良好的编码习惯，使用内存分配的函数，一但使用完毕之后就要记得使用对应的函数是否掉 将分配的内存的指针以链表的形式自行管理，使用之后从链表中删除，程序结束时可以检查改链表 使用智能指针 字节对齐问题 对齐要求：计算机体系结构规定了数据类型的对齐要求，通常以字节为单位。例如，一个32位体系结构可能需要数据类型的存储地址是其大小的整数倍，比如4字节对齐或8字节对齐。 未对齐访问：如果数据没有按照对齐要求存储在内存中，访问该数据可能会导致性能损失或硬件要求，并可能导致错误。在这种情况下，需要将数据移动到字节对齐的地址进行访问。 常见就是求复合类型大小，比如结构体、联合体 C语言函数参数压栈顺序C语言中，函数参数的压栈顺序通常是从右到左，也就是从最后一个参数开始压栈，依次向前。这是因为C语言的调用约定是”cdecl”（C Declaration），按照这个约定，函数的调用者（调用函数的地方）会将参数从右到左依次推入栈中，然后调用函数。 举个例子，假设有一个如下所示的函数： 123int addNumbers(int a, int b, int c) &#123; return a + b + c;&#125; 如果在另一个函数中调用addNumbers函数，假设要计算addNumbers(1, 2, 3)，参数的压栈顺序是这样的： 首先，数字3（参数c）被推入栈中。 然后，数字2（参数b）被推入栈中。 最后，数字1（参数a）被推入栈中。 可能内存溢出的函数 strcat: strcat 用于将一个字符串附加到另一个字符串的末尾。 可能导致内存溢出，因为它不会检查目标字符串的容量，如果目标字符串不足以容纳被附加的内容，就会溢出。 改进方法：使用 strncat 函数，该函数接受一个额外参数，指定要附加的最大字符数，从而避免溢出。 strncat: strncat 具有改进版的 strcat，可以控制附加的字符数。 仍然需要小心，确保指定的字符数不会超过目标字符串的容量。 strcmp: strcmp 用于比较两个字符串是否相等。 不会导致内存溢出，但可能导致无限循环或错误，如果比较的字符串没有正确的终止符。 改进方法：使用 strncmp 函数，并始终确保比较的字符串以 null 结尾。 strcpy: strcpy 用于将一个字符串复制到另一个字符串。 可能导致内存溢出，因为它不会检查目标字符串的容量，如果目标字符串不足以容纳被复制的内容，就会溢出。 改进方法：使用 strncpy 函数，该函数接受一个额外参数，指定要复制的最大字符数，从而避免溢出。 内存申请函数123456// 申请堆内存void *malloc(size_t size); //申请size_t个字节内存void free(void *ptr); //释放内存，但是指针还是可以用void *calloc(size_t nmemb, size_t size); //申请nmemb快内存，每块size_t个字节void *realloc(void *ptr, size_t size);//申请内存，重新申请size_t字节内存，void *reallocarray(void *ptr, size_t nmemb, size_t size);","tags":["C语言"]}]