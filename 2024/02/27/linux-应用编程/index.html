
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.26.8" theme-name="Stellar" theme-version="1.26.8">
  
  <meta name="generator" content="Hexo 7.1.1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>linux应用编程 - Blog</title>

  
    <meta name="description" content="Linux应用编程Linux文件I&#x2F;O编程Linux系统中，I&#x2F;O的类型可以分为标准I&#x2F;O与文件I&#x2F;O。同时针对I&#x2F;O的操作模式，也实现了阻塞I&#x2F;O、非阻塞I&#x2F;O、多路复用I&#x2F;O以及异步I&#x2F;O，这四种典型的模型。 标准I&#x2F;O和文件I&#x2F;O是为了实现对文件读写而封装的两套不同的用户程序编程接口">
<meta property="og:type" content="article">
<meta property="og:title" content="linux应用编程">
<meta property="og:url" content="http://example.com/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="Linux应用编程Linux文件I&#x2F;O编程Linux系统中，I&#x2F;O的类型可以分为标准I&#x2F;O与文件I&#x2F;O。同时针对I&#x2F;O的操作模式，也实现了阻塞I&#x2F;O、非阻塞I&#x2F;O、多路复用I&#x2F;O以及异步I&#x2F;O，这四种典型的模型。 标准I&#x2F;O和文件I&#x2F;O是为了实现对文件读写而封装的两套不同的用户程序编程接口">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/7766f41fb2da79b707371d53018949ce.png">
<meta property="og:image" content="http://example.com/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/640">
<meta property="og:image" content="http://example.com/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/image-20220412160356559.png">
<meta property="og:image" content="http://example.com/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/image-20220412161048941.png">
<meta property="og:image" content="http://example.com/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/image-20220418165001235.png">
<meta property="og:image" content="http://example.com/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/image-20220418194715505.png">
<meta property="og:image" content="http://example.com/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/image-20220418194924696.png">
<meta property="og:image" content="http://example.com/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/image-20220412154827736.png">
<meta property="og:image" content="http://example.com/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/%E3%80%8Alinux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20220526104021506.png">
<meta property="og:image" content="http://example.com/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/%E3%80%8Alinux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20220525180744944.png">
<meta property="og:image" content="http://example.com/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/%E3%80%8Alinux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20220525180917647.png">
<meta property="og:image" content="http://example.com/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/%E3%80%8Alinux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20220527064608117.png">
<meta property="og:image" content="http://example.com/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/%E3%80%8Alinux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20220418221627496.png">
<meta property="og:image" content="http://example.com/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/%E3%80%8Alinux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20220413154609767.png">
<meta property="og:image" content="http://example.com/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/%E3%80%8Alinux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20220418224755021.png">
<meta property="og:image" content="http://example.com/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/%E3%80%8Alinux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20220418232511926.png">
<meta property="og:image" content="http://example.com/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/%E3%80%8Alinux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20220418235142742.png">
<meta property="og:image" content="http://example.com/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/%E3%80%8Alinux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20220419000555074.png">
<meta property="og:image" content="http://example.com/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/%E3%80%8Alinux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20220419001914154.png">
<meta property="og:image" content="http://example.com/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/%E3%80%8Alinux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20220419002212785.png">
<meta property="og:image" content="http://example.com/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/%E3%80%8Alinux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20220426113659898.png">
<meta property="og:image" content="http://example.com/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/%E3%80%8Alinux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20220426114303526.png">
<meta property="og:image" content="http://example.com/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/%E3%80%8Alinux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20220426114416221.png">
<meta property="og:image" content="http://example.com/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/%E3%80%8Alinux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/image-20220413204745198.png">
<meta property="article:published_time" content="2024-02-27T08:51:00.000Z">
<meta property="article:modified_time" content="2024-03-13T13:05:51.601Z">
<meta property="article:author" content="baimin">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/7766f41fb2da79b707371d53018949ce.png">
  
  
  
  <meta name="keywords" content="linux">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.26.8">

  
    <link rel="shortcut icon" href="https://www.bing.com/images/search?view=detailV2&ccid=NBTs1th0&id=8DD1BA6653D365AD9ED73A5DDABEB32BB98F5D43&thid=OIP.NBTs1th0_7FYxpGGQJ-IDAAAAA&mediaurl=https%3a%2f%2fimg.ixintu.com%2fdownload%2fjpg%2f202001%2f3fcd67ac5c089ae3a8f72fd2b3508c93.jpg!ys&exph=250&expw=250&q=%e5%8d%9a%e5%ae%a2icon&simid=607990421440448215&FORM=IRPRST&ck=1141C8513F997CB92989E285F56C3350&selectedIndex=22&itb=0">
  

  

  
  
</head>
<body>

<div class="l_body content tech" id="start" layout="post" ><aside class="l_left"><div class="sidebar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="{config.avatar}" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">Blog</div><div class="sub normal cap">Thousand的日常记录</div><div class="sub hover cap" style="opacity:0"> Thousand's Daily</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"><a class="nav-item" title="undefined" href="/" style="color:1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="undefined" href="/" style="color:1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="undefined" href="/" style="color:1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="undefined" href="/" style="color:1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a></nav>
</div>
<div class="widgets">

<widget class="widget-wrapper toc single" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E6%96%87%E4%BB%B6I-O%E7%BC%96%E7%A8%8B"><span class="toc-text">Linux文件I&#x2F;O编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">Linux文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">文件的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6"><span class="toc-text">目录文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E6%96%87%E4%BB%B6"><span class="toc-text">符号链接文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E8%AE%BE%E5%A4%87"><span class="toc-text">文件和设备</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="toc-text">系统调用说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#write%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">write系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#read%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">read系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#open%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">open系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#close%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">close系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ioctl%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">ioctl系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">其他系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lseek%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">lseek系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fstat%E3%80%81stat%E5%92%8Clstat%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">fstat、stat和lstat系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dup%E5%92%8Cdup2%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">dup和dup2系统调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%B4%E6%8A%A4%E7%9B%B8%E5%85%B3%E8%B0%83%E7%94%A8"><span class="toc-text">文件维护相关调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#chmod%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">chmod系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chown%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">chown系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unlink%E3%80%81link%E5%92%8Csymlink%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">unlink、link和symlink系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mkdir%E5%92%8Crmdir%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">mkdir和rmdir系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chdir%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8Cgetcwd%E5%87%BD%E6%95%B0"><span class="toc-text">chdir系统调用和getcwd函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E6%89%AB%E6%8F%8F%E7%9B%B8%E5%85%B3%E8%B0%83%E7%94%A8"><span class="toc-text">目录扫描相关调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#opendir%E5%87%BD%E6%95%B0"><span class="toc-text">opendir函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readdir%E5%87%BD%E6%95%B0"><span class="toc-text">readdir函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#telldir%E5%87%BD%E6%95%B0"><span class="toc-text">telldir函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#seekdir%E5%87%BD%E6%95%B0"><span class="toc-text">seekdir函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#closedir%E5%87%BD%E6%95%B0"><span class="toc-text">closedir函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E8%B0%83%E7%94%A8"><span class="toc-text">错误处理调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#strerror%E5%87%BD%E6%95%B0"><span class="toc-text">strerror函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#perror%E5%87%BD%E6%95%B0"><span class="toc-text">perror函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98%EF%BC%9Afcntl%E5%92%8Cmmap"><span class="toc-text">高级主题：fcntl和mmap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fcntl%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">fcntl系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap%E5%87%BD%E6%95%B0"><span class="toc-text">mmap函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proc%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">&#x2F;proc文件系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E6%A0%87%E5%87%86I-O%E7%BC%96%E7%A8%8B"><span class="toc-text">Linux标准I&#x2F;O编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86I-O%E5%BA%93%E6%A6%82%E8%BF%B0"><span class="toc-text">标准I&#x2F;O库概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fopen%E5%87%BD%E6%95%B0"><span class="toc-text">fopen函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fread%E5%87%BD%E6%95%B0"><span class="toc-text">fread函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fwrite%E5%87%BD%E6%95%B0"><span class="toc-text">fwrite函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fclose%E5%87%BD%E6%95%B0"><span class="toc-text">fclose函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fflush%E5%87%BD%E6%95%B0"><span class="toc-text">fflush函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fseek%E5%87%BD%E6%95%B0"><span class="toc-text">fseek函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fgetc%E3%80%81getc%E5%92%8Cgetchar%E5%87%BD%E6%95%B0"><span class="toc-text">fgetc、getc和getchar函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fputc%E3%80%81putc%E5%92%8Cputchar%E5%87%BD%E6%95%B0"><span class="toc-text">fputc、putc和putchar函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fgets%E5%92%8Cgets%E5%87%BD%E6%95%B0"><span class="toc-text">fgets和gets函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#printf%E3%80%81fprintf%E5%92%8Csprintf%E5%87%BD%E6%95%B0"><span class="toc-text">printf、fprintf和sprintf函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#scanf%E3%80%81fscanf%E5%92%8Csscanf%E5%87%BD%E6%95%B0"><span class="toc-text">scanf、fscanf和sscanf函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%B5%81%E5%87%BD%E6%95%B0"><span class="toc-text">其他流函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%B5%81%E9%94%99%E8%AF%AF"><span class="toc-text">文件流错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%B5%81%E5%92%8C%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-text">文件流和文件描述符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-text">Linux 进程编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">进程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pipe%E7%AE%A1%E9%81%93"><span class="toc-text">pipe管道</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E4%BD%BF%E7%94%A8"><span class="toc-text">管道使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%AE%A1%E9%81%93%EF%BC%9AFIFOs"><span class="toc-text">先进先出管道：FIFOs</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-text">信号</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-text">发送信号</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IPC%E6%9C%BA%E5%88%B6%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E3%80%81%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%92%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">IPC机制：信号量、共享内存和消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-text">共享内存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">消息队列</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#socket%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-text">socket套接字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C"><span class="toc-text">套接字创建与运行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AF"><span class="toc-text">网络信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%A0%E7%89%B9%E7%BD%91%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-text">因特网守护进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%89%E9%A1%B9"><span class="toc-text">套接字选项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#select%E8%B0%83%E7%94%A8%E4%B8%8E%E5%A4%9A%E5%AE%A2%E6%88%B7"><span class="toc-text">select调用与多客户</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%B8%8EUDP"><span class="toc-text">数据报与UDP</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-text">Linux 多线程编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-tcp-ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">Linux tcp&#x2F;ip网络编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96"><span class="toc-text">Linux系统信息获取</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%8F%82%E6%95%B0"><span class="toc-text">程序参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#getopt%E5%87%BD%E6%95%B0"><span class="toc-text">getopt函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#getopt-long%E5%87%BD%E6%95%B0"><span class="toc-text">getopt_long函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">环境变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#putenv%E5%87%BD%E6%95%B0%E5%92%8Cgetenv%E5%87%BD%E6%95%B0"><span class="toc-text">putenv函数和getenv函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#environ%E5%8F%98%E9%87%8F"><span class="toc-text">environ变量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F"><span class="toc-text">时间和日期</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#time%E5%87%BD%E6%95%B0"><span class="toc-text">time函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#difftime%E5%87%BD%E6%95%B0"><span class="toc-text">difftime函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#gmtime%E5%87%BD%E6%95%B0"><span class="toc-text">gmtime函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#localtime%E5%87%BD%E6%95%B0"><span class="toc-text">localtime函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mktime%E5%87%BD%E6%95%B0"><span class="toc-text">mktime函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#astime%E5%92%8Cctime%E5%87%BD%E6%95%B0"><span class="toc-text">astime和ctime函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#strftime%E5%87%BD%E6%95%B0%E5%92%8Cstrptime%E5%87%BD%E6%95%B0"><span class="toc-text">strftime函数和strptime函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6"><span class="toc-text">临时文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#tmpna%E5%87%BD%E6%95%B0"><span class="toc-text">tmpna函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tmpfile%E5%87%BD%E6%95%B0"><span class="toc-text">tmpfile函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mktemp%E5%87%BD%E6%95%B0%E5%92%8Cmkstemp%E5%87%BD%E6%95%B0"><span class="toc-text">mktemp函数和mkstemp函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="toc-text">用户信息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#getuid%E5%92%8Cgetlogin%E5%87%BD%E6%95%B0"><span class="toc-text">getuid和getlogin函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#getpwuid%E5%92%8Cgetpwnam%E5%87%BD%E6%95%B0"><span class="toc-text">getpwuid和getpwnam函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#getpwent%E5%87%BD%E6%95%B0"><span class="toc-text">getpwent函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0"><span class="toc-text">其他函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF"><span class="toc-text">主机信息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#gethostname%E5%87%BD%E6%95%B0"><span class="toc-text">gethostname函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#uname%E5%87%BD%E6%95%B0"><span class="toc-text">uname函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-text">日志</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#syslog%E5%87%BD%E6%95%B0"><span class="toc-text">syslog函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0-1"><span class="toc-text">其他函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%92%8C%E9%99%90%E5%88%B6"><span class="toc-text">资源和限制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86"><span class="toc-text">Linux数据管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">内存分配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE"><span class="toc-text">内存释放</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%94%81%E5%AE%9A"><span class="toc-text">文件锁定</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%88%9B%E5%BB%BA%E9%94%81%E6%96%87%E4%BB%B6"><span class="toc-text">方法一：创建锁文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%8C%BA%E5%9F%9F%E9%94%81%E5%AE%9A"><span class="toc-text">方法二：区域锁定</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%94%81%E6%96%B9%E6%B3%95"><span class="toc-text">其他锁方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%81%E5%AE%9A%E7%8A%B6%E6%80%81%E4%B8%8B%E7%9A%84%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-text">锁定状态下的读写操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%94%81%E7%9A%84%E7%AB%9E%E4%BA%89"><span class="toc-text">文件锁的竞争</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-text">死锁</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="toc-text">开发工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#make%E5%92%8Cmakefile"><span class="toc-text">make和makefile</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#makefile%E8%AF%AD%E6%B3%95"><span class="toc-text">makefile语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#makefile%E6%B3%A8%E9%87%8A"><span class="toc-text">makefile注释</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#makefile%E7%9A%84%E5%AE%8F"><span class="toc-text">makefile的宏</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6"><span class="toc-text">多个目标文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E8%A7%84%E5%88%99"><span class="toc-text">内置规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E5%92%8C%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%99"><span class="toc-text">后缀和模式规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8make%E7%AE%A1%E7%90%86%E5%87%BD%E6%95%B0%E5%BA%93"><span class="toc-text">用make管理函数库</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#makefile%E6%96%87%E4%BB%B6%E5%92%8C%E5%AD%90%E7%9B%AE%E5%BD%95"><span class="toc-text">makefile文件和子目录</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#GNU-make%E5%92%8Cgcc"><span class="toc-text">GNU make和gcc</span></a></li></ol></li></ol></li></ol></li></ol></div></div></widget>







<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/"><span class="title">linux-全志V3s移植uboot kernel rootfile记录</span></a><a class="item title" href="/2024/03/12/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"><span class="title">ARM体系结构</span></a><a class="item title active" href="/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/"><span class="title">linux应用编程</span><svg class="active-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M21 11.098v4.993c0 3.096 0 4.645-.734 5.321c-.35.323-.792.526-1.263.58c-.987.113-2.14-.907-4.445-2.946c-1.02-.901-1.529-1.352-2.118-1.47a2.225 2.225 0 0 0-.88 0c-.59.118-1.099.569-2.118 1.47c-2.305 2.039-3.458 3.059-4.445 2.945a2.238 2.238 0 0 1-1.263-.579C3 20.736 3 19.188 3 16.091v-4.994C3 6.81 3 4.666 4.318 3.333C5.636 2 7.758 2 12 2c4.243 0 6.364 0 7.682 1.332C21 4.665 21 6.81 21 11.098" opacity=".5"/><path fill="currentColor" d="M9 5.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5z"/></svg></a><a class="item title" href="/2024/02/26/linux-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"><span class="title">linux-基础命令使用</span></a><a class="item title" href="/2024/03/11/cpp-%E5%B8%B8%E7%94%A8STL%E8%AE%B0%E5%BD%95/"><span class="title">cpp常用STL记录</span></a><a class="item title" href="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="title">数据结构与算法</span></a><a class="item title" href="/2024/03/08/C%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"><span class="title">C语言基础</span></a><a class="item title" href="/2024/03/03/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E4%BC%A0%E7%BB%9F%E5%88%86%E5%89%B2%E6%96%B9%E6%B3%95/"><span class="title">数字图像传统分割方法</span></a><a class="item title" href="/2024/03/02/%E4%BB%A3%E7%A0%81%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"><span class="title">代码命名规范</span></a><a class="item title" href="/2024/02/27/Visual-Studio%E7%9A%84%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E8%A7%A3%E9%87%8A/"><span class="title">Visual Studio的属性配置解释</span></a></div></widget>
</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/social/08a41b181ce68.svg"/></a><a class="social" href="https://" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/social/3845874.svg"/></a><a class="social" href="https://" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/social/3616429.svg"/></a><a class="social" href="https://" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/social/942ebbf1a4b91.svg"/></a></div></footer>
</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    
<div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2024-02-27T08:51:00.000Z">2024-02-27</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2024-03-13T13:05:51.601Z">2024-03-13</time></span></div></div>
</div>

    
    <div class="bottom">
      <div class="text-area">
        <h1 class="text title"><span>linux应用编程</span></h1>
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><h1 id="Linux应用编程"><a href="#Linux应用编程" class="headerlink" title="Linux应用编程"></a>Linux应用编程</h1><h2 id="Linux文件I-O编程"><a href="#Linux文件I-O编程" class="headerlink" title="Linux文件I&#x2F;O编程"></a>Linux文件I&#x2F;O编程</h2><p>Linux系统中，I&#x2F;O的类型可以分为标准I&#x2F;O与文件I&#x2F;O。同时针对I&#x2F;O的操作模式，也实现了阻塞I&#x2F;O、非阻塞I&#x2F;O、多路复用I&#x2F;O以及异步I&#x2F;O，这四种典型的模型。</p>
<p>标准I&#x2F;O和文件I&#x2F;O是为了实现对文件读写而封装的两套不同的用户程序编程接口，<strong>文件I&#x2F;O</strong>采用直接系统调用的方式实现对文件的读写；<strong>标准I&#x2F;O</strong>采用间接系统调用（库函数）的方式实现对文件的读写。</p>
<style>.giqimdpakodx{zoom: 50%;}</style><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/7766f41fb2da79b707371d53018949ce.png" class="giqimdpakodx lazy" alt="Linux 编程基础1--文件IO和标准IO、系统调用与库函数_标准 i&#x2F;o 库函数 和 文件i&#x2F;o 系统调用-CSDN博客">

<h3 id="Linux文件结构"><a href="#Linux文件结构" class="headerlink" title="Linux文件结构"></a>Linux文件结构</h3><p>在Linux中，一切都是文件。通常程序可以像使用文件那样使用磁盘文件、串行口、打印机和其他设备。大多数情况下，只需要使用5个基本的函数——open、close、read、write和ioctl。</p>
<p>文件，除了本身包含的内容以外，还有名字和一些属性，即”管理信息“，包括文件的创建、修改日期和访问权限。这些属性被保存在文件的inode节点中，这是文件系统中的一个特殊的数据块，同时它还包含文件的长度和文件在磁盘上的存放位置。</p>
<h4 id="文件的类型"><a href="#文件的类型" class="headerlink" title="文件的类型"></a>文件的类型</h4><p>（1）普通文件(regular file)。这种文件是最常见的文件类型，其数据形式可以是文本或二进制数据。</p>
<p>（2）目录文件(directory file)。这种文件包含其他类型文件的名字以及指向与这些文件有关的信息的指针。对一个目录文件具有读许可权的任一进程都可以读该目录文件的内容，但只有内核才有写目录文件的权限。</p>
<p>（3）字符设备文件(character special file)。这种文件被视为对字符设备的一种抽象，它代表的是应用程序对硬件设备的访问接口，Linux应用程序通过对该文件进行操作来实现对设备的访问。</p>
<p>（4）块设备文件(block special file)。这种文件类似于字符设备文件，只是它用于磁盘设备。Linux系统中的所有设备或者抽象为字符设备文件，或者为块设备文件。</p>
<p>（5）管道文件(pipe)。这种文件用于进程间的通信，有时也将其称为命名管道。</p>
<p>（6）套接字文件(socket)。这种文件用于进程间的网络通信，也可用于在一台宿主机上的进程之间的本地通信。</p>
<p>（7）符号链接文件(symbolic link)。这种文件指向另一个文件。</p>
<table>
<thead>
<tr>
<th>字符类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>b</td>
<td>块设备文件</td>
</tr>
<tr>
<td>c</td>
<td>字符设备文件</td>
</tr>
<tr>
<td>d</td>
<td>目录</td>
</tr>
<tr>
<td>-</td>
<td>普通文件</td>
</tr>
<tr>
<td>l</td>
<td>链接文件</td>
</tr>
<tr>
<td>s</td>
<td>套接字文件</td>
</tr>
<tr>
<td>p</td>
<td>管道文件</td>
</tr>
</tbody></table>
<p>在以上7种文件类型中，字符设备文件和块设备文件一般在学习linux驱动中使用，管道文件一般在进程通信中使用，套接字文件一般在Linux网络编程中使用，故这里暂时只对<u>目录文件和符号链接文件</u>进行说明。</p>
<h4 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h4><p>目录也是文件，它是一种特殊类型的文件。不过在现代的Linux中，即使是超级用户可能也不再被允许直接对目录进行写操作了。</p>
<p>目录是用于保存其他文件的节点号和名字的文件。目录文件中的每个数据项都是指向某个文件节点的链接，删除文件名就等于删除与之对应的链接。文件的节点号可以通过ln -i命令查看，也可以通过使用ln命令在不同的目录中创建指向同一个文件的链接。</p>
<p><code>删除目录中的一个文件，实质是删除该文件所对应的目录项，此时指向该文件的链接数减1。但是，该文件中的数据可能仍然能够通过其他指向该文件的链接访问到。如果，指向该文件的链接数变为0（比如使用ls -l命令后，输出内容中访问权限后面的那个数字），就表示该节点以及其指向的数据不再被使用，磁盘上的相应位置的存储空间会被标记为可用空间。</code></p>
<p>目录中包含文件，也包含子目录，这构成了文件系统的层次结构。根目录&#x2F;位于目录层次最顶端，下面的各级目录例如&#x2F;bin、&#x2F;etc、&#x2F;lib等子目录包含着系统中的所有文件。对于现实中的硬件设备，Linux文件系统为这些设备提供接口的文件一般放在&#x2F;dev子目录中。</p>
<style>.vgjtmtbejqtt{zoom: 50%;}</style><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/640" class="vgjtmtbejqtt lazy" alt="图片">

<h4 id="符号链接文件"><a href="#符号链接文件" class="headerlink" title="符号链接文件"></a>符号链接文件</h4><p>符号链接文件类似于Windows系统的快捷方式，只保留目标文件的地址，而不用占用存储空间。使用链接文件和使用目标文件的效果是一样的。符号链接文件指定不同的访问权限，以控制对文件的共享和保证安全性。</p>
<p>Linux中有两种类型的链接：硬链接和软链接。</p>
<p>硬链接是利用Linux系统中为每个文件分配的物理编号i节点建立链接。因此，硬链接不能跨越文件系统。硬链接的文件属性基本与源文件是基本一致的，可以进行同步更新。这种方式类似于Windows系统中将文件复制一份。</p>
<p>软链接是利用文件的路径名建立链接。通常建立软链接使用绝对路径而不是相对路径，以最大限度保证可移植性。软链接更像是Windows中创建快捷方式。软链接权限不会改变源文件（目标文件）的权限。</p>
<p>硬链接和软链接的不同之处在于：源文件删除后，软链接无法定位到源文件，所以会显示没有文件；硬链接类似于复制，删除源文件，硬链接依然可以访问。假如删除源文件后，重新创建一个同名文件，软链接将恢复；硬链接则不再有效。因为文件的i节点已经改变。</p>
<p>需要注意的是，修改硬链接的目标文件名，硬链接依然有效，软链接将断开；对一个已存在的链接文件执行移动或删除操作，有可能导致链接的断开。</p>
<h4 id="文件和设备"><a href="#文件和设备" class="headerlink" title="文件和设备"></a>文件和设备</h4><p>硬件设备在Linux中通常被映射为文件，比较重要的设备文件有3个：&#x2F;dev&#x2F;console、&#x2F;dev&#x2F;tty、&#x2F;dev&#x2F;null。</p>
<p>&#x2F;dev&#x2F;console：该设备是系统控制台，错误和诊断的信息通常会被发送到这个设备。每个UNIX系统都会有一个指定的终端或显示屏用来接收控制台消息。</p>
<p>&#x2F;dev&#x2F;tty：如果一个进程有控制终端，那么该设备文件就是这个终端（例如键盘、显示屏）的别名。若是系统自动运行的进程和脚本就没有控制终端，无法打开&#x2F;dev&#x2F;tty。</p>
<p>&#x2F;dev&#x2F;null：该文件是空设备文件，所有写向这个设备的输出都将被丢弃。若读该设备会立刻返回一个文件尾标志，在cp命令中可以利用它做复制空文件的源文件。常把不需要的输出重定向到&#x2F;dev&#x2F;null。</p>
<p>&#x2F;dev设备中的其他设备包括：硬盘软盘、通信端口、磁带驱动器、CD-ROM、声卡等设备的名字随系统的不同而不同，Linux发行版通常提供超级用户使用的应用程序，来管理普通用户无法访问的设备，例如挂载文件系统的mount命令。</p>
<p>设备被分为字符设备和块设备。两者区别在于访问设备时是否需要一次读写一整块。一般情况下，块设备是那些支持某些类型文件系统的设备，例如硬盘。</p>
<h3 id="系统调用说明"><a href="#系统调用说明" class="headerlink" title="系统调用说明"></a>系统调用说明</h3><p><strong>API</strong></p>
<p>应用程序接口API(Application Programming Interface) ，是程序员在用户空间下可以直接使用的函数接口，是一些预定义的函数，比如常用的read()、malloc()、free()、abs()函数等，这些函数都具有一定功能，说明了如何获得一个给定的服务，跟内核没有必然的联系。。</p>
<p><strong>系统调用</strong></p>
<p>操作系统负责管理和分配所有的计算机资源，为了更好地服务于应用程序，操作系统提供了一组特殊接口——系统调用接口层。系统调用接口层（System Call Iinterface，SCI）<u>介于应用层与内核层之间（系统调用接口层不属于内核层，但它是由内核函数实现的）</u>。为了安全考虑，应用程序不可以直接访问硬件资源。在单片机开发中，由于不需要操作系统，因此开发人员可以编写代码直接访问硬件；而在嵌入式系统中，通常需要操作系统，程序访问硬件资源的方式就发生了改变。</p>
<p>系统调用：使用少量的函数对文件和设备进行访问和控制。系统调用执行的流程如下：</p>
<p>（1）应用程序代码调用封装的func()函数，该函数是一个包装的系统调用的函数。</p>
<p>（2）func()函数负责准备向内核传递参数，并触发软中断int 0x80切换到内核。</p>
<p>（3）CPU被软中断打断后，执行中断处理函数，即系统调用处理函数（system_call）。</p>
<p>（4）system_call调用系统调用服务例程（sys_func），真正开始处理该系统调用。</p>
<p><strong>区别</strong></p>
<p>api是函数的定义，规定了这个函数的功能，跟内核无直接关系。而系统调用是通过中断向内核发请求，实现内核提供的某些服务。</p>
<p>程序员调用的是API（API函数），然后通过与系统调用共同完成函数的功能。 因此，API是一个提供给应用程序的接口，一组函数，是与程序员进行直接交互的。系统调用则不与程序员进行交互的，它是根据API函数，通过一个软中断机制向内核提交请求，以获取内核服务的接口。</p>
<h3 id="write系统调用"><a href="#write系统调用" class="headerlink" title="write系统调用"></a>write系统调用</h3><p>系统调用write的作用是把缓冲区buf的前nbytes个字节写入与文件描述符fildes关联的文件中。它返回实际写入的字节数。如果文件描述符有错或者底层的设备驱动程序对数据块长度比较敏感，该返回值可能会小于nbytes。如果这个函数返回0，就表示未写入任何数据：如果它返回的是-1，就表示在writei调用中出现了错误，错误代码保存在全局变量errno里。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">size t <span class="title function_">write</span><span class="params">(<span class="type">int</span> fildes, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((write(<span class="number">1</span>,<span class="string">&quot;Here is some data\n&quot;</span>,<span class="number">18</span>)) != <span class="number">18</span>)</span><br><span class="line">        write(<span class="number">2</span>,<span class="string">&quot;A write error has occurred on file descriptor 1\n&quot;</span>,<span class="number">46</span>);</span><br><span class="line">    <span class="built_in">exit</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<style>.oefwcqffckwy{zoom:67%;}</style><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/image-20220412160356559.png" class="oefwcqffckwy lazy" alt="image-20220412160356559">

<h3 id="read系统调用"><a href="#read系统调用" class="headerlink" title="read系统调用"></a>read系统调用</h3><p>系统调用read的作用是：从与文件描述符fildes相关联的文件里读入nbytes个字节的数据，并把它们放到数据区buf中。它返回实际读入的字节数，这可能会小于请求的字节数。如果read调用返回0，就表示未读入任何数据，己到达了文件尾。同样，如果返回的是-1，就表示read调用出现了错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fildes, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="open系统调用"><a href="#open系统调用" class="headerlink" title="open系统调用"></a>open系统调用</h3><p>简单地说，open建立了一条到文件或设备的访问路径。如果调用成功，它将返回一个可以被read、writ和其他系统调用使用的文件描述符。这个文件描述符是唯一的，它不会与任何其他运行中的进程共享。如果两个程序同时打开同一个文件，它们会分别得到两个不同的文件描述符。如果它们都对文件进行写操作，那么它们会各写各的，它们分别接着上次离开的位置继续往下写。它们的数据不会交织在一起，而是彼此互相覆盖。两个程序对文件的读写位置（偏移值）不同。可以通过使用文件锁功能来防止出现冲突，在后面会介绍该功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> oflags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> oflags, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"></span><br><span class="line">#严格来说，在遵循POSIX规范的系统上，使用open系统调用并不需要包括头文件sys/types.h和sys/stat.h，但在某些UNIX系统上，它们可能是必不可少的。</span><br></pre></td></tr></table></figure>

<p>of1ags参数是通过必需文件访问模式与其他可选模式相结合的方式来指定的，open调用必须指定表中所示的文件访问模式之一。</p>
<style>.lwvczetergdm{zoom:67%;}</style><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/image-20220412161048941.png" class="lwvczetergdm lazy" alt="image-20220412161048941">

<p>open调用还可以在oflags参数中包括下列可选模式的组合(用“按位或 | ”操作)。</p>
<ul>
<li><p>O_APPEND:把写入数据追加在文件的末尾。</p>
</li>
<li><p>O_TRUNC:把文件长度设置为零，丢弃已有的内容。</p>
</li>
<li><p>O_CREAT:如果需要，就按参数mode中给出的访问模式创建文件。</p>
</li>
<li><p>O_EXCL:与O_CREAT一起使用，确保调用者创建出文件。Open调用是一个原子操作，也就是说，它只执行一个函数调用。使用这个可选模式可以防止两个程序同时创建同一个文件。如果文件己经存在，open调用将失败。其他可以使用的oflags值请参考open调用的手册页。</p>
</li>
</ul>
<p>当使用带有O_CREAT标志的open调用来创建文件时，你必须使用有3个参数格式的open调用。第三个参数mode是几个标志按位或后得到的，这些标志在头文件sys&#x2F;stat.h.中定义，如下所示。</p>
<ul>
<li><p>S_IRUSR:读权限，文件属主。</p>
</li>
<li><p>S_IWUSR:写权限，文件属主。</p>
</li>
<li><p>S_IXUSR:执行权限，文件属主。</p>
</li>
<li><p>S_IRGRP:读权限，文件所属组。</p>
</li>
<li><p>S_IWGRP:写权限，文件所属组。</p>
</li>
<li><p>S_IXGRP:执行权限，文件所属组。</p>
</li>
<li><p>S_IROTH:读权限，其他用户。</p>
</li>
<li><p>S_IW0TH:写权限，其他用户。</p>
</li>
<li><p>S_IXOTH:执行权限，其他用户。</p>
</li>
</ul>
<p>看下面的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open (<span class="string">&quot;myfile&quot;</span>,O_CREAT,S_IRUSR|S_IXOTH);</span><br></pre></td></tr></table></figure>

<p><code>有几个因素会对文件的访问权限产生影响。首先，指定的访问权限只有在创建文件时才会使用；其次，用户掩码(由shell的umask命令设定)会影响到被创建文件的访问权限。open调用里给出的mode值将与当时的用户掩码的反值做AND操作。举例来说，如果用户掩码被设置为001，并且指定了SIOH模式标志，那么其他用户对创建的文件不会拥有执行权限，因为用户掩码中指定了不允许向其他用户提供执行权限。因此，open和creat调用中的标志实际上是发出设置文件访问权限的请求，所请求的权限是否会被设置取决于当时umask的值。</code></p>
<h3 id="close系统调用"><a href="#close系统调用" class="headerlink" title="close系统调用"></a>close系统调用</h3><p>你可以使用close调用终止文件描述符fildes与其对应文件之间的关联。文件描述符被释放并能够重新使用。close调用成功时返回0，出错时返回-1.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fildes)</span>;</span><br></pre></td></tr></table></figure>

<p>注意，检查close调用的返回结果非常重要。有的文件系统，特别是网络文件系统，可能不会在关闭文件之前报告文件写操作中出现的错误，这是因为在执行写操作时，数据可能未被确认写入。</p>
<h3 id="ioctl系统调用"><a href="#ioctl系统调用" class="headerlink" title="ioctl系统调用"></a>ioctl系统调用</h3><p>ioctl调用有点像是个大杂烩。它提供了一个用于控制设备及其描述符行为和配置底层服务的接口。原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fildes, <span class="type">int</span> cmd, ...)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="其他系统调用"><a href="#其他系统调用" class="headerlink" title="其他系统调用"></a>其他系统调用</h3><h4 id="lseek系统调用"><a href="#lseek系统调用" class="headerlink" title="lseek系统调用"></a>lseek系统调用</h4><p>lseek系统调用对文件描述符fildes的读写指针进行设置。也就是说，你可以用它来设置文件的下一个读写位置。读写指针既可被设置为文件中的某个绝对位置，也可以把它设置为相对于当前位置或文件尾的某个相对位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fildes, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>

<p>offset参数用来指定位置，而whence参数定义该偏移值的用法。whence可以取下列值之一。</p>
<ul>
<li>SEEK_SET: offset是一个绝对位置。</li>
<li>SEEK_CUR: offset是相对于当前位置的一个相对位置。</li>
<li>SEEK_END: offset是相对于文件尾的一个相对位置。</li>
</ul>
<p>lseek返回从文件头到文件指针被设置处的字节偏移值，失败时返回-1。参数offset的类型off_t是一个与具体实现有关的整数类型，它定义在头文件sys&#x2F;types.h中。</p>
<h4 id="fstat、stat和lstat系统调用"><a href="#fstat、stat和lstat系统调用" class="headerlink" title="fstat、stat和lstat系统调用"></a>fstat、stat和lstat系统调用</h4><p>fstat系统调用返回与打开的文件描述符相关的文件的状态信息，该信息将会写到一个buf结构中，buf的地址以参数形式传递给fstat。<br>下面是它们的原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fildes, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure>

<p><code>注意：包含头文件sys/types.h是可选的，但由于一些系统调用的定义针对那些某天可能会做出调整的标准类型使用了别名，所以但在程序中使用系统调用时，我们还是推荐将这个头文件包含进去。</code></p>
<p>相关函数stat和lstat返回的是通过文件名查到的状态信息。它们产生相同的结果，但当文件是一个符号链接时，lstat返回的是该符号链接本身的信息，而stat返回的是该链接指向的文件的信息。stat结构的成员在不同的类UNIX系统上会有所变化，但一般会包括表中所示的内容。</p>
<style>.tmxeutejtytu{zoom:67%;}</style><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/image-20220418165001235.png" class="tmxeutejtytu lazy" alt="image-20220418165001235">

<h4 id="dup和dup2系统调用"><a href="#dup和dup2系统调用" class="headerlink" title="dup和dup2系统调用"></a>dup和dup2系统调用</h4><p>dup系统调用提供了一种复制文件描述符的方法，使我们能够通过两个或者更多个不同的描述符来访问同一个文件。这可以用于在文件的不同位置对数据进行读写。dup系统调用复制文件描述符fildes，返回一个新的描述符。dup2系统调用则是通过明确指定目标描述符来把一个文件描述符复制为另外一个。<br>它们的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> fildes)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> fildes, <span class="type">int</span> fildes2)</span>;</span><br></pre></td></tr></table></figure>





<h3 id="文件维护相关调用"><a href="#文件维护相关调用" class="headerlink" title="文件维护相关调用"></a>文件维护相关调用</h3><h4 id="chmod系统调用"><a href="#chmod系统调用" class="headerlink" title="chmod系统调用"></a>chmod系统调用</h4><p>可以通过chmod系统调用来改变文件或目录的访问权限。这构成了shell程序chmod的基础。<br>该函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path,<span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p>path参数指定的文件被修改为具有mode参数给出的访问权限。参数mode的定义与open系统调用中的一样，也是对所要求的访问权限进行按位OR操作。除非程序被赋予适当的特权，否则只有文件的属主或超级用户可以修改它的权限。</p>
<h4 id="chown系统调用"><a href="#chown系统调用" class="headerlink" title="chown系统调用"></a>chown系统调用</h4><p>超级用户可以使用chown系统调用来改变一个文件的属主。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">uid_t</span> owner, gidt group)</span>;</span><br></pre></td></tr></table></figure>

<p>这个调用使用的是用户ID和组D的数字值(通过getuid和getgid调用获得)和一个用于限定谁可以修改文件属主的系统值。如果已经设置了适当的特权，文件的属主和所属组就会改变。</p>
<h4 id="unlink、link和symlink系统调用"><a href="#unlink、link和symlink系统调用" class="headerlink" title="unlink、link和symlink系统调用"></a>unlink、link和symlink系统调用</h4><p>可以使用unlink系统调用来删除一个文件。unlink系统调用删除一个文件的目录项并减少它的链接数。它在成功时返回0，失败时返回-1。如果想通过调用这个函数来成功别除文件，就必须拥有该文件所属目录的写和执行权限。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathl,<span class="type">const</span> <span class="type">char</span> *path2)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">symlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path1,<span class="type">const</span> <span class="type">char</span> *path2)</span>;</span><br></pre></td></tr></table></figure>

<p>如果一个文件的链接数减少到零，并且没有进程打开它，这个文件就会被别除。事实上，目录项总是被立刻删除，但文件所占用的空间要等到最后一个进程（如果有的话）关闭它之后才会被系统回收。程序使用的就是这个调用。文件上其他的链接表示这个文件还有其他名字，这通常是由ln程序创建的。你可以使用link系统调用在程序中创建一个文件的新链接。</p>
<h4 id="mkdir和rmdir系统调用"><a href="#mkdir和rmdir系统调用" class="headerlink" title="mkdir和rmdir系统调用"></a>mkdir和rmdir系统调用</h4><p>可以使用mkdir和rmdir系统调用来建立和删除目录。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path,<span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p>mkdir系统调用用于创建目录，它相当于mkdir程序。mkdir调用将参数path作为新建目录的名字。目录的权限由参数mode设定，其含义将按open系统调用的O_CREAT选项中的有关定义设置。当然，它还要服从umask的设置情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure>

<p>rmdir系统调用用于删除目录，但只有在目录为空时才行。rmdir程序就是用这个系统调用来完成工作的。</p>
<h4 id="chdir系统调用和getcwd函数"><a href="#chdir系统调用和getcwd函数" class="headerlink" title="chdir系统调用和getcwd函数"></a>chdir系统调用和getcwd函数</h4><p>程序可以像用户在文件系统里那样来浏览目录。就像你在shell里使用cd命令来切换目录一样，程序使用的是chdir系统调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure>

<p>程序可以通过调用getcwd函数来确定自己的当前工作目录。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *buf,<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>getcwd函数把当前目录的名字写到给定的缓冲区buf里。如果目录名的长度超出了参数size给出的缓冲区长度(一个ERANGE错误)，它就返回NULL。如果成功，它返回指针buf。</p>
<p><code>如果在程序运行过程中，目录被删除(EINVAL错误)或者有关权限发生了变化（EACCESS错误），getcwd也可能会返回NULL.</code></p>
<h3 id="目录扫描相关调用"><a href="#目录扫描相关调用" class="headerlink" title="目录扫描相关调用"></a>目录扫描相关调用</h3><p>Linux系统上一个常见问题就是扫描目录，也就是确定一个特定目录下存放的文件。在shell程序设计中，这很容易做到——只需让shell做一次表达式的通配符扩展。在过去，UNIX操作系统的各种变体都允许用户通过编程访问底层文件系统结构。你仍然可以把目录当作一个普通文件那样打开，并直接读取目录数据项，但不同的文件系统结构及其实现已经使这种方法没什么可移植性了。现在，一整套标准的库函数已经被开发出来，使得目录的扫描工作变得简单多了。</p>
<p>与目录操作有关的函数在dirent.h头文件中声明。它们使用一个名为DIR的结构作为目录操作的基础。被称为目录流的指向这个结构的指针(DIR*)被用来完成各种目录操作，其使用方法与用来操作普通文件的文件流(FILE*)非常相似。目录数据项本身则在dirent结构中返回，该结构也是在dirent.h头文件里声明的，这是因为用户不应直接改动DIR结构中的数据字段。</p>
<p>dirent结构中包含的目录项内容包括以下部分。</p>
<ul>
<li>ino_t dino: 文件的inode节点号。</li>
<li>char d_name[ ]: 文件的名字。</li>
</ul>
<p>下面将介绍下面这几个函数：</p>
<ul>
<li>opendir、closedir</li>
<li>readdir</li>
<li>telldir</li>
<li>seekdir</li>
<li>closedir</li>
</ul>
<h4 id="opendir函数"><a href="#opendir函数" class="headerlink" title="opendir函数"></a>opendir函数</h4><p>opendiri函数的作用是打开一个目录并建立一个目录流。如果成功，它返回一个指向DIR结构的指针，该指针用于读取目录数据项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>

<p>opendir在失败时返回一个空指针。注意，目录流使用一个底层文件描述符来访问目录本身，所以如果打开的文件过多，opendir可能会失败。</p>
<h4 id="readdir函数"><a href="#readdir函数" class="headerlink" title="readdir函数"></a>readdir函数</h4><p>readdir函数返回一个指针，该指针指向的结构里保存着目录流dirp中下一个目录项的有关资料。后续的readdir调用将返回后续的目录项。如果发生错误或者到达目录尾，readdir将返回NULL。POSIX兼容的系统在到达目录尾时会返回NULL,但并不改变erno的值，只有在发生错误时才会设置errno。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure>

<p>注意，如果在readdir函数扫描目录的同时还有其他进程在该目录里创建或删除文件，readdir将不保证能够列出该目录里的所有文件（和子目录）。</p>
<h4 id="telldir函数"><a href="#telldir函数" class="headerlink" title="telldir函数"></a>telldir函数</h4><p>telldir函数的返回值记录着一个目录流里的当前位置。你可以在随后的seekdir调用中利用这个值来重置目录扫描到当前位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">telldir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="seekdir函数"><a href="#seekdir函数" class="headerlink" title="seekdir函数"></a>seekdir函数</h4><p>seekdir函数的作用是设置目录流dirp的目录项指针。loc的值用来设置指针位置，它应该通过前一个telldir调用获得。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">seekdir</span><span class="params">(DIR *dirp, <span class="type">long</span> <span class="type">int</span> loc)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="closedir函数"><a href="#closedir函数" class="headerlink" title="closedir函数"></a>closedir函数</h4><p>closedir函数关闭一个目录流并释放与之关联的资源。它在执行成功时返同0，发生错误时返回-1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="错误处理调用"><a href="#错误处理调用" class="headerlink" title="错误处理调用"></a>错误处理调用</h3><p>前面介绍的许多系统调用和函数都会因为各种各样的原因而失败。它们会在失败时设置外部变量errno的值来指明失败的原因。许多不同的函数库都把这个变量用做报告错误的标准方法。值得重申的是，程序必须在函数报告出错之后立刻检查errno变量，因为它可能被下一个函数调用所覆盖，即使下一个函数自身并没有出错，也可能会覆盖这个变量。</p>
<p>错误代码的取值和含义都列在头文件errno.h里，如下所示。</p>
<ul>
<li>EPERM:操作不允许。</li>
<li>ENOENT:文件或目录不存在。</li>
<li>EINTR:系统调用被中断。</li>
<li>EIO:I&#x2F;O错误。</li>
<li>EBUSY:设备或资源忙。</li>
<li>EEXIST:文件存在。</li>
<li>EINVAL:无效参数。</li>
<li>EMFILE:打开的文件过多。</li>
<li>ENODEV:设备不存在。</li>
<li>EISDIR:是一个目录。</li>
<li>ENOTDIR:不是一个目录。</li>
</ul>
<p>有两个非常有用的函数可以用来报告出现的错误，它们是strerror和perror.</p>
<h4 id="strerror函数"><a href="#strerror函数" class="headerlink" title="strerror函数"></a>strerror函数</h4><p>strerror函数把错误代码映射为一个字符串，该字符串对发生的错误类型进行说明。这在记录错误条件时十分有用。</p>
<p>该函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strerror</span><span class="params">(<span class="type">int</span> errnum)</span>;</span><br></pre></td></tr></table></figure>

<p>它可能在标准错误输出中给出如下的输出结果：</p>
<p><code>program: Too many open files</code></p>
<h4 id="perror函数"><a href="#perror函数" class="headerlink" title="perror函数"></a>perror函数</h4><p>perror函数也把errno变量中报告的当前错误映射到一个字符串，并把它输出到标准错误输出流。该字符串的前面先加上字符串s（如果不为空）中给出的信息，再加上一个冒号和一个空格。</p>
<p>该函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="高级主题：fcntl和mmap"><a href="#高级主题：fcntl和mmap" class="headerlink" title="高级主题：fcntl和mmap"></a>高级主题：fcntl和mmap</h3><p>该部分较少使用。</p>
<h4 id="fcntl系统调用"><a href="#fcntl系统调用" class="headerlink" title="fcntl系统调用"></a>fcntl系统调用</h4><p>fcntl系统调用对底层文件描述符提供了更多的操纵方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fildes, <span class="type">int</span> cmd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fildes, <span class="type">int</span> cmd, <span class="type">long</span> arg)</span>;</span><br></pre></td></tr></table></figure>

<p>利用fcntl系统调用，你可以对打开的文件描述符执行各种操作，包括对它们进行复制、获取和设置文件描述符标志、获取和设置文件状态标志，以及管理建议性文件锁等。</p>
<p>对不同操作的选择是通过选取命令参数cmd不同的值来实现的，其取值定义在头文件fcntl.h中。根据所选择命令的不同，系统调用可能还需要第三个参数arg。</p>
<ul>
<li>fcntl(fildes, F_DUPFD, newfd): 这个调用返回一个新的文件描述符，其数值等于或大于整数newfd。新文件描述符是描述符fildes的一个副本。根据已打开文件数目和newfd值的情况，它的效果可能和系统调用dup(fildes)完全一样。</li>
<li>fcntl(fildes, F_GETFD): 这个调用返回在fcntl.h头文件里定义的文件描述符标志，其中包括FD_CLOEXEC，它的作用是决定是否在成功调用了某个exec系列的系统调用之后关闭该文件描述符。</li>
<li>fcntl(fildes, F_SETFD, flags): 这个调用用于设置文件描述符标志，通常仅用来设置FD_CLOEXEC。</li>
<li>fcntl(fildes, F_GETFL)和fcntl(fildes, F_SETFL, flags): 这两个调用分别用来获取和设置文件状态标志和访问模式。你可以利用在fcntl.h头文件中定义的掩码O_ACCMODE来提取出文件的访问模式。其他标志包括那些当open调用使用O_CREAT打开文件时作为第三参数出现的标志。注意，你不能设置所有的标志，特别是不能通过fcntl设置文件的权限。</li>
</ul>
<h4 id="mmap函数"><a href="#mmap函数" class="headerlink" title="mmap函数"></a>mmap函数</h4><p>UNX提供了一个有用的功能以允许程序共享内存，Liux内核从2.0版本开始已经把这一功能包括进来。map（内存映射）函数的作用是建立一段可以被两个或更多个程序读写的内存。一个程序对它所做出的修改可以被其他程序看见。</p>
<p>这要通过使用带特殊权限集的虚拟内存段来实现。对这类虚拟内存段的读写会使操作系统去读写磁盘文件中与之对应的部分。</p>
<p>mmap函数创建一个指向一段内存区域的指针，该内存区域与可以通过一个打开的文件描述符访问的文件的内容相关联。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fildes, <span class="type">off_t</span> off)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>通过传递off参数来改变经共享内存段访问的文件中数据的起始偏移值。</p>
</li>
<li><p>打开的文件描述符由fildes参数给出。</p>
</li>
<li><p>可以访问的数据量（即内存段的长度）由len参数设置。</p>
</li>
<li><p>你可以通过addr参数来请求使用某个特定的内存地址。如果它的取值是零，结果指针就将自动分配。这是推荐的做法，否则会降低程序的可移植性，因为不同系统上的可用地址范围是不一样的。</p>
</li>
<li><p>Prot参数用于设置内存段的访问权限。它是下列常数值的按位OR结果。</p>
<ul>
<li><p>PROT_READ: 允许读该内存段。</p>
</li>
<li><p>PROT_WRITE: 允许写该内存段。</p>
</li>
<li><p>PROT_EXEC: 允许执行该内存段。</p>
</li>
<li><p>PROT_NONE: 该内存段不能被访问。</p>
</li>
</ul>
</li>
<li><p>flags参数控制程序对该内存段的改变所造成的影响，可以使用的选项如下。</p>
<ul>
<li>MAP_PRIVATE: 内存段是私有的，对它的修改只对本进程有效。</li>
<li>MAP_SHARED: 把对该内存段的修改保存到磁盘文件中。</li>
<li>MAP_FIXED: 该内存段必须位于addr指定的地址处。</li>
</ul>
</li>
</ul>
<p><strong>msync函数</strong>的作用是：把在该内存段的某个部分或整段中的修改写回到被映射的文件中（或者从被映射文件里读出）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msync</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>内存段需要修改的部分由作为参数传递过来的起始地址addr和长度len确定。flags参数控制着执行修改的具体方式，可以使用的选项如下。</p>
<ul>
<li>MS_ASYNC: 采用异步写方式</li>
<li>MS_SYNC: 采用同步写方式</li>
<li>MS_INVALIDATE: 从文件中读回数据</li>
</ul>
<p><strong>munmap函数</strong>的作用是释放内存段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len)</span>;</span><br></pre></td></tr></table></figure>



<h3 id="proc文件系统"><a href="#proc文件系统" class="headerlink" title="&#x2F;proc文件系统"></a>&#x2F;proc文件系统</h3><p>Linux提供了一个特殊的文件系统procfs,它通常以&#x2F;proc目录的形式呈现。该目录中包含了许多特殊文件用来对驱动程序和内核信息进行更高层的访问。只要应用程序有正确的访问权限，它们就可以通过读写这些文件来获得信息或设置参数。</p>
<p>&#x2F;proc目录中的文件会随系统的不同而不同，当Linux&#x2F;版本中有更多的驱动程序和设施支持procfs文件系统时，该目录中就会包含更多的文件。在这里，将介绍一些&#x2F;proc目录中常用的文件，并简单讨论它们的用途。</p>
<style>.pwprnelhgere{zoom: 50%;}</style><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/image-20220418194715505.png" class="pwprnelhgere lazy" alt="image-20220418194715505">

<p>在多数情况下，只需直接读取这些文件就可以获得状态信息。</p>
<p>例如，&#x2F;proc&#x2F;cpuinfo给出的是cpu的详细信息：</p>
<style>.kiiidjfpchtl{zoom: 50%;}</style><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/image-20220418194924696.png" class="kiiidjfpchtl lazy" alt="image-20220418194924696">

<ul>
<li><p>类似地，&#x2F;proc&#x2F;meminfo和&#x2F;proc&#x2F;version分别给出的是内存使用情况和内核版本信息。</p>
</li>
<li><p>你可以通过特定内核函数获得更多的信息，它们位于&#x2F;proc目录的子目录中。例如，你可以通过&#x2F;proc&#x2F;net&#x2F;sockstat文件获得网络套接字的使用统计。</p>
</li>
<li><p>proc目录中的有些条目不仅可以被读取，而且可以被修改。例如，系统中所有运行的程序同时能打开的文件总数是Linux内核的一个参数。它的当前值可通过读取&#x2F;proc&#x2F;sys&#x2F;fs&#x2F;fi1e-max文件得到。</p>
</li>
<li><p>&#x2F;proc目录中以数字命名的子目录用于提供正在运行的程序的信息。</p>
</li>
</ul>
<h2 id="Linux标准I-O编程"><a href="#Linux标准I-O编程" class="headerlink" title="Linux标准I&#x2F;O编程"></a>Linux标准I&#x2F;O编程</h2><h3 id="标准I-O库概述"><a href="#标准I-O库概述" class="headerlink" title="标准I&#x2F;O库概述"></a>标准I&#x2F;O库概述</h3><p>针对输入输出操作直接使用底层系统调用的一个问题是它们的效率非常低：</p>
<ul>
<li><p>使用系统调用会影响系统的性能。与函数调用相比，系统调用的开销要大些，因为在执行系统调用时，Linux必须从运行用户代码切换到执行内核代码，然后再返回用户代码。减少这种开销的一个好方法是，在程序中尽量减少系统调用的次数，并且让每次系统调用完成尽可能多的工作。例如，每次读写大量的数据而不是每次仅读写一个字符。</p>
</li>
<li><p>硬件会限制对底层系统调用一次所能读写的数据块大小。</p>
</li>
</ul>
<p>为了给设备和磁盘文件提供更高层的接口，Linux发行版(和UNIX)提供了一系列的标准函数库。它们是一些由函数构成的集合，你可以把它们应用到自己的程序中，比如提供输出缓冲功能的标准&#x2F;O库。你可以高效地写任意长度的数据块，库函数则在数据满足数据块长度要求时安排执行底层系统调用。这就极大降低了系统调用的开销。</p>
<p>库函数有一个与之对应的标准头文件，例如与标准I&#x2F;O库对应的头文件是stdio.h。下图是对前面讨论的总结，它显示了Linux系统中各种文件函数与用户、设备驱动程序、内核和硬件之间的关系。</p>
<style>.sywrmhunayrh{zoom:67%;}</style><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/image-20220412154827736.png" class="sywrmhunayrh lazy" alt="image-20220412154827736">

<p>标准I&#x2F;O库(stdio)及其头文件stdio.h为底层I&#x2F;O系统调用提供了一个通用的接口。这个库现在已经成为ANSI标准C的一部分，而前面见到的系统调用却还不是。标准I&#x2F;O库提供了许多复杂的函数用于格式化输出和扫描输入。它还负责满足设备的缓冲需求。</p>
<p>在很多方面，你使用标准&#x2F;O库的方式和使用底层文件描述符一样。你需要先打开一个文件以建立一个访问路径。这个操作的返回值将作为其他I&#x2F;O库函数的参数。在标准I&#x2F;O库中，与底层文件描述符对应的是流(stream)，它被实现为指向结构FILE的指针。</p>
<p><code>注意，不要把这里的文件流与C++语言中的输入输出流(iostream)以及AT&amp;T UNIX System V Release3中引入的进程间通信中的STREAMS模型相混淆，STEAMS模型不在本书的讨论范围之内。要想进一步了解STREAMS,请查阅X/Open规范(http:/www.opengroup.org)和随System V)版本一起提供的AT&amp;T STREAMS Programming Guide(《AT&amp;T STREAMS程序设计指南》）。</code></p>
<p>在启动程序时，有3个文件流是自动打开的。它们是stdin、stdout和stderr。它们都是在stdio.h头文件里定义的，分别代表着标准输入、标准输出和标准错误输出，与底层文件描述符0、1和2相对应。</p>
<p>下面主要介绍标准&#x2F;O库中的下列库函数：</p>
<ul>
<li>fopen、fclose</li>
<li>fread、fwrite</li>
<li>fflush-</li>
<li>fseek-</li>
<li>fgetc、getc、getchar</li>
<li>fputc、putc、putchar</li>
<li>fgets、gets</li>
<li>printf、fprintf和sprintf</li>
<li>scanf、fscanf和sscanf</li>
</ul>
<h4 id="fopen函数"><a href="#fopen函数" class="headerlink" title="fopen函数"></a>fopen函数</h4><p>fopen库函数类似于底层的open系统调用。它主要用于文件和终端的输入输出。如果需要对设备进行明确的控制，那最好使用底层系统调用，因为这可以避免用库函数带来的一些潜在问题，如输入输出缓冲。</p>
<p>该函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br></pre></td></tr></table></figure>

<p>fopen:打开由filename参数指定的文件，并把它与一个文件流关联起来。mode参数指定文件的打开方式，它取下列字符串中的值。</p>
<ul>
<li>“r”或”rb”:以只读方式打开。</li>
<li>“w”或”wb”:以写方式打开，并把文件长度截短为零。</li>
<li>“a”或”ab”:以写方式打开，新内容追加在文件尾。</li>
<li>“r+”或”rb+”或”r+b”:以更新方式打开（读和写）。</li>
<li>“w+”或”wb+”或”w+b”:以更新方式打开，并把文件长度截短为零。</li>
<li>“a+”或”ab+”或”a+b”:以更新方式打开，新内容追加在文件尾。</li>
</ul>
<p><code>字母b表示文件是一个二进制文件而不是文本文件。</code></p>
<p><code>请注意，UNIX和Linux并不像MS-DOS那样区分文本文件和二进制文件。UNIX和Linux把所有文件都看作为二进制文件。另一个需要注意的地方是mode参数，它必须是一个字符串，而不是一个字符。所以总是应该使用双引号，而不是单引号。</code></p>
<p>fopen在成功时返回一个非空的FILE*指针，失败时返回ULL值，NULL值在头文件stdio.h里定义。可用的文件流数量和文件描述符一样，都是有限制的。实际的限制是由头文件stio.h中定义的FOPEN_MAX来定义的，它的值至少为8，在Linux系统中，通常是16。</p>
<h4 id="fread函数"><a href="#fread函数" class="headerlink" title="fread函数"></a>fread函数</h4><p>fread库函数用于从一个文件流里读取数据。数据从文件流stream读到由ptr指向的数据缓冲区里。fread和fwrite都是对数据记录进行操作，size参数指定每个数据记录的长度，计数器nitems给出要传输的记录个数。它的返回值是成功读到数据缓冲区里的记录个数（而<strong>不是字节数</strong>）。当到达文件尾时，它的返回值可能会小于nitems，甚至可以是零。</p>
<p>该函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nitems, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="fwrite函数"><a href="#fwrite函数" class="headerlink" title="fwrite函数"></a>fwrite函数</h4><p>fwrite库函数与fread有相似的接口。它从指定的数据缓冲区里取出数据记录，并把它们写到输出流中。它的返回值是成功写入的记录个数。</p>
<p>该函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span> <span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nitems, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p><code>注意，不推荐把fread和fwrite用于结构化数据。部分原因在于用fwrite写的文件在不同的计算机体系结构之间可能不具备可移植性。</code></p>
<h4 id="fclose函数"><a href="#fclose函数" class="headerlink" title="fclose函数"></a>fclose函数</h4><p>fclose库函数关闭指定的文件流stream,使所有尚未写出的数据都写出。因为stdio库会对数据进行缓冲，所以使用fclose是很重要的。如果程序需要确保数据已经全部写出，就应该调用fclose函数。虽然当程序正常结束时，会自动对所有还打开的文件流调用fcIose函数，但这样做就没有机会检查由fclose报告的错误了。</p>
<p>该函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="fflush函数"><a href="#fflush函数" class="headerlink" title="fflush函数"></a>fflush函数</h4><p>fflush库函数的作用是把文件流里的所有未写出数据立刻写出。例如，可以用这个函数来确保在试图读入一个用户响应之前，先向终端送出一个交互提示符。使用这个函数还可以确保在程序继续执行之前重要的数据都已经被写到磁盘上。有时在调试程序时，还可以用它来确认程序是正在写数据而不是被挂起了。注意，调用fclose函数隐含执行了一次flush操作，所以你不必在调用fclose之前调用fflush。</p>
<p>该函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fflush</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="fseek函数"><a href="#fseek函数" class="headerlink" title="fseek函数"></a>fseek函数</h4><p>fseek函数是与lseek系统调用对应的文件流函数。它在文件流里为下一次读写操作指定位置。offset和whence参数的含义和取值与前面的lseek系统调用完全一样。但lseek返回的是一个off_t数值，而fseek返回的是一个整数：0表示成功，-1表示失败并设置errno指出错误。</p>
<p>该函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> <span class="type">int</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="fgetc、getc和getchar函数"><a href="#fgetc、getc和getchar函数" class="headerlink" title="fgetc、getc和getchar函数"></a>fgetc、getc和getchar函数</h4><p>fgetc函数从文件流里取出下一个字节并把它作为一个字符返回。当它到达文件尾或出现错误时，它返回EOF，必须通过ferror或feof来区分这两种情况。</p>
<p>这些函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getc</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getchar</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>getc函数的作用和fgetc一样，但它有可能被实现为一个宏，如果是这样，stream参数就可能被计算不止一次，所以它不能有副作用(例如，它不能影响变量)。此外，你也不能保证能够使用getc的地址作为一个函数指针。getchar函数的作用相当于getc(stdin)，它从标准输入里读取下一个字符。</p>
<h4 id="fputc、putc和putchar函数"><a href="#fputc、putc和putchar函数" class="headerlink" title="fputc、putc和putchar函数"></a>fputc、putc和putchar函数</h4><p>futc函数把一个字符写到一个输出文件流中。它返回写入的值，如果失败，则返回EOF。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c,FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">putc</span><span class="params">(<span class="type">int</span> c,FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">putchar</span><span class="params">(<span class="type">int</span> c)</span>;</span><br></pre></td></tr></table></figure>

<p>类似于fgetc和getc之间的关系，putc函数的作用也相当于fputc,但它可能被实现为一个宏。putchar函数相当于putc(c,stdout)，它把单个字符写到标准输出。注意，putchar和getchar都是把字符当作int类型而不是char类型来使用的。这就允许文件尾(EOF)标识取值-1，这是一个超出字符数字编码范围的值。</p>
<h4 id="fgets和gets函数"><a href="#fgets和gets函数" class="headerlink" title="fgets和gets函数"></a>fgets和gets函数</h4><p>fgets函数从输入文件流stream里读取一个字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> n, FILE *stream)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure>

<p>fgets把读到的字符写到s指向的字符串里，直到出现下面某种情况：遇到换行符，己经传输了n-1个字符，或者到达文件尾。它会把遇到的换行符也传递到接收字符串里，再加上一个表示结尾的空字节\0。一次调用最多只能传输n-1个字符，因为它必须把空字节加上以结束字符串。</p>
<p>当成功完成时，fgets返回一个指向字符串s的指针。如果文件流己经到达文件尾，fgets会设置这个文件流的EOF标识并返回一个空指针。如果出现读错误，fgets返回一个空指针并设置errno以指出错误的类型。</p>
<p>gets函数类似于fgets,只不过它从标准输入读取数据并丢弃遇到的换行符。它在接收字符串的尾部加上一个null字节。</p>
<p><code>注意：gets对传输字符的个数并没有限制，所以它可能会溢出自己的传输缓冲区。因此，应该避免使用它并用fgets来代替。许多安全问题都可以追溯到在程序中使用了可能造成各种缓冲区溢出的函数，gets就是一个这样的函数，所以千万要小心！</code></p>
<h4 id="printf、fprintf和sprintf函数"><a href="#printf、fprintf和sprintf函数" class="headerlink" title="printf、fprintf和sprintf函数"></a>printf、fprintf和sprintf函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span> <span class="params">(<span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format,...)</span>;</span><br></pre></td></tr></table></figure>

<p>printf函数把自己的输出送到标准输出。fprintf函数把自己的输出送到一个指定的文件流。sprintf函数把自己的输出和一个结尾空字符写到作为参数传递过来的字符串s里。这个字符串必须足够容纳所有的输出数据。</p>
<p>普通字符在输出时不发生变化。转换控制符让printf取出传递过来的其他参数并对它们的格式过行编排。转换控制符总是以%字符开头。下面是一些常用的转换控制符。</p>
<ul>
<li>%d, %i: 以十进制格式输出一个整数。</li>
<li>%o, %x: 以八进制或十六进制格式输出一个整数。</li>
<li>%c: 输出一个字符。</li>
<li>%s: 输出一个字符串。</li>
<li>%f: 输出一个（单精度）浮点数。</li>
<li>%e: 以科学计数法格式输出一个双精度浮点数。</li>
<li>%g：以通用格式输出一个双精度浮点数。</li>
</ul>
<h4 id="scanf、fscanf和sscanf函数"><a href="#scanf、fscanf和sscanf函数" class="headerlink" title="scanf、fscanf和sscanf函数"></a>scanf、fscanf和sscanf函数</h4><p>scanf系列函数的工作方式与printf系列函数很相似，只是前者的作用是从一个文件流里读取数据，并把数据值放到以指针参数形式传递过来的地址处的变量中。它们也使用一个格式字符串来控制输入数据的转换，它所使用的许多转换控制符都与printf系列函数的一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *stream,<span class="type">const</span> <span class="type">char</span> *format,...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>scanf函数读入的值将保存到对应的变量里去，这些变量的类型必须正确，并且它们必须精确匹配格式字符串。否则，内存数据就可能会遭到破坏，从而使程序崩溃。编译器是不会对此做出错误提示的，但如果你运气够好，你可能会看到一个警告信息！</p>
<p>scanf系列函数的format格式字符串里同时包含着普通字符和转换控制符，就像printf函数中一样。但在scanf系列函数中，那些普通字符是用于指定在输入数据里必须出现的字符。</p>
<h4 id="其他流函数"><a href="#其他流函数" class="headerlink" title="其他流函数"></a>其他流函数</h4><p>stdio函数库里还有一些其他的函数使用流参数或标准流stdin、stdout和stderr,如下所示。</p>
<ul>
<li>fgetpos: 获得文件流的当前（读写）位置。</li>
<li>fsetpos: 设置文件流的当前（读写）位置。</li>
<li>ftell: 返回文件流当前（读写）位置的偏移值。</li>
<li>rewind: 重置文件流里的读写位置。</li>
<li>freopen: 重新使用一个文件流。</li>
<li>setvbuf: 设置文件流的缓冲机制。</li>
<li>remove: 相当于unlink函数，但如果它的path参数是一个目录的话，其作用就相当于rmdir函数。</li>
</ul>
<h4 id="文件流错误"><a href="#文件流错误" class="headerlink" title="文件流错误"></a>文件流错误</h4><p>为了表明错误，许多stdio库函数会返回一个超出范围的值，比如空指针或EOF常数。此时，错误由外部变量errno指出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> errno;</span><br></pre></td></tr></table></figure>

<p>注意，许多函数都可能改变errno的值。它的值只有在函数调用失败时才有意义。你必须在函数表明失败之后立刻对其进行检查。你应该总是在使用它之前将它先复制到另一个变量中，因为像fprintf这样的输出函数本身就可能改变errno的值。</p>
<p>你也可以通过检查文件流的状态来确定是否发生了错误，或者是否到达了文件尾。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ferror</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">clearerr</span><span class="params">(FILE *stream)</span></span><br></pre></td></tr></table></figure>

<p>ferror函数测试一个文件流的错误标识，如果该标识被设置就返回一个非零值，否则返回零。</p>
<p>feof函数测试一个文件流的文件尾标识，如果该标识被设置就返回非零值，否则返回零。我们可以像下面这样使用它：</p>
<p><code>if(feof (some_stream))</code></p>
<p>clearerr函数的作用是清除由stream指向的文件流的文件尾标识和错误标识。它没有返回值，也未定义任何错误。你可以通过使用它从文件流的错误状态中恢复。例如，在“磁盘己满”错误解决之后，继续开始写入文件流。</p>
<h4 id="文件流和文件描述符"><a href="#文件流和文件描述符" class="headerlink" title="文件流和文件描述符"></a>文件流和文件描述符</h4><p>每个文件流都和一个底层文件描述符相关联。你可以把底层的输入输出操作与高层的文件流操作混合使用，但一般来说，这并不是一个明智的做法，因为数据缓冲的后果难以预料。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fileno</span><span class="params">(FILE *stream)</span>;</span><br><span class="line">FILE *<span class="title function_">fdopen</span><span class="params">(<span class="type">int</span> fildes, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br></pre></td></tr></table></figure>

<p>你可以通过调用fileno函数来确定文件流使用的是哪个底层文件描述符。它返回指定文件流使用的文件描述符，如失败就返回-1。如果你需要对一个己经打开的文件流进行底层访问时（例如，对它调用fstat)，这个函数将很有用。</p>
<p>你可以通过调用fdopen函数在一个己打开的文件描述符上创建一个新的文件流。实质上，这个函数的作用是为一个已经打开的文件描述符提供stio缓冲区，这样解释可能更容易理解一些。</p>
<p>fdopen函数的操作方式与fopen函数是一样的，只是前者的参数不是一个文件名，而是一个底层的文件描述符。如果你已经通过open系统调用创建了一个文件（可能是出于为了更好地控制其访问权限的目的），但又想通过文件流来对它进行写操作，这个函数就很有用了。fdopen函数的mode参数与fopen函数的完全一样，但它必须符合该文件在最初打开时所设定的访问模式。fdopen返回一个新的文件流，失败时返回NULL。</p>
<h2 id="Linux-进程编程"><a href="#Linux-进程编程" class="headerlink" title="Linux 进程编程"></a>Linux 进程编程</h2><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>每种系统IPC进程间通信方式不十分一致，Linux综合了多个UNIX系统，主要有7种方式：</p>
<ul>
<li><p><del>file 文件</del></p>
</li>
<li><p>pipe 管道</p>
</li>
<li><p>singal 信号</p>
</li>
<li><p>System V IPC 机制</p>
<ul>
<li>semophore 信号量</li>
<li>semophore 共享内存</li>
<li>message queue 消息队列</li>
</ul>
</li>
<li><p>socket 套接字</p>
</li>
</ul>
<h4 id="pipe管道"><a href="#pipe管道" class="headerlink" title="pipe管道"></a>pipe管道</h4><p>当从一个进程连接数据流到另一个进程时，使用管道pipe。</p>
<p>例如shell中输入命令：<code>cmd1 | cmd2</code>，该命令经历以下过程：</p>
<ul>
<li>cmd1的标准输入来自终端键盘。</li>
<li>cmd1的标准输出传递给cmd2，作为它的标准输入。</li>
<li>cmd2的标准输出连接到终端屏幕。</li>
</ul>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="《linux程序设计》阅读笔记/image-20220526104021506.png" alt="image-20220526104021506" style="zoom:67%;" />

<h5 id="管道使用"><a href="#管道使用" class="headerlink" title="管道使用"></a>管道使用</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *<span class="title function_">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command, <span class="type">const</span> <span class="type">char</span> *open_mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pclose</span><span class="params">(FILE *stream_to_close)</span>;</span><br></pre></td></tr></table></figure>

<p><code>popen</code>函数允许一个程序将另外一个程序作为新进程来启动，他们之间可以传递数据。需要注意，一个管道只能单向传输信息，若想实现双向通信，需要使用两个管道。</p>
<ul>
<li>参数command为要运行的程序名和相应参数</li>
<li>参数open_mode取值为“r”时，调用popen的程序能够接收另外那个进程输出的数据，只需要使用标准I&#x2F;O库stdio中的函数（如fread函数）解析popen返回的FILE文件流即可；取值为“w”时，调用程序能够使用fwrite函数发送数据到另外那个进程，该进程可以从标准输入流中解析接收到的数据，一般来说进程并不知道接收到的数据是不是其他进程发送的，它只是简单地从标准输入流中接收并解析。</li>
</ul>
<p><code>pclose</code>函数负责关闭popen开启的文件流，并返回文件流关闭的退出码。pclose会一直等待popen完成后才执行，若调用程序在pclose执行前使用wait语句，那么退出状态会丢失，这时候返回-1，同时errno设置为ECHILD。</p>
<h5 id="先进先出管道：FIFOs"><a href="#先进先出管道：FIFOs" class="headerlink" title="先进先出管道：FIFOs"></a>先进先出管道：FIFOs</h5><p>为了在不相关的两个程序（即不是由共同祖先进程创建的）间进行数据传递，可以使用<code>FIFOs</code>，也称为命名管道<code>named pipes</code>。命名管道是一种特殊类型的文件（Linux中一切皆文件），在文件系统中有文件名，但行为和没有命名的管道类似。</p>
<p>可以使用命令行或者在程序中创建，命令行方法为输入<code>mkfifo filename</code>，在程序中创建方法如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syd/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mknod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">mode_t</span> mode | S_IFIFO, (<span class="type">dev_t</span>) <span class="number">0</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><code>mknod</code>函数能创建许多特殊类型的文件，但唯一具有可移植性的方法是使用一个dev_t类型的0值，并将访问模式与S_IFIFO按位“或”。</p>
<p><strong>1、使用open打开FIFO文件</strong></p>
<p>使用open打开FIFO文件的主要限制是不能以O_RDWR的模式，因为管道是单向使用的，同样若想双向传递数据，应该使用两个FIFO。</p>
<p>打开FIFO文件和普通文件的区别是open函数第二个参数open_flag的O_NONBLOCK。使用该模式不仅会改变open函数的调用方式，还会改变open根据返回的文件描述符进行的读写请求方式。4种合法的结合形式如下：</p>
<ul>
<li>open(const char *path, O_RDONLY);</li>
<li>open(const char *path, O_RDONLY | O_NONBLOCK);</li>
<li>open(const char *path, O_WRONLY);</li>
<li>open(const char *path, O_WRONLY | O_NONBLOCK);</li>
</ul>
<h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><p>信号是UNIX和Linux系统响应某些条件而产生的一个事件。接收到该信号的进程会相应地采取一些行动。我们用术语生成(raise)表示一个信号的产生，使用术语捕获(catch)表示接收到一个信号。信号是由于某些错误条件而生成的，如内存段冲突、浮点处理器错误或非法指令等。它们由shell和终端处理器生成来引起中断，它们还可以作为在进程间传递消息或修改行为的一种方式，明确地由一个进程发送给另一个进程。无论何种情况，它们的编程接口都是相同的。信号可以被生成、捕获、响应或（至少对于一些信号）忽略。</p>
<p>信号的名称是在头文件signal.h中定义的。它们以SIG开头，见表。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="《linux程序设计》阅读笔记/image-20220525180744944.png" alt="image-20220525180744944" style="zoom:67%;" />

<p><strong>如果进程接收到上面这些信号中的一个，但事先没有安排捕获它，进程将会立刻终止。</strong>通常，系统将生成核心转储文件core，并将其放在当前目录下。该文件是进程在内存中的映像，它对程序的调试很有用处。</p>
<p>其他信号：</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="《linux程序设计》阅读笔记/image-20220525180917647.png" alt="image-20220525180917647" style="zoom:67%;" />



<h5 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h5><p>进程可以通过调用<strong>kill函数</strong>向包括它本身在内的其他进程发送一个信号。如果程序没有发送该信号的权限，对kill函数的调用就将失败，失败的常见原因是目标进程由另一个用户所拥有。这个函数和同名的shell命令完成相同的功能，它的定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure>

<p>信号向我们提供了一个有用的闹钟功能。进程可以通过调用<strong>alam函数</strong>在经过预定时间后发送一个SIGALRM信号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>pause函数</strong>能将当前程序挂起直到有一个信号出现为止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>sigaction函数</strong>。上面的相关函数在传统的UNIX编程中较常见，而X&#x2F;Open和UNIX规范实现了更加强大的sigaction接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oact)</span>;</span><br></pre></td></tr></table></figure>

<p>sigaction结构至少包括以下成员：<code>void (*) (int) sa_handler</code>、<code>sigset_t sa_mask</code>、<code>int sa_flags</code>。sa_handler为函数指针，指向收到信号sig后将调用的信号处理函数；sa_mask为信号集，在调用sa_handler指向的函数前，会先将其加入到信号屏蔽字中，其包含了将被阻塞且不会传递给该进程的信号。</p>
<h4 id="IPC机制：信号量、共享内存和消息队列"><a href="#IPC机制：信号量、共享内存和消息队列" class="headerlink" title="IPC机制：信号量、共享内存和消息队列"></a>IPC机制：信号量、共享内存和消息队列</h4><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">semctl</span><span class="params">(<span class="type">int</span> sem_id, <span class="type">int</span> semm_num, <span class="type">int</span> command, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> num_sems, <span class="type">int</span> sem_flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">semop</span><span class="params">(<span class="type">int</span> sem_id, <span class="keyword">struct</span> sembuf *sem_ops, <span class="type">size_t</span> num_sem_ops)</span>;</span><br></pre></td></tr></table></figure>

<p><code>semget</code>函数用于创建一个新信号量或取得一个已有信号量的键。程序对所有信号量的访问都是间接的，它先提供一个信号量键，再由系统生成一个相应的信号量标识符。只有semget函数能直接使用信号量键，其他信号量函数都是使用semget函数返回的信号量标识符。参数key是信号量键，不相关的进程可以通过它访问同一个信号量；参数num_ssems指定需要的信号量数目，取值一般为1；参数sem_flags和open函数的标志相似。</p>
<p><code>semop</code>函数用于改变信号量的值。</p>
<ul>
<li>参数sem_id是semget返回的信号量标识符</li>
<li>参数sem_ops是指向一个结构数组的指针，该结构数组包含以下成员<code>struct sembuf&#123;short sem_num; short sem_op; short sem_flg;&#125;</code>。成员sem_num为信号量编号，除非需要使用一组信号量，否则取值一般为0；成员sem_op为一次操作需要改变的数值，通常用到-1和+1两个值，-1为p操作表示它等待信号量变为可用，+1为v操作，此时它发送信号表示信号量现在可用；成员sem_flg一般被设置为SEM_UNDO，操作系统将跟踪当前进程对这个信号量的修改情况，若进程在没有释放该信号量的情况下终止，操作系统将自动释放该进程持有的信号量。</li>
</ul>
<p><code>semctl</code>函数用来直接控制信号量信息。</p>
<ul>
<li>参数sem_id为semget返回的信号量标识符。</li>
<li>参数sem_num同上所述。</li>
<li>参数command表示将要采取的动作。它可以设置许多值，常用的有两个：SETVAL表示将信号量初始化为一个已知的值，该值通过union semun结构中的val成员设置；IPC_RMID表示删除一个已经无需继续使用的信号量标识符。</li>
<li>若还有第四个参数，它是union semun结构，至少包含成员：<code>union semum&#123;int val; struct semid_ds *buf; unsigned short *array&#125;</code></li>
</ul>
<h5 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h5><p>共享内存允许不相关的两个进程访问同一个逻辑内存。不过它未提供同步机制，在第一个进程结束对共享内存的写操作前，并无自动的机制可以阻止第二个进程对其进行读写。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="《linux程序设计》阅读笔记/image-20220527064608117.png" alt="image-20220527064608117" style="zoom:67%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#innclude sys/shm.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">const</span> <span class="type">void</span> *shm_addr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shm_addr)</span>;</span><br></pre></td></tr></table></figure>

<p><code>shmget</code>函数用来创建共享内存，其返回值为一个共享内存标识符，标识符用于后续共享内存的其他函数。参数key为共享内存段命名；参数size为以字节为单位指定需要共享的内存容量；参数shmflg包含9个比特权限标志。</p>
<p><code>shmat</code>函数，返回值为指向共享内存的地址指针。第一次创建共享内存段时，它不能被任何进程访问，要想对其访问，必须将其连接到一个进程的地址空间中，该工作由shmat函数完成。参数shm_id为shmget函数返回的标识符；参数shm_addr指定共享内存连接到当前进程中的地址位置，一般为空指针，由系统选择共享内存出现的地址；参数shmflg为一组位标志，两个可能的取值为SHM_RND（与shm_addr参数一起使用，用来控制共享内存连接的地址）和SHM_RDONLY（使连接的内存只读）。</p>
<p><code>shmdt</code>函数用来将共享内存从当前进程中分离，使得当前进程不可再使用该共享内存。参数为shmat函数返回的地址指针。</p>
<p><code>shmctl</code>函数对共享内存进行控制。</p>
<ul>
<li>参数shm_id为shmget返回的标识符；</li>
<li>参数command为采取的动作，取值分别为IPC_STAT、IPC_SET和IPC_RMID。</li>
<li>参数buf为shmid_ds结构的指针，该结构包含成员：<code>struct shmid_ds&#123;uid_t shm_perm.uid; uid_t shm_perm.gid; mode_t shm_perm.mode;&#125;</code></li>
</ul>
<h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><p>消息队列和命名管道FIFO有相似之处，但少了在打开和关闭管道方面的复杂性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msg_ptr, <span class="type">size_t</span> msg_sz, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msg_ptr, <span class="type">size_t</span> msg_sz, <span class="type">long</span> <span class="type">int</span> msgtype, <span class="type">int</span> msgflg)</span>;</span><br></pre></td></tr></table></figure>

<p><code>msgget</code>函数用来创建一个消息队列。参数key为消息队列键；参数msgflg为9个权限标志。</p>
<p><code>msgsnd</code>函数用来把消息加到消息队列中。消息的结构需要注意“长度必须小于系统规定的上限”和“必须以长整型成员变量开始”这两个限制，消息的结构定义为：<code>struct my_message &#123;long int message_type; /*data*/&#125;</code>。参数msqid为msgget函数返回的标识符；参数msg_ptr为指向待发送消息的指针，注意消息的结构以长整型开始；参数msg_sz为指向消息的长度，长度不能包含长整型消息类成员变量长度；参数msgflg控制在当前消息队列满或队列消息到达系统范围的限制时将要发生的事情。</p>
<p><code>msgrcv</code>函数用来从一个消息队列中获取消息。参数msqid、msg_ptr和msg_sz如上所述；参数msgtype可以实现一种简单形式的接收优先级，若值为0则获取队列中第一个可用消息，若值大于0则获取具有相同类型的第一个消息，若值小于0则获取消息类型等于或小于msgtype绝对值的第一个消息；参数msgflg用于控制当队列中没有相应类型的消息可接收时将发生的动作。</p>
<p><code>msgctl</code>函数。</p>
<h4 id="socket套接字"><a href="#socket套接字" class="headerlink" title="socket套接字"></a>socket套接字</h4><p>前面几种进程通信方式，只有在同一台机器上的进程才能使用。socket套接字是管道概念的一个扩展，可以使同一台机器上的不同进程进行通信，也可以使不同机器上的进程之间进行通信，所以套接字还包括了计算机网络中的通信。</p>
<h5 id="套接字创建与运行"><a href="#套接字创建与运行" class="headerlink" title="套接字创建与运行"></a>套接字创建与运行</h5><p><strong>1、套接字属性</strong></p>
<p>套接字三个属性：域(domiain)、类型(type)和协议(protocol)。套接字还用地址作为名字，地址格式随域（协议族protocol family）不同而不同，每个协议族又可以用一个或多个地址族定义地址格式。</p>
<p><strong>域</strong>。域指定套接字通信中使用的网络介质，常见的域为<strong>AF_INET</strong>（AF_INET6表示Ipv6），用于网络套接字，它指Internet网络，其底层协议——网际协议IP使用IP地址来指定网络中的计算机。IP地址表示因特网中的服务器计算机，IP端口表示机器上某个特定的服务，外部程序通过IP地址和端口号的组合进行服务访问（标准服务有标准端口号，可以不用协商好端口号）。域为<strong>AF_UNIX</strong>用于本地套接字，其底层协议是文件输入&#x2F;输出，地址为文件名。</p>
<p><strong>套接字类型</strong>。域可能有多种通信方式，每种方式也有其不同特性。域为AF_INET时，其底层因特网协议则提供了以下两种通信机制：**流(stream)<strong>和</strong>数据报(datagram)**。流套接字由类型SOCK_STREAM指定，其在AF_INET域中通过TCP&#x2F;IP连接实现，详情参考TCP协议；数据报套接字由类型SOCK_DGRAM指定，其在AF_INET域中通过UDP&#x2F;IP连接实现，对发送的数据报有长度限制，详情参考UDP协议。</p>
<p><strong>套接字协议</strong>。若底层传输机制允许不止一个协议来提供套接字类型，就可以为套接字选择一个特定的协议。一般对于网络套接字和文件系统套接字，默认即可。</p>
<p><strong>2、创建套接字</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure>

<p>socket函数调用返回一个描述符，描述符用于read和write调用进行数据发送和接收，而close用于关闭套接字连接；其参数如前面所述，通信所用协议一般由domain和type决定，protocol设置为0表示使用默认协议。</p>
<p><strong>3、套接字地址</strong></p>
<p>每个域有自己的地址格式。对于AF_UNIX域，地址由结构sockaddr_un描述，其定义在头文件“sys&#x2F;un.”h中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span>&#123;</span></span><br><span class="line">  <span class="type">sa_family_t</span> sun_family;	<span class="comment">//域</span></span><br><span class="line">  <span class="type">char</span> sun_path[];			<span class="comment">//路径名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于AF_INET域，地址由结构sockaddr_in指定，其定义在头文件“netinet.h”中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> sin_family;		<span class="comment">//域</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> sin_port;<span class="comment">//端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>	<span class="comment">//IP地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其中in_addr结构如下</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> s_addr;	<span class="comment">//4字节组成32位的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>4、命名套接字</strong></p>
<p>若让其他进程能够调用创建好的套接字，服务器程序需要给该套接字命名，这样AF_UNIX套接字会关联到一个文件系统的路径名，AF_INET套接字会关联到一个IP端口号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> socket, <span class="type">const</span> strcut sockaddr *address, <span class="type">size_t</span> address_len)</span>;</span><br></pre></td></tr></table></figure>

<p>参数socket为具体创建套接字的描述符；参数address使用通用地址类型(struct sockaddr *)，将上面介绍的两种具体地址类型进行转换，使地址与未命名的套接字进行绑定；参数address_len为地址结构的长度。</p>
<p><strong>5、创建套接字队列</strong></p>
<p>服务器程序须创建一个队列来保持未处理的连接请求，这使用listen系统调用完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> scoket, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure>

<p>参数backlog设置队列的长度，对未处理连接的数目进行限制，常用值为5。</p>
<p><strong>6、接受连接</strong></p>
<p>服务器程序创建并命名了套接字后，可以通过accept系统调用等待客户建立对该套接字的连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> socket, <span class="keyword">struct</span> sockaddr *address, <span class="type">size_t</span> *address_len)</span>;</span><br></pre></td></tr></table></figure>

<p>套接字必须先用<strong>bind</strong>命名，并用<strong>listen</strong>调用分配队列。连接的客户地址存放于address指向的结构中，若不关心客户地址，则address为空指针。</p>
<p>accept函数<u>将创建一个新套接字</u>来与客户进行通信，并返回新套接字的描述符，新套接字的类型和服务器监听套接字类型相同。若队列中没有未处理的连接，accept将阻塞（程序暂停）直到有客户建立连接为止。</p>
<p><strong>7、请求连接</strong></p>
<p>客户端通过connect调用，来将一个未命名的套接字和服务器的监听套接字进行连接，从而建立通信。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> socket, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *address, <span class="type">size_t</span> address_len)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>8、关闭套接字</strong></p>
<p>通过<strong>close</strong>函数来终止服务器和客户端上的套接字连接。</p>
<p><strong>9、字节序问题</strong></p>
<p>通过套接字接口传递的端口号和地址都是二进制数字，不同计算机使用不同的字节序来表示整数。例如，Intel处理器将32为整数分为4个连续的字节，并按照小端字节序（高字节高内存，低字节低内存），而IBM则相反使用大端字节序，若两个处理数据不同的计算机以逐个字节的方式来复制，那么得到的最终数值就会不一致。</p>
<p>为了使其通过网络传输的多字节整数的值一致，需要定义一个网络字节序，服务器和客户端都必须在传输之前将主机内部整数表示方式转换为网络字节序，这个通过以下函数完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">htonl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> hostlong)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title function_">htons</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> hostshort)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> netlong)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> netshort)</span>;</span><br></pre></td></tr></table></figure>

<p>以上函数将16位和32位整数进行字节序转换，函数名是相应操作的简写，例如htonl表示“host to network,long”，若主机字节序和网络字节序相同，则为空操作。</p>
<h5 id="网络信息"><a href="#网络信息" class="headerlink" title="网络信息"></a>网络信息</h5><p>主机IP地址可以调用主机数据库函数来获取，若没有查询的主机或地址相关的数据项，则返回空指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyaddr</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> type)</span>;</span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其中函数返回的指针指向的结构体包括如下成员</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *h_name;		<span class="comment">//主机名字</span></span><br><span class="line">    <span class="type">char</span> **h_aliase;	<span class="comment">//别名列表</span></span><br><span class="line">    <span class="type">int</span> h_addrtype;		<span class="comment">//地址类型</span></span><br><span class="line">    <span class="type">int</span> h_length;		<span class="comment">//地址长度的字节数</span></span><br><span class="line">    <span class="type">char</span> **h_addr_list;	<span class="comment">//地址列表（网络顺序）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>与服务及其关联端口号相关信息，可以通过服务信息函数获取。其中proto参数指定连接的协议，取值为tcp或udp。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> servent *<span class="title function_">getservbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *proto)</span>;</span><br><span class="line"><span class="keyword">struct</span> servent *<span class="title function_">getservbyport</span><span class="params">(<span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span> *proto)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构servent至少包含以下成员</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *s_name;		<span class="comment">//服务名称</span></span><br><span class="line">    <span class="type">char</span> **s_aliases;	<span class="comment">//别名列表</span></span><br><span class="line">    <span class="type">int</span> s_port;			<span class="comment">//IP端口号</span></span><br><span class="line">    <span class="type">char</span> *s_proto;		<span class="comment">//服务的协议类型tcp或udp</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>主机计算机数据库信息，可以调用gethostbyname函数，结果可以使用inet_ntoa将返回的地址从网络字节序转换为可以打印的字符串，字符串格式为“点分四元组”格式；而gethostname函数则是获取当前主机的名字，主机名字将被写入name指针指向的字符串中，若主机名太长，namelength会截断主机名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gethostname</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> namelength)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="因特网守护进程"><a href="#因特网守护进程" class="headerlink" title="因特网守护进程"></a>因特网守护进程</h5><p>UNIX系统通常以超级服务器的方式来提供多项网络服务。超级服务器程序(因特网守护进程xinetd或inetd)同时监听许多端口地址上的连接。当有客户连接到某项服务时，守护程序就运行相应的服务器。这使得针对各项网络服务的服务器不需要一直运行着，它们可以在需要时启动。</p>
<p>因特网守护进程在现代Linux系统中是通过xinetd来实现的。xinetd实现方式取代了原来的UNIX程序inetd，尽管你仍然会在一些较老的Linux系统中以及其他的类UNIX系统中看到inetd的应用。</p>
<p>我们通常是通过一个图形用户界面来配置xinetd以管理网络服务，但我们也可以直接修改它的配置文件。它的配置文件通常是&#x2F;etc&#x2F;xinetd.conf和&#x2F;etc&#x2F;xinetd.d目录中的文件。每一个由xinetd提供的服务都在&#x2F;etc&#x2F;xinetd.d目录中有一个对应的配置文件。xinetd将在其启动时或被要求的情况下读取所有这些配置文件。</p>
<h5 id="套接字选项"><a href="#套接字选项" class="headerlink" title="套接字选项"></a>套接字选项</h5><p>可以使用许多选项来控制套接字连接的行为，使用setsockopt函数控制这些选项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> socket, <span class="type">int</span> level, <span class="type">int</span> option_name, <span class="type">const</span> <span class="type">void</span> *option_value, <span class="type">size_t</span> option_len)</span>;</span><br></pre></td></tr></table></figure>

<p>其中参数level表示可以在协议层次的不同级别对选项进行设置。例如套接字级别设置为SOL_SOCKET，底层协议级别(如TCP、UDP)设置为该协议的编号（通过netinet&#x2F;in.h头文件或函数getprotobyname获取）。</p>
<p>选项名称和功能参考手册。</p>
<h5 id="select调用与多客户"><a href="#select调用与多客户" class="headerlink" title="select调用与多客户"></a>select调用与多客户</h5><p>在编写Linux程序时，经常会遇到需要检查好几个输入的状态才能确定下一步行动的情况。例如像终端仿真器的通信程序，需要有效同时读取键盘和串行口，若是在一个单用户的系统中，运行一个“忙等待”循环还可以接受，它不停扫描设备是否有数据，如果有数据到达就读取它，但就是很消耗CPU的时间。</p>
<p>select系统调用允许程序同时在多个底层文件描述符上等待输入的到达。这意味着终端仿真程序可以一直阻塞到有事情可做为止。类似地，服务器也可以通过同时在多个打开的套接字上等待请求到来的方法来处理多客户。</p>
<p><strong>select</strong>调用用于测试文件描述符集合中，是否有一个文件描述符已处于可读或可写状态或错误状态，它将阻塞以等待某个文件描述符进入上述这些状态。select系统调用原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>select函数返回状态变化的描述符总数，会在以下情况返回：readfds有描述符可读、writefds有描述符可写或者errorsfds有描述符遇到错误条件，若以上3种情况都不发生，则超过timeout时间后会返回。参数<strong>nfds</strong>指定需测试的文件描述符数目，数量从0到(nfds-1)；其他三个参数<strong>readfds</strong>、<strong>writefds</strong>和<strong>errorfds</strong>可以被设置为空指针，表示不执行相应的测试；参数<strong>timeout</strong>用于防止无限期阻塞，若它是一个空指针并且套接字没有任何活动，这个调用将一直阻塞下去。</p>
<p>select函数对数据结构fd_set进行的操作，它是由打开的文件描述符构成的集合，有一组定义好的宏可以用来控制这些集合。<strong>FD_ZERO</strong>用于将fd_set初始化为空集合；<strong>FD_SET</strong>和<strong>FD_CLR</strong>分别用于在集合中设置和清除由参数fd传递的文件描述符；<strong>FD_ISSET</strong>函数用于当select返回时，可以测试描述符集合readfds、writefds和errorfds，找出需要注意的描述符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *fdset)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;</span><br></pre></td></tr></table></figure>

<p>超时值由<strong>timeval</strong>结构控制：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">    <span class="type">time_t</span> tv_sec;	<span class="comment">//秒，类型time_t被定义为一个整数</span></span><br><span class="line">    <span class="type">long</span> tv_usec;	<span class="comment">//微秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="数据报与UDP"><a href="#数据报与UDP" class="headerlink" title="数据报与UDP"></a>数据报与UDP</h5><p>当客户需要发送一个短小的查询请求给服务器，并且期望接收到一个短小的响应时，我们一般就使用由UDP提供的服务。如果服务器处理客户请求的时间足够短，服务器就可以通过一次处理一个客户请求的方式来提供服务，从而允许操作系统将客户进入的请求放入队列。这简化了服务器程序的编写。</p>
<p>因为UDP提供的是不可靠服务，所以你可能发现数据报或响应会丢失。如果数据对于你来说非常重要，就需要小心编写UDP客户程序，以检查错误并在必要时重传。实际上，UDP数据报在局域网中是非常可靠的。</p>
<p>为了访问由UDP提供的服务，你需要像以前一样使用套接字和close系统调用，但你需要用两个数据报专用的系统调用sendto和recvfrom来代替原来使用在套接字上的read和write调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buffer, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr *from, <span class="type">socklen_t</span> *fromlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buffer, <span class="type">size_t</span> len, <span class="type">int</span> flgs, <span class="keyword">struct</span> sockaddr *from, <span class="type">socklen_t</span> *fromlen)</span>;</span><br></pre></td></tr></table></figure>

<p>flag参数一般设置为0。</p>
<h2 id="Linux-多线程编程"><a href="#Linux-多线程编程" class="headerlink" title="Linux 多线程编程"></a>Linux 多线程编程</h2><h2 id="Linux-tcp-ip网络编程"><a href="#Linux-tcp-ip网络编程" class="headerlink" title="Linux tcp&#x2F;ip网络编程"></a>Linux tcp&#x2F;ip网络编程</h2><h2 id="Linux系统信息获取"><a href="#Linux系统信息获取" class="headerlink" title="Linux系统信息获取"></a>Linux系统信息获取</h2><p>当为Linux(或UNIX和类UNIX系统)编写程序时，必须考虑到程序将在一个多任务环境中运行。这意味着在同一时间会有多个程序运行，它们共享内存、磁盘空间和CPU周期等机器资源。甚至同一程序也会有多个实例同时运行。最重要的是，这些程序能够互不干扰，能够了解它们的环境，并且能正确运行，不产生冲突(例如，试图与其他程序同时写同一个文件)。</p>
<p>程序能通过系统环境获得其相关运行条件的信息：</p>
<ul>
<li>向程序传递参数</li>
<li>环境变量</li>
<li>查看时间</li>
<li>临时文件</li>
<li>获得有关用户和主机的信息</li>
<li>生成和配置日志信息</li>
<li>了解系统各项资源的限制</li>
</ul>
<h4 id="程序参数"><a href="#程序参数" class="headerlink" title="程序参数"></a>程序参数</h4><p>当一个用C语言编写的Linux或UNIX程序运行时，它是从main函数开始的。对程序而言，main函数的声明如下所示：</p>
<p><code>int main(int argc, char *argv[])</code></p>
<p>shell将命令行输入的参数分解成单词并放入argv数组，argv[0]为程序名自身，若输入参数有n个，则共有n+1个实际参数。例如：<code>$ myprog left right &#39;and center&#39;</code></p>
<p>程序myprog将从main函数开始，main带的参数是：</p>
<p><code>argv: 4</code></p>
<p><code>argv: &#123;&quot;myprog&quot;, &quot;left&quot;, &quot;right&quot;, &quot;and center&quot;&#125;</code></p>
<p>一般在程序中，命令行参数设置有一定的原则：</p>
<ul>
<li>所有命令行开关都应以一个短横线 ‘-’ 开头，后面可以是数字或字母：-r -l。</li>
<li>若某选项需要值，该值应作为独立的参数紧跟在该选项后面：-xx value。</li>
<li>不带后续参数的选项可以在一个短横线后归并到一起：-lstr。</li>
<li>最好能为单字符开关增加一个更长的、更有意义的开关名：–help。</li>
</ul>
<h5 id="getopt函数"><a href="#getopt函数" class="headerlink" title="getopt函数"></a>getopt函数</h5><p>为了更好遵循上面的原则，Linux提供了getopt函数，它支持需要关联和非关联值的选项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getopt</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *<span class="type">const</span> argv[ ], <span class="type">const</span> <span class="type">char</span> *optstring)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *optarg;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> optind, opterr, optopt;</span><br></pre></td></tr></table></figure>

<p>getopt函数将传递给程序的main函数的argc和argv作为参数，同时接受一个选项指定符字符串optstring，该字符串告诉getopt哪些选项可用，以及它们是否有关联值。optstring只是一个字符列表，每个字符代表一个单字符选项。如果一个字符后面紧跟一个冒号(：)，则表明该选项有一个关联值作为下一个参数。bash中的getopts命令执行类似的功能。</p>
<p>例如，我们可以用下面的调用来处理上面的例子：</p>
<p><code>getopt (argc, argv, &quot;if:lr&quot;);</code></p>
<p>它允许几个简单的选项：-i、-l、-r和-f，其中-f选项后要紧跟一个文件名参数。使用相同的参数，但以不同的顺序来调用命令将改变程序的行为。</p>
<p>getopt的返回值是argv数组中的下一个选项字符（如果有的话）。循环调用getopt就可以依次得到每个选项。getopt有如下行为。</p>
<p>如果选项有一个关联值，则外部变量optarg指向这个值。<br>如果选项处理完毕，getopt返回-1，特殊参数 ‘–’ 将使getopt停止扫描选项。</p>
<p>如果遇到一个无法识别的选项，getopt返回一个问号(？)，并把它保存到外部变量optopt中。</p>
<p>如果一个选项要求有一个关联值(例如例子中的-f)，但用户并未提供这个值，getopt通常将返回一个问号(？)。如果我们将选项字符串的第一个字符设置为冒号(：)，那么getopt将在用户未提供值的情况下返回冒号(：)而不是问号(？)。</p>
<p>外部变量optind被设置为下一个待处理参数的索引。getopt利用它来记录自己的进度。程序很少需要对这个变量进行设置。当所有选项参数都处理完毕后，optind将指向argv数组尾部可以找到其余参数的位置。</p>
<p><code>有些版本的getopt会在第一个非选项参数处停下来，返回-1并设置optind的值。而其他一些版本，如Linux提供的版本，能够处理出现在程序参数中任意位置的选项。注意，在这种情况下，getopt实际上重写了argv数组，把所有非选项参数都集中在一起，从argv[optind]位置开始。对GNU版本的getopt而言，这一行为是由环境变量POSIXLY_CORRECT控制的，如果它被设置，getopt就会在第一个非选项参数处停下来。此外，还有些getopt版本会在遇到未知选项时打印出错信息。注意，根据POSIX规范的规定，如果opterr变量是非零值，getopt就会向stderr打印一条出错信息。</code></p>
<h5 id="getopt-long函数"><a href="#getopt-long函数" class="headerlink" title="getopt_long函数"></a>getopt_long函数</h5><p>许多Linux应用程序也接受比我们在前面例子中所用的单字符选项含义更明确的参数。GNU C函数库包含getopt的另一个版本，称作getopt_long，它接受以双划线(-)开始的长参数。</p>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>UNIX规范为各种应用定义了许多标准环境变量，包括终端类型、默认的编辑器、时区等。C语言程序可以通过putenv和getenv函数来访问环境变量。</p>
<h5 id="putenv函数和getenv函数"><a href="#putenv函数和getenv函数" class="headerlink" title="putenv函数和getenv函数"></a>putenv函数和getenv函数</h5><p>环境由一组格式为“名字&#x3D;值”的字符串组成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">putenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="built_in">string</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>getenv函数以给定的名字搜索环境中的一个字符串，并返回与该名字相关的值。如果请求的变量不存在，它就返回null。如果变量存在但无关联值，它将运行成功并返回一个空字符串，即该字符串的第一个字节是null。由于getenv返回的字符串是存储在getenv提供的静态空间中，所以如果想进一步使用它，你就必须将它复制到另一个字符串中，以免它被后续的getenv调用所覆盖。</p>
<p>putenv函数以一个格式为“名字&#x3D;值”的字符串作为参数，并将该字符串加到当前环境中。如果由于可用内存不足而不能扩展环境，它会失败并返回-1。此时，错误变量errno将被设置为ENOMEM。</p>
<p>在下面的实验中，你将编写一个程序来打印所选的任意环境变量的值。如果给程序传递第二个参数，你还将设置环境变量的值。</p>
<p><code>注意：环境仅对程序本身有效。你在程序里做的改变不会反映到外部环境中，这是因为变量的值不会从子进程（你的程序）传播到父进程(shell)。</code></p>
<h5 id="environ变量"><a href="#environ变量" class="headerlink" title="environ变量"></a>environ变量</h5><p>程序可以通过environ变量（一个以null结尾的字符串数组）直接访问这个字符串数组，其声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ</span><br></pre></td></tr></table></figure>

<p>例子，遍历并输出系统的环境变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> **env = environ;</span><br><span class="line">    <span class="keyword">while</span>(*env)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,*env);</span><br><span class="line">        env++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="《linux程序设计》阅读笔记/image-20220418221627496.png" alt="image-20220418221627496" style="zoom:50%;" />



<h4 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h4><h5 id="time函数"><a href="#time函数" class="headerlink" title="time函数"></a>time函数</h5><p>时间通过一个预定义的类型time_t来处理。这是一个大到能够容纳以秒计算的日期和时间的整数类型。在Linux系统中，它是一个长整型，与处理时间值的函数一起定义在头文件time.h中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">time</span><span class="params">(<span class="type">time_t</span> *tloc)</span>;</span><br></pre></td></tr></table></figure>

<p>可以通过调用time函数得到底层的时间值，它返回的是从纪元开始至今的秒数。如果tloc不是一个空指针，time函数还会把返回值写入tloc指针指向的位置。</p>
<h5 id="difftime函数"><a href="#difftime函数" class="headerlink" title="difftime函数"></a>difftime函数</h5><p>以从1970年开始计算的秒数来表示时间和日期，对测算某些事情持续的时间是很有用的。可以把它考虑为简单地把两次调用time得到的值相减。然而ISO&#x2F;ANSI C标准委员会经过审议，并没有规定用time_t类型来测量任意时间之间的秒数，他们发明了一个函数difftime，该函数用来计算两个time_t值之间的秒数并以double类型返回它。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">difftime</span><span class="params">(<span class="type">time_t</span> timel, <span class="type">time_t</span> time2)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="gmtime函数"><a href="#gmtime函数" class="headerlink" title="gmtime函数"></a>gmtime函数</h5><p>为了提供（对人类）更有意义的时间和日期，需要把时间值转换为可读的时间和日期。有一些标准函数可以帮我们做到这一点。gmtime函数把底层时间值分解为一个结构，该结构包含一些常用的成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">gmtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> timeval)</span>;</span><br></pre></td></tr></table></figure>

<p>tm结构被定义为至少包含表中所示的成员。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="《linux程序设计》阅读笔记/image-20220413154609767.png" alt="image-20220413154609767" style="zoom:67%;" />

<p><code>不过，这儿有个小问题。如果在格林尼治标准时间(GMT)之外的时区运行这个程序，或者所在的地方像本例中那样采用了夏令时，你会发现时间（可能还有日期）是不对的。这是因为gmtime按GMT返回时间(现在GMT被称为世界标准时间，或UTC)Linux和UNIX这样做是为了同步全球各地的所有程序和系统。不同时区同一时刻创建的文件都会有相同的创建时间。要看当地时间，你需要使用localtime函数。</code></p>
<h5 id="localtime函数"><a href="#localtime函数" class="headerlink" title="localtime函数"></a>localtime函数</h5><p>使用localtime函数能输出当地时区的时间信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">localtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timeval)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="mktime函数"><a href="#mktime函数" class="headerlink" title="mktime函数"></a>mktime函数</h5><p>使用mktime函数可以将localtime输出值转化为原始的时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">mktime</span><span class="params">(<span class="keyword">struct</span> tm *timeptr)</span>;</span><br></pre></td></tr></table></figure>

<h5 id="astime和ctime函数"><a href="#astime和ctime函数" class="headerlink" title="astime和ctime函数"></a>astime和ctime函数</h5><p>为了更“友好”地显示时间和日期，可以使用这两个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">astime</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> tm *timeptr)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">ctime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timeval)</span>;</span><br></pre></td></tr></table></figure>

<p>asctime函数返回一个字符串，它表示由tm结构timeptr所给出的时间和日期。这个返回的字符串有类似下面的格式，它总是这种长度为26个字符的固定格式：</p>
<p><code>Sun Jun 9 12:34:56 2007\n\0</code></p>
<p>ctime函数等效于调用下面这个函数，它以原始时间值为参数，并将它转换为一个更易读的本地时间：</p>
<p><code>asctime(localtime(timeval))</code></p>
<h5 id="strftime函数和strptime函数"><a href="#strftime函数和strptime函数" class="headerlink" title="strftime函数和strptime函数"></a>strftime函数和strptime函数</h5><p>为了对时间和日期字符串的格式有更多控制，Linux和现代的类UNIX系统提供了<strong>strftime函数</strong>。它很像是一个针对时间和日期的sprintf函数，工作方式也很类似：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strftime</span><span class="params">(<span class="type">char</span> *s, <span class="type">size_t</span> maxsize, <span class="type">const</span> <span class="type">char</span> *format, <span class="keyword">struct</span> tm *timeptr)</span>;</span><br></pre></td></tr></table></figure>

<p>strftime函数格式化timeptr指针指向的tm结构所表示的时间和日期，并将结果放在字符串s中。字符串被指定（至少）maxsize个字符长。format字符串用于控制写入字符串s的字符。与printf一样，它包含将被传给字符串的普通字符和用于格式化时间和日期元素的转换控制符。转换控制符见表。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="《linux程序设计》阅读笔记/image-20220418224755021.png" alt="image-20220418224755021" style="zoom:50%;" />

<p>为了读取日期，你可以使用<strong>strptime函数</strong>，该函数以一个代表日期和时间的字符串为参数，并创建表示同一日期和时间的tm结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strptime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *format, <span class="keyword">struct</span> tm *timeptr)</span>;</span><br></pre></td></tr></table></figure>

<p>format字符串的构建方式和strftime的format字符串完全一样。strptime在字符串扫描方面类似于sscanf函数，也是查找可识别字段，并把它们写入对应的变量中。只是这里是根据format字符串来填充tm结构的成员。不过，strptimel的转换控制符与strftime的相比，限制要稍微松一些，因为strptime中的星期几和月份用缩写和全称都行，两者都匹配strptime中的a控制符，此外，strftime对小于10的数字总以0开头，而strptimel则把它看作是可选的。</p>
<p>strptime返回一个指针，指向转换过程处理的最后一个字符后面的那个字符。如果碰到不能转换的字符，转换过程就在该处停下来。调用程序需要检查是否己从传递的字符串中读入了足够多的数据，以确保tm结构中写入了有意义的值。</p>
<h4 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h4><p>很多情况下，程序会利用一些文件形式的临时存储手段。这些临时文件可能保存着一个计算的中间结果，也可能是关键操作前的文件备份。例如，一个数据库应用程序在删除记录时就可能使用临时文件。该文件收集需要保留的数据库条目，然后在处理结束后，这个临时文件就变成新的数据库，原来文件则被删除。</p>
<p>临时文件的这种用法很常见，但也有一个隐藏的缺点。必须确保应用程序为临时文件选取的文件名是唯一的。否则，因为Linux是一个多任务系统，另一个程序就可能选择同样的文件名，从而导致两个程序互相干扰。</p>
<h5 id="tmpna函数"><a href="#tmpna函数" class="headerlink" title="tmpna函数"></a>tmpna函数</h5><p>用tmpnam函数可以生成一个唯一的文件名：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">tmpnam</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure>

<p>tmpnam函数返回一个不与任何己存在文件同名的有效文件名。如果字符串s不为空，文件名也会写入它。对tmpnaml的后续调用会覆盖存放返回值的静态存储区，所以如果tmpnam要被多次调用，就有必要给它传递一个字符串参数了。这个字符串的长度至少要有L_tmpnam(通常为20)个字符。tmpnam可以被一个程序最多调用TMP_MAX次（至少为几千次），每次它都会返回一个不同的文件名。</p>
<h5 id="tmpfile函数"><a href="#tmpfile函数" class="headerlink" title="tmpfile函数"></a>tmpfile函数</h5><p>如果遇到需要立刻使用临时文件的情况，你可以用tmpfile函数在给它命名的同时打开它。这点非常重要，因为另一个程序可能会创建出一个与tmpnam返回的文件名同名的文件。tmpfile函数则完全避免了这个问题的发生：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *<span class="title function_">tmpfile</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>tmpfile函数返回一个文件流指针，它指向一个唯一的临时文件。该文件以读写方式打开（通过w+方式的fopen)，当对它的所有引用全部关闭时，该文件会被自动删除。</p>
<p>如果出错，tmpfile返回空指针并设置errno的值。</p>
<h5 id="mktemp函数和mkstemp函数"><a href="#mktemp函数和mkstemp函数" class="headerlink" title="mktemp函数和mkstemp函数"></a>mktemp函数和mkstemp函数</h5><p>UNIX有另一种生成临时文件名的方式，就是使用mktemp和mkstemp函数。Linux也支持这两个函数，它们与tmpnam类似，不同之处在于可以为临时文件名指定一个模板，模板可以让你对文件的存放位置和名字有更多的控制：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">mktemp</span><span class="params">(<span class="type">char</span> *template)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkstemp</span><span class="params">(<span class="type">char</span> *template)</span>;</span><br></pre></td></tr></table></figure>

<p>mktemp函数以给定的模板为基础创建一个唯一的文件名。template参数必须是一个以6个x字符结尾的字符串。mktemp即函数用有效文件名字符的一个唯一组合来替换这些x字符。它返回一个指向生成的字符串的指针，如果不能生成一个唯一的名字，它就返回一个空指针。</p>
<p>mkstemp函数类似于tmpfile，它也是同时创建并打开一个临时文件。文件名的生成方法和mktemp一样，但是它的返回值是一个打开的、底层的文件描述符。</p>
<p><code>应该在程序中使用“创建并打开”函数tmpfile和mkstemp，而不要使用tmpnam和mktemp。</code></p>
<h4 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h4><p>除了init程序以外，所有的linux程序都是由其他程序或用户启动的。Linux运行的每个程序都是以某个用户的名义在运行，每个用户登录进入Linux系统时会有一个用户标识符UID，所以运行的程序会有一个关联的UID。</p>
<p>UID有自己的类型uid_t，定义在sys&#x2F;types.h中，是一个小整数。有些UID是系统预定义的，其他则是系统管理员在添加新用户时创建的。一般情况下，用户的UID值都大于100。</p>
<h5 id="getuid和getlogin函数"><a href="#getuid和getlogin函数" class="headerlink" title="getuid和getlogin函数"></a>getuid和getlogin函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">getuid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">getlogin</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>getuid函数返回程序关联的UID，它通常是启动程序的用户的UID。getlogin函数返回与当前用户关联的登录名。</p>
<p>系统文件&#x2F;etc&#x2F;passwd包含一个用户账号数据库。它由行组成，每行对应一个用户，包括用户名、加密口令、用户标识符(UID)、组标识符(GID)、全名、家目录和默认shell。下面是一个示例行：</p>
<p><code>neil:zBqxfgedfpk:500:100:Neil atthew:/home/neil:/bin/bash</code></p>
<p>如果编写一个程序，它能确定启动它的用户的UID，那么你就可以对它进行扩展，让它查找密码文件以找到用户的登录名和全名。</p>
<p>但我们并不推荐这种做法，因为为了提高系统的安全性，现代的类UNIX系统都不再使用简单的密码文件了。许多系统，包括Linux，都有一个使用shadow密码文件的选项，原来的密码文件中不再包含任何有用的加密口令信息（这些信息通常存放在&#x2F;etc&#x2F;shadow文件中，这是一个普通用户不能读取的文件）。为此，人们定义了一组函数来提供一个标准而有效的获取用户信息的编程接口。</p>
<h5 id="getpwuid和getpwnam函数"><a href="#getpwuid和getpwnam函数" class="headerlink" title="getpwuid和getpwnam函数"></a>getpwuid和getpwnam函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> password *<span class="title function_">getpwuid</span><span class="params">(<span class="type">uid_t</span> uid)</span>;</span><br><span class="line"><span class="keyword">struct</span> password *<span class="title function_">getpwnam</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>

<p>密码数据库结构password定义在头文件pwd.h中，包含以下成员：</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="《linux程序设计》阅读笔记/image-20220418232511926.png" alt="image-20220418232511926" style="zoom:67%;" />

<p>有些UNIX系统可能对用户全名字段使用一个不同的名字。例如某些系统上是pw_gecos，其他系统是pw_comment。</p>
<p>getpwuid和getpwnam函数都返回一个指针，该指针指向某个用户对应的password结构。这个用户通过getpwuid的UID参数或通过getpwnam的用户登录名来确定。出错时，它们返回一个空指针并设置errno。</p>
<h5 id="getpwent函数"><a href="#getpwent函数" class="headerlink" title="getpwent函数"></a>getpwent函数</h5><p>如果要扫描密码文件中的所有信息，可以使用getpwent函数。它的作用是依次取出文件数据项：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">endpwent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">struct</span> password *<span class="title function_">getpwent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setpwent</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>getpwent函数依次返回每个用户的信息数据项。当到达文件尾时，它返回一个空指针。</p>
<p>如果已经扫描了足够多的数据项，可以使用endpwent函数来终止处理过程。</p>
<p>setpwent函数重置读指针到密码文件的开始位置，这样下一个getpwent函数重新开始一个新的扫描。</p>
<h5 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h5><p>用户和组标识符还可以被其他一些不太常用的函数获得：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">geteuid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">gid_t</span> <span class="title function_">getgid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">gid_t</span> <span class="title function_">getegid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">#只有超级用户才能调用setuid和setgid函数</span><br><span class="line"><span class="type">int</span> <span class="title function_">setuid</span><span class="params">(<span class="type">uid_t</span> uid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setgid</span><span class="params">(<span class="type">gid_t</span> gid)</span>;</span><br></pre></td></tr></table></figure>



<h4 id="主机信息"><a href="#主机信息" class="headerlink" title="主机信息"></a>主机信息</h4><p>正如程序可以查找用户信息一样，程序也可以获得运行它的计算机的有关细节。</p>
<h5 id="gethostname函数"><a href="#gethostname函数" class="headerlink" title="gethostname函数"></a>gethostname函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gethostname</span><span class="params">(<span class="type">char</span> *name, <span class="type">size_t</span> namelen)</span>;</span><br></pre></td></tr></table></figure>

<p>gethostname函数把机器的网络名写入name字符串。该字符串至少有namelen个字符长。成功时，gethostname返回0，否则返回-1。</p>
<h5 id="uname函数"><a href="#uname函数" class="headerlink" title="uname函数"></a>uname函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/utsname.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">uname</span><span class="params">(<span class="keyword">struct</span> utsname *name)</span>;</span><br></pre></td></tr></table></figure>

<p>uname函数主机信息写入name参数指向的结构。utsname结构定义在头文件sys&#x2F;utsname.h中，至少包括以下成员：</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="《linux程序设计》阅读笔记/image-20220418235142742.png" alt="image-20220418235142742" style="zoom:67%;" />

<p>uname成功时返回一个非负整数，否则返回-1并设置errno来指出错误。</p>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>许多应用程序需要记录它们的活动。系统程序经常需要向控制台或日志文件写消息。这些消息可能指示错误、警告或是与系统状态有关的一般信息。</p>
<h5 id="syslog函数"><a href="#syslog函数" class="headerlink" title="syslog函数"></a>syslog函数</h5><p>虽然系统消息的格式和存储方式不尽相同，但产生消息的方法却是标准的。UNIX规范通过syslog函数为所有程序产生日志信息提供了一个接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syslog</span><span class="params">(<span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span> *message, arguments...)</span>;</span><br></pre></td></tr></table></figure>

<p>syslog函数向系统的日志设施（facility）发送一个日志信息。每条信息都有一个priority参数，该参数是一个<strong>严重级别</strong>与一个<strong>设施值</strong>的<u>按位或</u>。其中，严重级别控制日志信息的处理方式，设施值记录日志信息的来源。</p>
<p>定义在头文件syslog.h中的<strong>设施值</strong>包括LOG_USER（默认值）——它指出消息来自一个用户应用程序，以及LOG_LOCAL0、LOG_LOCAL1直到LOG_LOCAL7，它们含义由本地管理员指定。</p>
<p><strong>严重级别</strong>按优先级递减排列：</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="《linux程序设计》阅读笔记/image-20220419000555074.png" alt="image-20220419000555074" style="zoom:67%;" />

<p>根据系统配置，LOG_EMERG信息可能会广播给所有用户，LOG_ALERT信息可能会EMAIL给管理员，LOG_DEBUG信息可能会被忽略，而其他信息则写入日志文件。</p>
<p>syslog创建的日志信息包含消息头和消息体。消息头根据设施值及日期和时间创建。消息体根据syslog的message参数创建，该参数的作用类似printf中的格式字符串。syslog的其他参数根据message字符串中printf风格的转换控制符而定。</p>
<p>此外，转换控制符%m可用于插入与错误变量errno当前值对应的出错消息字符串，对于记录错误消息很有用。</p>
<p><code>例：syslog(LOG_ERR | LOG_USER, &quot;oops-%m\n&quot;);</code></p>
<h5 id="其他函数-1"><a href="#其他函数-1" class="headerlink" title="其他函数"></a>其他函数</h5><p>在头文件syslog.h中还定义了一些能够改变日志记录行为的其他函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">closelog</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">openlog</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ident, <span class="type">int</span> logopt, <span class="type">int</span> facility)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setlogmask</span><span class="params">(<span class="type">int</span> maskpri)</span>;</span><br></pre></td></tr></table></figure>

<p>你可以通过调用openlog函数来改变日志信息的表示方式。它可以设置一个字符串ident，该字符串会添加在日志信息的前面。你可以通过它来指明是哪个程序创建了这条信息。facility参数记录一个将被用于后续syslog调用的默认设施值，其默认值是LOG_USER。logopt参数对后续syslog调用的行为进行配置，它是0个或多个表中参数的按位或。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="《linux程序设计》阅读笔记/image-20220419001914154.png" alt="image-20220419001914154" style="zoom:67%;" />

<p>openlog函数会分配并打开一个文件描述符，并通过它来写日志。你可以调用closelog函数来关闭它。注意，在调用syslog.之前无需调用openlog,因为syslog会根据需要自行打开日志设施。</p>
<p>你可以使用setlogmask函数来设置一个日志掩码，并通过它来控制日志信息的优先级。优先级未在日志掩码中置位的后续syslog调用都将被丢弃。所以你可以通过这个方法关闭LOG_DEBUG消息而不用改变程序主体。</p>
<p>你可以用LOG_MASK(priority)为日志信息创建一个掩码，它的作用是创建一个只包含一个优先级的掩码。你还可以用LOG_UPTO(priority)来创建一个由指定优先级之上的所有优先级（包括指定优先级）构成的掩码。</p>
<h4 id="资源和限制"><a href="#资源和限制" class="headerlink" title="资源和限制"></a>资源和限制</h4><p>Linux系统上运行的程序会受到资源限制的影响。它们可能是硬件方面的物理性限制（例如内存）、系统策略的限制(例如，允许使用的CPU时间)或具体实现的限制（如整数的长度或文件名中所允许的最大字符数）。UNIX规范定义了一些可由应用程序决定的限制。</p>
<p>头文件limits.h中定义了许多代表操作系统方面限制的显式常量，如表所示。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="《linux程序设计》阅读笔记/image-20220419002212785.png" alt="image-20220419002212785" style="zoom:67%;" />

<p><code>注意：NAME_MAX是特定于文件系统的。为了写可移植性更好的代码，你应该使用pathconf函数。详细信息请参考pathconf的手册页。</code></p>
<p>头文件sys&#x2F;resource.h提供了资源操作方面的定义，其中包括对程序长度、执行优先级和文件资源等方面限制进行查询和设置的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getpriority</span><span class="params">(<span class="type">int</span> which, <span class="type">id_t</span> who)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setpriority</span><span class="params">(<span class="type">int</span> which, <span class="type">id_t</span> who, <span class="type">int</span> priority)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="keyword">struct</span> rlimit *r_limit)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setrlimit</span> <span class="params">(<span class="type">int</span> resource, <span class="type">const</span> <span class="keyword">struct</span> rlimit *r_limit)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getrusage</span><span class="params">(<span class="type">int</span> who, <span class="keyword">struct</span> rusage *r_usage)</span>;</span><br></pre></td></tr></table></figure>

<p>id_t是一个整数类型，它用于用户和组标识符。在头文件sys&#x2F;resource.h中定义的rusage结构用来确定当前程序已耗费了多少CPU时间，它至少包含如下两个成员。</p>
<ul>
<li>struct timeval ru_utime: 使用的用户时间</li>
<li>struct timeval ru_stime: 使用的系统时间</li>
</ul>
<p>***暂略！</p>
<h2 id="Linux数据管理"><a href="#Linux数据管理" class="headerlink" title="Linux数据管理"></a>Linux数据管理</h2><p>数据管理的3个方面。</p>
<ul>
<li>动态内存管理：可以做什么以及Liux不允许做什么。</li>
<li>文件锁定：协调锁、共享文件的锁定区域和避免死锁。</li>
<li>dbm数据库：一个大多数Linux系统都提供的、基本的、不基于SQL的数据库函数库。</li>
</ul>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>Linux为应用程序提供了一个简洁的视图，它能反映一个巨大的可直接寻址的内存空间。</p>
<p>此外，Linux还提供了内存保护机制，它避免了不同的应用程序之间的互相干扰。</p>
<p>如果机器被正确配置并且有足够的交换空间，Linux还允许应用程序访问比实际物理内存更大的内存空间。</p>
<h5 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h5><p>使用标准C语言函数库中的malloc调用来分配内存：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="comment">//为一个结构数组分配内存，返回结果为第一个元素的指针</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> number_of_elements, <span class="type">size_t</span> element_size)</span>;</span><br><span class="line"><span class="comment">//改变之前分配的内存块的大小，使用该函数后应使用返回的新的内存指针</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *existing_memory, <span class="type">size_t</span> new_size)</span>;</span><br></pre></td></tr></table></figure>

<p>刚开始时，内核只是通过使用空闲的物理内存来满足应用程序的内存请求，但是当物理内存耗尽时，它便会开始使用所谓的交换空间(swap space)。在Linux系统中，交换空间是一个在安装系统时分配的独立的磁盘区域。如果熟悉Windows操作系统的话，Linux交换空间的作用有点像隐藏的Windows交换文件。但与Windows不同，Linux的交换空间中没有局部堆、全局堆或可丢弃内存段等需要在代码中操心的内容——Linux内核会为你完成所有的管理工作。</p>
<p>内核会在物理内存和交换空间之间移动数据和程序代码，使得每次读写内存时，数据看起来总像是已存在于物理内存中，而不管在你访问它们之前，它们究竟是在哪里。用更专业的术语来说，Linux实现了一个“按需换页的虚拟内存系统”。用户程序看到的所有内存全是虚拟的，也就是说，它并不真正存在于程序使用的物理地址上。Linux将所有的内存都以页为单位进行划分，通常每一页的大小为4096字节。每当程序试图访问内存时，就会发生虚拟内存到物理内存的转换，转换的具体实现和耗费的时间取决于你所使用的特定硬件情况。当所访问的内存在物理上并不存在时，就会产生一个页面错误并将控制权交给内核。</p>
<p>Linux内核会对访问的内存地址进行检查，如果这个地址对于程序来说是合法可用的，内核就会确定需要向程序提供哪一个物理内存页面。然后，如果该页面之前从未被写入过，内核就直接分配它，如果它己经被保存在硬盘的交换空间上，内核就读取包含数据的内存页面到物理内存（可能需要把一个已有页面从内存中移出到硬盘）。接着，在完成虚拟内存地址到物理地址的映射之后，内核允许用户程序继续运行。Linux应用程序并不需要操心这一过程，因为所有的具体实现都已隐藏在内核中了。最终，当应用程序耗尽所有的物理内存和交换空间，或者当最大栈长度被超过时，内核将拒绝此后的内存请求，并可能提前终止程序的运行。</p>
<h5 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h5><p>动态使用内存的程序应该总是通过free调用，来把不用的内存释放给malloc内存管理器。这样做可以将分散的内存块重新合并到一起，并由malloc函数库而不是应用程序来管理它。如果一个运行中的程序（进程）自己使用并释放内存，则这些自由内存实际上仍然处于被分配给该进程的状态。</p>
<p>在幕后，Linux将程序员使用的内存块作为一个物理页面集来管理，通常内存中的每个页面为4K字节。但如果一个内存页面未被使用，Linux内存管理器就可以将其从物理内存置换到交换空间中（术语叫换页），从而减轻它对资源使用的影响。如果程序试图访问位于已置换到交换空间中的内存页中的数据，那么Linux会短暂地暂停程序，将内存页从交换空间再次置换到物理内存，然后允许程序继续运行，就像数据一直存在于内存中一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr_to memory)</span>;</span><br></pre></td></tr></table></figure>

<p><code>调用free时使用的指针参数必须是指向由malloc、calloc或realloc调用所分配的内存</code></p>
<p>请记住：一旦调用free释放了一块内存，它就不再属于这个进程。它将由malloc函数库负责管理。在对一块内存调用free之后，就绝不能再对其进行读写操作了。</p>
<h4 id="文件锁定"><a href="#文件锁定" class="headerlink" title="文件锁定"></a>文件锁定</h4><p>文件锁定是多用户、多任务操作系统中一一个非常重要的组成部分。程序经常需要共享数据，而这通常是通过文件来实现的。因此，对于这些程序来说，建立某种控制文件的方式就非常重要了。只有这样，文件才可以通过一种安全的方式更新，或者说，当一个程序正在对文件进行写操作时，文件就会进入一个暂时状态，在这个状态下，如果另外一个程序尝试读这个文件，它就会自动停下来等待这个状态的结束。</p>
<p>第一种方法——<strong>创建锁文件</strong>。Linux提供了多种特性来实现文件锁定。其中最简单的方法就是以原子操作的方式创建锁文件，所谓“原子操作”就是在创建锁文件时，系统将不允许任何其他的事情发生。这就给程序提供了一种方式来确保它所创建的文件是唯一的，而且这个文件不可能被其他程序在同一时刻创建。</p>
<p>第二种方法——<strong>区域锁定</strong>。这种方法更高级一些，它允许程序锁定文件的一部分，从而可以独享对这一部分内容的访问。有两种不同的方式可以实现第二种形式的文件锁定。将只对其中的一种做详细介绍，因为两种方式非常相似——第二种方式只不过是程序接口稍微不同而己。</p>
<h5 id="方法一：创建锁文件"><a href="#方法一：创建锁文件" class="headerlink" title="方法一：创建锁文件"></a>方法一：创建锁文件</h5><p>许多应用程序只需要能够针对某个资源创建一个锁文件即可。然后，其他程序就可以通过检查这个文件来判断它们自己是否被允许访问这个资源。</p>
<p><code>注意，锁文件仅仅只是充当一个指示器的角色，程序间需要通过相互协作来使用它们。用术语来说，锁文件只是建议锁，而不是强制锁，在后者中，系统将强制锁的行为。</code></p>
<p>为了创建一个用作锁指示器的文件，你可以使用在fcntl.h头文件中定义的open系统调用，并带上O_CREAT和O_EXCL标志。这样能够以一个原子操作同时完成两项工作：确定文件不存在，然后创建它。</p>
<h5 id="方法二：区域锁定"><a href="#方法二：区域锁定" class="headerlink" title="方法二：区域锁定"></a>方法二：区域锁定</h5><p>用创建锁文件的方法来控制对诸如串行口或不经常访问的文件之类的资源的独占式访问，是一个不错的选择，但它并不适用于访问大型的共享文件。假设你有一个大文件，它由一个程序写入数据，但却由许多不同的程序同时对这个文件进行更新。当一个程序负责记录长期以来连续收集到的数据，而其他一些程序负责对记录的数据进行处理时，这种情况就可能发生。处理程序不能等待记录程序结束，因为记录程序将一直不停地运行，所以它们需要一些协调方法来提供对同一个文件的并发访问。</p>
<p>你可以通过锁定文件区域的方法来解决这个问题，文件中的某个特定部分被锁定了，但其他程序可以访问这个文件中的其他部分。这被称为文件段锁定或文件区域锁定。Linux提供了至少两种方式来实现这一功能：使用<strong>fcntl系统调用</strong>和使用<strong>lockf调用</strong>。</p>
<p>我们将主要介绍fcntl接口，因为它是最常使用的接口。lockf和fcntl非常相似，在Linux中，它一般作为fcntl的备选接口。但是，fcntl和lockf的锁定机制不能同时工作：它们使用不同的底层实现，因此决不要混合使用这两种类型的调用，而应坚持使用其中的一种。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fildes, <span class="type">int</span> command, ···)</span>;</span><br></pre></td></tr></table></figure>

<p>fcntl对一个打开的文件描述符进行操作，并能根据<strong>command</strong>参数的设置完成不同的任务。它为我们提供了3个用于文件锁定的命令选项：F_GETLK、F_SETLK和F_SETLKW。</p>
<p>当使用这些命令选项时，fcntl的第三个参数必须是一个指向flock结构的指针，所以实际的函数原型应为：<code>int fcntl(int fildes, int command, struct flock *flock_structure);</code></p>
<p><strong>flock_structure</strong>（文件锁）结构依赖具体的实现，但它至少包含下述成员：</p>
<ul>
<li>short l_type</li>
<li>short l_whence</li>
<li>off_t l_start</li>
<li>off_t l_1en</li>
<li>pid_t l_pid</li>
</ul>
<p><strong>l_type</strong>成员的取值定义在头文件fcntl.h中，如表所示。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="《linux程序设计》阅读笔记/image-20220426113659898.png" alt="image-20220426113659898" style="zoom:67%;" />

<p><strong>l_whence</strong>、<strong>l_start</strong>和<strong>l_len</strong>成员定义了文件中的一个区域，即一个连续的字节集合。l_whence的取值必须是SEEK_SET、SEEK_CUR、SEEK END(在头文件unistd.h中定义)中的一个。它们分别对应于文件头、当前位置和文件尾。l_whence定义了l_start的相对偏移值，其中，l_start是该区域的第一个字节。l_whence通常被设为SEEK_SET，这时l_start就从文件的开始计算。l_len参数定义了该区域的字节数。</p>
<p><strong>l_pid</strong>参数用来记录持有锁的进程。</p>
<p>文件中的每个字节在任一时刻只能拥有一种类型的锁：共享锁、独占锁或解锁。fcntl调用可用的命令和选项的组合相当多：</p>
<p><strong>1、F_GETLK命令</strong></p>
<p>第一个命令是F_GETLK。它用于获取fildes（第一个参数）打开的文件的锁信息。它不会尝试去锁定文件。调用进程把自己想创建的锁类型信息传递给fcntl，使用F_GETLK命令的fcntl就会返回将会阻止获取锁的任何信息。</p>
<p>flock结构中使用的值如表所示。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="《linux程序设计》阅读笔记/image-20220426114303526.png" alt="image-20220426114303526" style="zoom:67%;" />

<p><strong>2、F_SETLK命令</strong></p>
<p>这个命令试图对fildes指向的文件的某个区域加锁或解锁。flock结构中使用的值（与F_GETLK命令中用到的不同之处）如表所示。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="《linux程序设计》阅读笔记/image-20220426114416221.png" alt="image-20220426114416221" style="zoom:67%;" />

<p>与F_GETLK一样，要加锁的区域由flock结构中的l_start、l_whence和l_len的值定义。如果加锁成功，fcntl将返回一个非-1的值：如果失败，则返回-1。这个函数总是立刻返回。</p>
<p><strong>3、F_SETLKW命令</strong></p>
<p>F_SETLKW命令与上面介绍的FSETLK命令作用相同，但在无法获取锁时，这个调用将等待直到可以为止。一旦这个调用开始等待，只有在可以获取锁或收到一个信号时它才会返回。</p>
<p><code>程序对某个文件拥有的所有锁都将在相应的文件描述符被关闭时自动清除。在程序结束时也会自动清除各种锁。</code></p>
<h5 id="其他锁方法"><a href="#其他锁方法" class="headerlink" title="其他锁方法"></a>其他锁方法</h5><p>还有另外一种锁定文件的方法：lockf函数。它也通过文件描述符进行操作。其原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lockf</span><span class="params">(<span class="type">int</span> fildes, <span class="type">int</span> function, <span class="type">off_t</span> size_to_lock)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>function参数</strong>的取值如下所示。</p>
<ul>
<li>F_ULOCK:解锁。</li>
<li>F_LOCK:设置独占锁。</li>
<li>F_TLOCK:测试并设置独占锁。</li>
<li>F_TEST:测试其他进程设置的锁。</li>
</ul>
<p><strong>size_to_lock参数</strong>是操作的字节数，它从文件的当前偏移值开始计算。</p>
<p>lockf有一个比fcntl函数更简单的接口，这主要是因为它在功能性和灵活性上都要比fcntl函数差一些。为了使用这个函数，必须首先搜寻你想锁定的区域的起始位置，然后以要锁定的字节数为参数来调用它。</p>
<p>与文件锁定的fcntl方法一样，lockf设置的所有锁都是建议锁，它们并不会真正地阻止你读写文件中的数据。对锁的检测是程序的责任。混合使用fcntl锁和lockf锁的效果未被定义，因此你必须决定使用哪种类型的锁定方法并坚持用下去。</p>
<h5 id="锁定状态下的读写操作"><a href="#锁定状态下的读写操作" class="headerlink" title="锁定状态下的读写操作"></a>锁定状态下的读写操作</h5><p>当对文件区域加锁之后，你必须使用底层的read和write调用来访问文件中的数据，而不要使用更高级的fread和fwrite调用，这是因为fread和fwrite会对读写的数据进行缓存。</p>
<h5 id="文件锁的竞争"><a href="#文件锁的竞争" class="headerlink" title="文件锁的竞争"></a>文件锁的竞争</h5><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>在讨论锁定时如果未提到死锁的危险，那么这个讨论就不能算是完整的。假设两个程序想要更新同一个文件。它们需要同时更新文件中的字节1和字节2。程序A选择首先更新字节2，然后再更新字节1；程序B则是先更新字节1，然后才是字节2。两个程序同时启动。程序A锁定字节2，而程序B锁定字节1。然后程序A尝试锁定字节1，但因为这个字节已经被程序B锁定，所以程序A将在那里等待。接着程序B尝试锁定字节2，但因为这个字节已经被程序A锁定，所以程序B也将在那里等待。</p>
<p>这种两个程序都无法继续执行下去的情况，就被称为死锁(deadlock或deadly embrace)。这个问题在数据库应用程序中很常见，当许多用户频繁访问同一个数据时就很容易发生死锁。大多数的商业关系型数据库都能够检测到死锁并自动解开，但Liux内核不行。这时就需要采取一些外部干涉手段，例如强制终止其中一个程序来解决这个问题。</p>
<p>程序员必须对这种情况提高警惕。当有多个程序都在等待获得锁时，你就需要非常小心地考虑是否会发生死锁。在本例中，死锁是非常容易避免的：两个程序只需要使用相同的顺序来锁定它们需要的字节或锁定一个更大的区域即可。</p>
<h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><h4 id="make和makefile"><a href="#make和makefile" class="headerlink" title="make和makefile"></a>make和makefile</h4><p>多个源文件带来的问题：对于一个含多个头文件的程序，假设只修改其中一个头文件，此时只影响局部包含该头文件的源文件，若希望仅重新编译该部分程序的文件，而不用将整个工程的文件重新编译，可以使用make工具解决该问题。</p>
<p>makefile文件：make命令内置了很多智能机制，但是需要根据工程编写一个makefile文件来告诉make去构造该工程应用程序的编译。</p>
<h5 id="makefile语法"><a href="#makefile语法" class="headerlink" title="makefile语法"></a>makefile语法</h5><p>makefile文件由一组<strong>依赖关系和规则</strong>构成。每个依赖关系由一个目标（即将要创建的文件）和一组该目标所依赖的源文件组成。而规则描述了如何通过这些依赖文件创建目标。一般来说，目标是一个单独的可执行文件。</p>
<p>make命令会读取makefile文件的内容，它先确定目标文件或要创建的文件，然后比较该目标所依赖的源文件的日期和时间以决定该采用哪条规则来构造目标。通常在创建最终的目标文件之前，它需要先创建一些中间目标。make命令会根据makefile文件来确定目标文件的创建顺序以及正确的规则调用顺序。</p>
<p>make程序本身有许多选项，其中最常用的3个选项如下所示。</p>
<ul>
<li>-k: 它的作用是让make命令在发现错误时仍然继续执行，而不是在检测到第一个错误时就停下来。你可以利用这个选项在一次操作中发现所有未编译成功的源文件。</li>
<li>-n: 它的作用是让make命令输出将要执行的操作步骤，而不真正执行这些操作。</li>
<li>-f <filename>: 它的作用是告诉make命令将哪个文件作为makefile文件。如果未使用这个选项，标准版本的make命令将首先在当前目录下查找名为makefile的文件，如果该文件不存在，它就会查找名为Makefilel的文件。<code>如果是在Linux系统中，使用的可能是GNU Make，这个版本的make命令将在搜索makefile文件和Makefile文件之前，首先查找名为GNUmakefilel的文件。按惯例，许多Linux程序员使用文件名Makefile，因为如果一个目录下都是以小写字母为名称的文件，则Makefi1e文件将在目录的文件列表中第一个出现。建议不要使用文件名GNUmakefile，因为它是特定于make命令的GNU实现的。</code></li>
</ul>
<p>为了指示make命令创建一个特定的目标（通常是一个可执行文件），你可以把该目标的名字作为make命令的一个参数。如果不这么做，make命令将试图创建列在makefile文件中的第一个目标。许多程序员都会在自己的makefile文件中将第一个目标定义为all，然后再列出其他从属目标。这个约定可以明确地告诉make命令，在未指定特定目标时，默认情况下应该创建哪个目标，建议坚持使用这一约定。</p>
<p><em><strong>1依赖关系</strong></em></p>
<p>依赖关系定义了最终应用程序里的每个文件与源文件之间的关系。在makefile文件中，这些规则的写法是：先写目标的名称，然后紧跟着一个冒号，接着是空格或制表符tab，最后是用空格或制表符tab隔开的文件列表（这些文件用于创建目标文件）。</p>
<p>例如下面的示例，表示目标myapp依赖于main.o、2.o和3.o，而main.o依赖于main.c和a.h，等等。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">myapp: main.o 2.o 3.o</span></span><br><span class="line"><span class="section">main.o: main.c a.h</span></span><br><span class="line"><span class="section">2.o: 2.c a.h b.h</span></span><br><span class="line"><span class="section">3.o: 3.c b.h c.h</span></span><br></pre></td></tr></table></figure>

<p>这组依赖关系形成一个层次结构，它显示了源文件之间的关系。可以很容易地看出，如果文件b.h发生改变，就需重新编译2.o和3.o，而由于2.o和3.o发生了改变，还需要重新创建目标myapp。</p>
<p>如果想一次创建多个文件，可以利用伪目标all。假设应用程序由二进制文件myapp和使用手册myapp.1组成。可以用下面这行语句进行定义：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: myapp myapp.1</span></span><br></pre></td></tr></table></figure>

<p>再次强调，如果未指定一个all目标，则make命令将只创建它在文件makefile中找到的第一个目标。</p>
<p><em><strong>2规则</strong></em></p>
<p>makefile文件的第二部分内容是规则，它们定义了目标的创建方式。</p>
<p>对于该部分，空格和制表符tab是有区别的。</p>
<ul>
<li>规则所在的行必须以制表符tab开头，用空格是不行的；</li>
<li>如果makefile文件中的某行以空格结尾，它也可能会导致make命令执行失败；</li>
<li>如果缺少了制表符tab，make命令就不会正常工作，所以发现这个错误很容易。</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">myapp: main.o 2.o 3.o</span></span><br><span class="line">	gcc -o myapp main.o 2.o 3.o</span><br><span class="line"><span class="section">main.o: main.c a.h</span></span><br><span class="line">	gcc -c main.c</span><br><span class="line"><span class="section">2.o: 2.c a.h b.h</span></span><br><span class="line">	gcc -c 2.c</span><br><span class="line"><span class="section">3.o: 3.c b.h c.h</span></span><br><span class="line">	gcc -c 3.c</span><br></pre></td></tr></table></figure>

<h5 id="makefile注释"><a href="#makefile注释" class="headerlink" title="makefile注释"></a>makefile注释</h5><p>makefile文件中的注释以#号开头，一直延续到这一行的结束。和C语言源文件中的注释一样。</p>
<h5 id="makefile的宏"><a href="#makefile的宏" class="headerlink" title="makefile的宏"></a>makefile的宏</h5><p><em><strong>问题 1</strong></em></p>
<p>对于管理包含非常多源文件的大型项目来说，按照上面的makefile构建会显得过于庞大并缺乏弹性。因此，makefile文件允许使用宏，以一种更通用的格式来书写它们。</p>
<ul>
<li>通过语句MACRONAME&#x3D;value在makefile文件中定义宏</li>
<li>引用宏的方法是使用$(MACRONAME)或${MACRONAME}。make的某些版本还接受$MACRONAME的用法。</li>
<li>如果想把一个宏的值设置为空，可以令等号(&#x3D;)后面留空。</li>
</ul>
<p><em><strong>问题 2</strong></em></p>
<p>Makefilel文件的另一问题是，它假设编译器的名字是gcc，而在其他UNIX系统中，编译器的名字可能是cc或c89。如果想将makefile文件移植到另一版本的UNIX系统中，或在现有系统中使用另一个编译器，为了使其工作，将不得不修改makefile文件中许多行的内容。宏是用来收集所有这些与系统相关内容的好方法，通过使用宏定义，可以方便地修改这些内容。</p>
<p>宏通常都是在makefile文件中定义的，但也可以在调用make命令时在命令行上给出宏定义，例如命令make CC&#x3D;c89。命令行上的宏定义将覆盖在makefile文件中的宏定义。当在makefile文件之外使用宏定义时，要注意宏定义必须以单个参数的形式传递，所以应避免在宏定义中使用空格或应像下面这样给宏定义加上引号：make “cc&#x3D;c89”。</p>
<p>示例：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: myapp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Which compiler</span></span><br><span class="line">CC = gcc</span><br><span class="line"></span><br><span class="line"><span class="comment">#Where are include files kept</span></span><br><span class="line">INCLUDE =</span><br><span class="line"></span><br><span class="line"><span class="comment">#Options for development</span></span><br><span class="line">CFLAGS = -g -Wall -ansi</span><br><span class="line"></span><br><span class="line"><span class="comment">#Options for release</span></span><br><span class="line"><span class="comment">#CFLAGS = -o -Wall -ansi</span></span><br><span class="line"></span><br><span class="line"><span class="section">myapp: main.o 2.o 3.o</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o myapp main.o 2.o 3.o</span><br><span class="line"><span class="section">main.o: main.c a.h</span></span><br><span class="line">	<span class="variable">$(CC)</span> -I <span class="variable">$(INCLUDE)</span> <span class="variable">$(CFLAGS)</span> -c main.c</span><br><span class="line"><span class="section">2.o: 2.c a.h b.h</span></span><br><span class="line">	<span class="variable">$(CC)</span> -I <span class="variable">$(INCLUDE)</span> <span class="variable">$(CFLAGS)</span> -c 2.c</span><br><span class="line"><span class="section">3.o: 3.c b.h c.h</span></span><br><span class="line">	<span class="variable">$(CC)</span> -I <span class="variable">$(INCLUDE)</span> <span class="variable">$(CFLAGS)</span> -c 3.c</span><br></pre></td></tr></table></figure>

<p>make命令内置了一些特殊的宏定义，通过使用它们，可以让makefile文件变得更加简洁：</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="《linux程序设计》阅读笔记/image-20220413204745198.png" alt="image-20220413204745198" style="zoom:67%;" />

<p>在makefi1e文件中，可能还会看到下面两个有用的特殊字符，它们出现在命令之前。</p>
<ul>
<li>-：告诉make命令忽略所有错误。例如，如果想创建一个目录，但又想忽略任何错误（比如目录已存在），就可以在mkdir命令的前面加上一个减号。</li>
<li>@: 告诉make在执行某条命令前不要将该命令显示在标准输出上。如果想用echo命令给出一些说明信息，这个字符将非常有用。</li>
</ul>
<h5 id="多个目标文件"><a href="#多个目标文件" class="headerlink" title="多个目标文件"></a>多个目标文件</h5><p>通常制作不止一个目标文件或者将多组命令集中到一个位置来执行是很有用的。可以通过扩展makefile文件来达到这一目的。</p>
<p>下面的例子中在makefile文件中增加一个clean选项来删除不需要的目标文件，增加一个install选项来将编译成功的应用程序安装到另一个目录下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: myapp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Which compiler</span></span><br><span class="line">CC = gcc</span><br><span class="line"></span><br><span class="line"><span class="comment">#####################################################################</span></span><br><span class="line"><span class="comment">#Where to install</span></span><br><span class="line">INSTDIR = /usr/local/bin</span><br><span class="line"><span class="comment">#####################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Where are include files kept</span></span><br><span class="line">INCLUDE =</span><br><span class="line"></span><br><span class="line"><span class="comment">#Options for development</span></span><br><span class="line">CFLAGS = -g -Wall -ansi</span><br><span class="line"></span><br><span class="line"><span class="comment">#Options for release</span></span><br><span class="line"><span class="comment">#CFLAGS = -o -Wall -ansi</span></span><br><span class="line"></span><br><span class="line"><span class="section">myapp: main.o 2.o 3.o</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o myapp main.o 2.o 3.o</span><br><span class="line"><span class="section">main.o: main.c a.h</span></span><br><span class="line">	<span class="variable">$(CC)</span> -I <span class="variable">$(INCLUDE)</span> <span class="variable">$(CFLAGS)</span> -c main.c</span><br><span class="line"><span class="section">2.o: 2.c a.h b.h</span></span><br><span class="line">	<span class="variable">$(CC)</span> -I <span class="variable">$(INCLUDE)</span> <span class="variable">$(CFLAGS)</span> -c 2.c</span><br><span class="line"><span class="section">3.o: 3.c b.h c.h</span></span><br><span class="line">	<span class="variable">$(CC)</span> -I <span class="variable">$(INCLUDE)</span> <span class="variable">$(CFLAGS)</span> -c 3.c</span><br><span class="line">	</span><br><span class="line"><span class="comment">#####################################################################</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	-rm main.o 2.o 3.o</span><br><span class="line"><span class="section">install: myapp</span></span><br><span class="line">	@if [ -d <span class="variable">$(INSTDIR)</span> ];	\</span><br><span class="line">		then	\</span><br><span class="line">		cp myapp <span class="variable">$(INSTDIR)</span>;	\</span><br><span class="line">		chmod a+x <span class="variable">$(INSTDIR)</span>/myapp;	\</span><br><span class="line">		chmod og-w <span class="variable">$(INSTDIR)</span>/myapp;	\</span><br><span class="line">		echo <span class="string">&quot;Installed in <span class="variable">$(INSTDIR)</span>&quot;</span>;	\</span><br><span class="line">		<span class="keyword">else</span>	\</span><br><span class="line">		echo <span class="string">&quot;Sorry, <span class="variable">$(INSTDIR)</span> does not exist&quot;</span>;	\</span><br><span class="line">	fi</span><br><span class="line"><span class="comment">##################################################################</span></span><br></pre></td></tr></table></figure>



<h5 id="内置规则"><a href="#内置规则" class="headerlink" title="内置规则"></a>内置规则</h5><p>事实上，make命令本身带有大量的内置规则，它们可以极大地简化makefile文件的内容，尤其在拥有许多源文件时更是如此。</p>
<h5 id="后缀和模式规则"><a href="#后缀和模式规则" class="headerlink" title="后缀和模式规则"></a>后缀和模式规则</h5><h5 id="用make管理函数库"><a href="#用make管理函数库" class="headerlink" title="用make管理函数库"></a>用make管理函数库</h5><p>对于大型项目，一种比较方便的做法是用函数库来管理多个编译产品。函数库实际上就是文件，它们通常以。a(a是英文archive的首字母)为后缀名，在该文件中包含了一组目标文件。make命令用一个特殊的语法来处理函数库，这使得函数库的管理工作变得非常容易。</p>
<p>用于管理函数库的语法是lib(file.o),它的含义是目标文件file.o是存储在函数库lib.a中的。make命令用一个内置规则来管理函数库，该规则的常见形式如下所示：</p>
<h5 id="makefile文件和子目录"><a href="#makefile文件和子目录" class="headerlink" title="makefile文件和子目录"></a>makefile文件和子目录</h5><p>对于大型的项目，有时希望能把构成一个函数库的几个文件从主文件中分离出来，并将它们保存到一个子目录中。使用make命令完成这一工作的方法有两个。</p>
<p>第一个方法是，可以在子目录中编写出第二个makefile文件，它的作用是编译该子目录下的源文件，并将它们保存到一个函数库中，然后将该库文件复制到上一级的主目录中。在主目录中的makefile文件包含一条用于制作函数库的规则，该规则会调用第二个makefile.文件，如下所示：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mylib.a:</span></span><br><span class="line">	(cd mylibdirectory;<span class="variable">$(MAKE)</span>)</span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>这就是说，你必须总是执行命令make mylib.a。当make命令调用这条规则来创建函数库时，它将切换到子目录mylibdirectory中，然后调用一个新的make命令来管理函数库。由于make会针对每个命令调用一个新的shell,而使用第二个makefile文件的make命令本身又并没有执行cd命令，但它又必须在一个不同的目录下创建函数库，为解决这一问题，我们用括号将这两个命令括起来，从而确保它们只被一个单独的shell处理。</p>
<p>第二个方法是，在原来的makefile文件中添加一些宏。新添加的宏通过在我们己见过的宏的尾部追加一个字母得到，字母D代表目录，字母F代表文件名。然后你就可以用下面的规则来替换内置的.c.o后缀规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">.c.o:</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c $(@D) /$(&lt;F) -o $(@D)/$(@F)</span><br></pre></td></tr></table></figure>

<p>这条规则的作用是：编译子目录中的源文件并将目标文件放在该子目录中。然后，你用如下的依赖关系和规则来更新当前目录下的函数库：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mylib.a: mydir/2.o mydir/3.o</span></span><br><span class="line">	ar -rv mylib.a <span class="variable">$?</span></span><br></pre></td></tr></table></figure>

<h5 id="GNU-make和gcc"><a href="#GNU-make和gcc" class="headerlink" title="GNU make和gcc"></a>GNU make和gcc</h5>
<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2024/02/27/%E5%A5%A5%E6%AF%94%E4%B8%AD%E5%85%89Femto-Bolt%E7%9B%B8%E6%9C%BA%E8%AF%B4%E6%98%8E/">奥比中光Femto Bolt相机</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2024/02/26/linux-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/">linux-基础命令使用</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">baimin</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.26.8">Stellar 1.26.8</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
<div class="main-mask" onclick="sidebar.toggle()"></div></div></div><div class="scripts">
<script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.26.8';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.26.8';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"codeblock":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js","memos":"/js/plugins/memos.js","marked":"/js/plugins/marked.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.8.4/lazyload.min.js","transition":"fade"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@10.3/swiper-bundle.min.css","js":"https://unpkg.com/swiper@10.3/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://cdn.bootcdn.net/ajax/libs/scrollReveal.js/4.0.9/scrollreveal.min.js","distance":"16px","duration":800,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","flying_pages":"https://cdn.bootcdn.net/ajax/libs/flying-pages/2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.umd.min.js","css":"https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.min.css","selector":null});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied","toast":"复制成功"});
  }
</script>

<!-- required -->
<script src="/js/main.js?v=1.26.8" async></script>

<!-- optional -->






<!-- inject -->

</div></body></html>
