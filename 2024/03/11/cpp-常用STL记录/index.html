
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.26.8" theme-name="Stellar" theme-version="1.26.8">
  
  <meta name="generator" content="Hexo 7.1.1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>cpp常用STL记录 - Blog</title>

  
    <meta name="description" content="概述参考：https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;582795495 C++ STL是C++标准库的一部分，不等于C++标准库。 C++ 标准库C++ 标准库可以分为两部分：  标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。 面向对象类库： 这个库是类及其相关函数的集合。  标准函数库标准函数库分为以下几类：  输入&#x2F;输出 I">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp常用STL记录">
<meta property="og:url" content="http://example.com/2024/03/11/cpp-%E5%B8%B8%E7%94%A8STL%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="概述参考：https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;582795495 C++ STL是C++标准库的一部分，不等于C++标准库。 C++ 标准库C++ 标准库可以分为两部分：  标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。 面向对象类库： 这个库是类及其相关函数的集合。  标准函数库标准函数库分为以下几类：  输入&#x2F;输出 I">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/03/11/cpp-%E5%B8%B8%E7%94%A8STL%E8%AE%B0%E5%BD%95/v2-42e902c425fdcdb4d0490edb8a35fa45_720w.webp">
<meta property="article:published_time" content="2024-03-11T11:06:13.000Z">
<meta property="article:modified_time" content="2024-03-18T02:03:53.516Z">
<meta property="article:author" content="baimin">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/03/11/cpp-%E5%B8%B8%E7%94%A8STL%E8%AE%B0%E5%BD%95/v2-42e902c425fdcdb4d0490edb8a35fa45_720w.webp">
  
  
  
  <meta name="keywords" content="C++">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.26.8">

  
    <link rel="shortcut icon" href="https://www.bing.com/images/search?view=detailV2&ccid=NBTs1th0&id=8DD1BA6653D365AD9ED73A5DDABEB32BB98F5D43&thid=OIP.NBTs1th0_7FYxpGGQJ-IDAAAAA&mediaurl=https%3a%2f%2fimg.ixintu.com%2fdownload%2fjpg%2f202001%2f3fcd67ac5c089ae3a8f72fd2b3508c93.jpg!ys&exph=250&expw=250&q=%e5%8d%9a%e5%ae%a2icon&simid=607990421440448215&FORM=IRPRST&ck=1141C8513F997CB92989E285F56C3350&selectedIndex=22&itb=0">
  

  

  
  
</head>
<body>

<div class="l_body content tech" id="start" layout="post" ><aside class="l_left"><div class="sidebar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="{config.avatar}" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">Blog</div><div class="sub normal cap">Thousand的日常记录</div><div class="sub hover cap" style="opacity:0"> Thousand's Daily</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"><a class="nav-item" title="undefined" href="/" style="color:1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="undefined" href="/" style="color:1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="undefined" href="/" style="color:1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="undefined" href="/" style="color:1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a></nav>
</div>
<div class="widgets">

<widget class="widget-wrapper toc single" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93"><span class="toc-text">C++ 标准库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E5%BA%93"><span class="toc-text">标准函数库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%BA%93"><span class="toc-text">面向对象类库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93"><span class="toc-text">STL 标准模板库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E5%AE%B9%E5%99%A8"><span class="toc-text">STL容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E"><span class="toc-text">说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%80%A7%E5%AE%B9%E5%99%A8"><span class="toc-text">顺序性容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vector"><span class="toc-text">vector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque"><span class="toc-text">deque</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list"><span class="toc-text">list</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-text">关联式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#set-multiset"><span class="toc-text">set&#x2F;multiset</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-multimap"><span class="toc-text">map&#x2F;multimap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text">STL容器适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pair"><span class="toc-text">pair</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stack"><span class="toc-text">stack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue-priority-queue"><span class="toc-text">queue &amp; priority_queue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E4%B8%B2"><span class="toc-text">string串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unordered%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">unordered哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ListNode%E7%BA%BF%E6%80%A7%E9%93%BE%E8%A1%A8"><span class="toc-text">ListNode线性链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bitset%E4%BD%8D%E5%BA%8F%E5%88%97"><span class="toc-text">bitset位序列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">STL迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E7%AE%97%E6%B3%95"><span class="toc-text">STL算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-text">常用函数</span></a></li></ol></li></ol></div></div></widget>

<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">专栏：thousand</span></div><div class="widget-body"><a class="item active" href="/2024/03/11/cpp-%E5%B8%B8%E7%94%A8STL%E8%AE%B0%E5%BD%95/"><span class="title">cpp常用STL记录</span><svg class="active-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M21 11.098v4.993c0 3.096 0 4.645-.734 5.321c-.35.323-.792.526-1.263.58c-.987.113-2.14-.907-4.445-2.946c-1.02-.901-1.529-1.352-2.118-1.47a2.225 2.225 0 0 0-.88 0c-.59.118-1.099.569-2.118 1.47c-2.305 2.039-3.458 3.059-4.445 2.945a2.238 2.238 0 0 1-1.263-.579C3 20.736 3 19.188 3 16.091v-4.994C3 6.81 3 4.666 4.318 3.333C5.636 2 7.758 2 12 2c4.243 0 6.364 0 7.682 1.332C21 4.665 21 6.81 21 11.098" opacity=".5"/><path fill="currentColor" d="M9 5.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5z"/></svg></a></div></widget>





<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2024/03/03/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E4%BC%A0%E7%BB%9F%E5%88%86%E5%89%B2%E6%96%B9%E6%B3%95/"><span class="title">数字图像传统分割方法</span></a><a class="item title" href="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="title">数据结构与算法</span></a><a class="item title" href="/2024/03/18/%E5%AD%98%E5%82%A8%E5%99%A8%E5%8C%BA%E5%88%AB-ROM%E3%80%81RAM%E3%80%81FLASH%E3%80%81DDR%E7%AD%89/"><span class="title">存储器区别(ROM、RAM、FLASH、DDR等)</span></a><a class="item title" href="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/"><span class="title">linux-全志V3s移植uboot kernel rootfile记录</span></a><a class="item title active" href="/2024/03/11/cpp-%E5%B8%B8%E7%94%A8STL%E8%AE%B0%E5%BD%95/"><span class="title">cpp常用STL记录</span><svg class="active-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M21 11.098v4.993c0 3.096 0 4.645-.734 5.321c-.35.323-.792.526-1.263.58c-.987.113-2.14-.907-4.445-2.946c-1.02-.901-1.529-1.352-2.118-1.47a2.225 2.225 0 0 0-.88 0c-.59.118-1.099.569-2.118 1.47c-2.305 2.039-3.458 3.059-4.445 2.945a2.238 2.238 0 0 1-1.263-.579C3 20.736 3 19.188 3 16.091v-4.994C3 6.81 3 4.666 4.318 3.333C5.636 2 7.758 2 12 2c4.243 0 6.364 0 7.682 1.332C21 4.665 21 6.81 21 11.098" opacity=".5"/><path fill="currentColor" d="M9 5.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5z"/></svg></a><a class="item title" href="/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/"><span class="title">linux-应用编程</span></a><a class="item title" href="/2024/03/12/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"><span class="title">ARM体系结构</span></a><a class="item title" href="/2024/02/26/linux-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"><span class="title">linux-基础命令使用</span></a><a class="item title" href="/2024/03/08/C%E8%AF%AD%E8%A8%80-%E5%9F%BA%E7%A1%80/"><span class="title">C语言基础</span></a><a class="item title" href="/2024/03/02/%E4%BB%A3%E7%A0%81%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"><span class="title">代码命名规范</span></a></div></widget>
</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/social/08a41b181ce68.svg"/></a><a class="social" href="https://" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/social/3845874.svg"/></a><a class="social" href="https://" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/social/3616429.svg"/></a><a class="social" href="https://" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/placeholder/social/942ebbf1a4b91.svg"/></a></div></footer>
</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    
<div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" id="menu" href="/topic">专栏</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/2024/03/11/cpp-%E5%B8%B8%E7%94%A8STL%E8%AE%B0%E5%BD%95/">thousand</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2024-03-11T11:06:13.000Z">2024-03-11</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2024-03-18T02:03:53.516Z">2024-03-18</time></span></div></div>
</div>

    
    <div class="bottom">
      <div class="text-area">
        <h1 class="text title"><span>cpp常用STL记录</span></h1>
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/582795495">https://zhuanlan.zhihu.com/p/582795495</a></p>
<p><u>C++ STL是C++标准库的一部分，不等于C++标准库。</u></p>
<h3 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ 标准库</h3><p>C++ 标准库可以分为两部分：</p>
<ul>
<li><strong>标准函数库：</strong> 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库<u>继承自 C 语言</u>。</li>
<li><strong>面向对象类库：</strong> 这个库是类及其相关函数的集合。</li>
</ul>
<h4 id="标准函数库"><a href="#标准函数库" class="headerlink" title="标准函数库"></a>标准函数库</h4><p>标准函数库分为以下几类：</p>
<ul>
<li>输入&#x2F;输出 I&#x2F;O</li>
<li>字符串和字符处理</li>
<li>数学</li>
<li>时间、日期和本地化</li>
<li>动态分配</li>
<li>其他</li>
<li>宽字符函数</li>
</ul>
<h4 id="面向对象类库"><a href="#面向对象类库" class="headerlink" title="面向对象类库"></a>面向对象类库</h4><p>标准的 C++ 面向对象类库定义了大量支持一些常见操作的类，比如输入&#x2F;输出 I&#x2F;O、字符串处理、数值处理。面向对象类库包含以下内容：</p>
<ul>
<li>标准的 C++ I&#x2F;O 类</li>
<li>String 类</li>
<li>数值类</li>
<li><strong>STL 容器类</strong></li>
<li><strong>STL 算法</strong></li>
<li><strong>STL 函数对象</strong></li>
<li><strong>STL 迭代器</strong></li>
<li><strong>STL 分配器</strong></li>
<li>本地化库</li>
<li>异常处理类</li>
<li>杂项支持库</li>
</ul>
<h3 id="STL-标准模板库"><a href="#STL-标准模板库" class="headerlink" title="STL 标准模板库"></a>STL 标准模板库</h3><p>STL (Standard Template Library)，即标准模板库，是一个具有工业强度的，高效的C++程序库。</p>
<p>C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。</p>
<p>C++ 标准模板库的核心包括以下三个组件：</p>
<table>
<thead>
<tr>
<th align="left">组件</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">容器（Containers）</td>
<td align="left">一种<strong>数据结构</strong>，容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。</td>
</tr>
<tr>
<td align="left">算法（Algorithms）</td>
<td align="left">它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。</td>
</tr>
<tr>
<td align="left">迭代器（iterators）</td>
<td align="left">迭代器用于遍历对象集合的元素，提供了访问容器中对象的方法。</td>
</tr>
</tbody></table>
<p>除此之外，还有仿函数（Functor）、适配器（Adaptor）、分配器（allocator）。</p>
<h2 id="STL容器"><a href="#STL容器" class="headerlink" title="STL容器"></a>STL容器</h2><p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/564057584">https://zhuanlan.zhihu.com/p/564057584</a></p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>STL中的容器有顺序性容器、关联容器、容器适配器。容器类<u>自动申请和释放内存</u>，无需new和delete操作。</p>
<p><strong>（1）顺序性容器（Sequence containers）</strong></p>
<p>每个元素都有固定位置，取决于插入时机和地点，和元素值无关，vector、deque、list；</p>
<p>Vector：将元素置于一个<u>动态数组</u>中加以管理，可以随机存取元素（用索引直接存取），数组尾部添加或移除元素非常快速，但是在中部或头部安插元素比较费时；</p>
<p>Deque：是“double-ended queue”的缩写，可以随机存取元素（用索引直接存取），数组头部和尾部添加或移除元素都非常快速，但是在中部或头部安插元素比较费时；</p>
<p>List：双向链表，不提供随机存取（按顺序走到需存取的元素，O(n)），在任何位置上执行插入或删除动作都非常迅速，内部只需调整一下指针；</p>
<table>
<thead>
<tr>
<th>容器</th>
<th>简介说明</th>
</tr>
</thead>
<tbody><tr>
<td>vector</td>
<td>可变大小数组。相当于数组，可动态构建，支持随机访问，无头插和尾插，仅支持inset插入，除尾部外的元素删除比较麻烦。但使用最为广泛</td>
</tr>
<tr>
<td>deque</td>
<td>双端队列。支持头插、删，尾插、删，随机访问较vector容器来说慢,但对于首尾的数据操作比较方便</td>
</tr>
<tr>
<td>list</td>
<td>双向循环链表。使用起来很高效，对于任意位置的插入和删除都很快，在操作过后，以后指针、迭代器、引用都不会失效</td>
</tr>
<tr>
<td>forward_list</td>
<td>单向链表。只支持单向访问，在链表的任何位置进行插入&#x2F;删除操作都非常快</td>
</tr>
<tr>
<td>array</td>
<td>固定数组。vector的底层即为array数组，它保存了一个以严格顺序排列的特定数量的元素</td>
</tr>
</tbody></table>
<p><strong>（2）关联式容器（Associated containers）</strong></p>
<p>元素位置取决于特定的排序准则，和插入顺序无关，set、multiset、map、multimap等。</p>
<p>Set&#x2F;Multiset：内部的元素依据其值自动排序，Set内的相同数值的元素只能出现一次，Multisets内可包含多个数值相同的元素，内部由二叉树实现，便于查找；</p>
<p>Map&#x2F;Multimap：Map的元素是成对的键值&#x2F;实值，内部的元素依据其值自动排序，Map内的相同数值的元素只能出现一次，Multimaps内可包含多个数值相同的元素，内部由二叉树实现，便于查找；</p>
<table>
<thead>
<tr>
<th>容器</th>
<th>简介说明</th>
</tr>
</thead>
<tbody><tr>
<td>set&#x2F;mutliset</td>
<td>集合&#x2F;多重集合。对于set，在使用insert插入元素时，已插入过的元素不可重复插入，这正好符合了集合的互异性，在插入完成显示后，会默认按照升序进行排序，对于multiset，可插入多个重复的元素</td>
</tr>
<tr>
<td>map&#x2F;mutlimap</td>
<td>映射&#x2F;多重映射。二者均为二元关联容器（在构造时需要写两个参数类型，前者对key值，后者对应value值），因为有两个参数，因此在插入元素的时候需要配合对组pair进行插入，具体见深入详解</td>
</tr>
</tbody></table>
<p><strong>（3）容器适配器（Congtainer adapters）</strong></p>
<table>
<thead>
<tr>
<th>容器</th>
<th>简介说明</th>
</tr>
</thead>
<tbody><tr>
<td>stack</td>
<td>堆栈。其原理是先进后出（FILO），其底层容器可以是任何标准的容器适配器，默认为deque双端队列</td>
</tr>
<tr>
<td>queue</td>
<td>队列。其原理是先进先出（FIFO），只有队头和队尾可以被访问，故不可有遍历行为，默认也为deque双端队列</td>
</tr>
<tr>
<td>pirority_queue</td>
<td>优先队列。它的第一个元素总是它所包含的元素中优先级最高的，就像数据结构里的<strong>堆</strong>，会默认形成大堆，还可以使用仿函数来控制生成大根堆还是生成小根堆，若没定义，默认使用vector容器</td>
</tr>
</tbody></table>
<ul>
<li>对于 stack 堆栈，在我们日常生活中类似于坐地铁、电梯；</li>
<li>对于 deque 队列，在我们日常生活中类似于排队打饭；</li>
<li>对于 pirority_queue，因为其本质是<strong>堆</strong>，可以考虑解决一些贪心问题；</li>
</ul>
<h3 id="顺序性容器"><a href="#顺序性容器" class="headerlink" title="顺序性容器"></a>顺序性容器</h3><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt; vector&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">1.构造函数</span><br><span class="line"></span><br><span class="line">vector():创建一个空vector</span><br><span class="line">vector(int nSize):创建一个vector,元素个数为nSize</span><br><span class="line">vector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为t</span><br><span class="line">vector(const vector&amp;):复制构造函数</span><br><span class="line">vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中</span><br><span class="line">2.增加函数</span><br><span class="line"></span><br><span class="line">void push_back(const T&amp; x):向量尾部增加一个元素X</span><br><span class="line">iterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素x</span><br><span class="line">iterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素x</span><br><span class="line">iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</span><br><span class="line">3.删除函数</span><br><span class="line"></span><br><span class="line">iterator erase(iterator it):删除向量中迭代器指向元素</span><br><span class="line">iterator erase(iterator first,iterator last):删除向量中[first,last)中元素</span><br><span class="line">void pop_back():删除向量中最后一个元素</span><br><span class="line">void clear():清空向量中所有元素</span><br><span class="line">4.遍历函数</span><br><span class="line"></span><br><span class="line">reference at(int pos):返回pos位置元素的引用</span><br><span class="line">reference front():返回首元素的引用</span><br><span class="line">reference back():返回尾元素的引用</span><br><span class="line">iterator begin():返回向量头指针，指向第一个元素</span><br><span class="line">iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置</span><br><span class="line">reverse_iterator rbegin():反向迭代器，指向最后一个元素</span><br><span class="line">reverse_iterator rend():反向迭代器，指向第一个元素之前的位置</span><br><span class="line">5.判断函数</span><br><span class="line"></span><br><span class="line">bool empty() const:判断向量是否为空，若为空，则向量中无元素</span><br><span class="line">6.大小函数</span><br><span class="line"></span><br><span class="line">int size() const:返回向量中元素的个数</span><br><span class="line">int capacity() const:返回当前向量张红所能容纳的最大元素值</span><br><span class="line">int max_size() const:返回最大可允许的vector元素数量值</span><br><span class="line">7.其他函数</span><br><span class="line"></span><br><span class="line">void swap(vector&amp;):交换两个同类型向量的数据</span><br><span class="line">void assign(int n,const T&amp; x):设置向量中第n个元素的值为x</span><br><span class="line">void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素</span><br></pre></td></tr></table></figure>

<p><strong>二维数组两种定义方法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N=<span class="number">5</span>, M=<span class="number">6</span>; </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">obj</span>(N); <span class="comment">//定义二维动态数组大小5行 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt; obj.<span class="built_in">size</span>(); i++)<span class="comment">//动态二维数组为5行6列，值全为0 </span></span><br><span class="line">    &#123; </span><br><span class="line">        obj[i].<span class="built_in">resize</span>(M); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; obj.<span class="built_in">size</span>(); i++)<span class="comment">//输出二维动态数组 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;obj[i].<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;obj[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N=<span class="number">5</span>, M=<span class="number">6</span>; </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">obj</span>(N, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(M)); <span class="comment">//定义二维动态数组5行6列 </span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; obj.<span class="built_in">size</span>(); i++)<span class="comment">//输出二维动态数组 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;obj[i].<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;obj[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span>  <span class="comment">// 头文件</span></span></span><br><span class="line"></span><br><span class="line">deque&lt;type&gt; deq;  <span class="comment">// 声明一个元素类型为type的双端队列que</span></span><br><span class="line"><span class="function">deque&lt;type&gt; <span class="title">deq</span><span class="params">(size)</span></span>;  <span class="comment">// 声明一个类型为type、含有size个默认值初始化元素的的双端队列que</span></span><br><span class="line"><span class="function">deque&lt;type&gt; <span class="title">deq</span><span class="params">(size, value)</span></span>;  <span class="comment">// 声明一个元素类型为type、含有size个value元素的双端队列que</span></span><br><span class="line"><span class="function">deque&lt;type&gt; <span class="title">deq</span><span class="params">(mydeque)</span></span>;  <span class="comment">// deq是mydeque的一个副本</span></span><br><span class="line"><span class="function">deque&lt;type&gt; <span class="title">deq</span><span class="params">(first, last)</span></span>;  <span class="comment">// 使用迭代器first、last范围内的元素初始化deq</span></span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; deq;</span><br><span class="line"></span><br><span class="line">deq[ ]：用来访问双向队列中单个的元素。</span><br><span class="line">deq.<span class="built_in">front</span>()：返回第一个元素的引用。</span><br><span class="line">deq.<span class="built_in">back</span>()：返回最后一个元素的引用。</span><br><span class="line">deq.<span class="built_in">push_front</span>(x)：把元素x插入到双向队列的头部。</span><br><span class="line">deq.<span class="built_in">pop_front</span>()：弹出双向队列的第一个元素。</span><br><span class="line">deq.<span class="built_in">push_back</span>(x)：把元素x插入到双向队列的尾部。</span><br><span class="line">deq.<span class="built_in">pop_back</span>()：弹出双向队列的最后一个元素。</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ol>
<li>支持随机访问，即支持[ ]以及at()，但是性能没有vector好。</li>
<li>可以在内部进行插入和删除操作，但性能不及list。</li>
<li>deque两端都能够快速插入和删除元素，而vector只能在尾端进行。</li>
<li>deque的元素存取和迭代器操作会稍微慢一些，因为deque的内部结构会多一个间接过程。</li>
<li>deque迭代器是特殊的智能指针，而不是一般指针，它需要在不同的区块之间跳转。</li>
<li>deque可以包含更多的元素，其max_size可能更大，因为不止使用一块内存。</li>
<li>deque不支持对容量和内存分配时机的控制。</li>
<li>在除了首尾两端的其他地方插入和删除元素，都将会导致指向deque元素的任何pointers、references、iterators失效。不过，deque的内存重分配优于vector，因为其内部结构显示不需要复制所有元素。</li>
<li>deque的内存区块不再被使用时，会被释放，deque的内存大小是可缩减的。不过，是不是这么做以及怎么做由实际操作版本定义。</li>
<li><u>deque不提供容量操作：capacity()和reverse()，但是vector可以</u>。</li>
</ol>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//list定义和初始化</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;lst1; <span class="comment">//创建空list</span></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">lst2</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">//创建含有5个元素的list</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;<span class="built_in">lst3</span>(<span class="number">3</span>,<span class="number">2</span>); <span class="comment">//创建含有3个元素的list</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;<span class="built_in">lst4</span>(lst2); <span class="comment">//使用lst2初始化lst4</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;<span class="built_in">lst5</span>(lst2.<span class="built_in">begin</span>(),lst2.<span class="built_in">end</span>()); <span class="comment">//同lst4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//list常用操作函数</span></span><br><span class="line">Lst1.<span class="built_in">assign</span>() 给list赋值</span><br><span class="line">Lst1.<span class="built_in">back</span>() 返回最后一个元素</span><br><span class="line">Lst1.<span class="built_in">begin</span>() 返回指向第一个元素的迭代器</span><br><span class="line">Lst1.<span class="built_in">clear</span>() 删除所有元素</span><br><span class="line">Lst1.<span class="built_in">empty</span>() 如果list是空的则返回<span class="literal">true</span></span><br><span class="line">Lst1.<span class="built_in">end</span>() 返回末尾的迭代器</span><br><span class="line">Lst1.<span class="built_in">erase</span>() 删除一个元素</span><br><span class="line">Lst1.<span class="built_in">front</span>() 返回第一个元素</span><br><span class="line">Lst1.<span class="built_in">get_allocator</span>() 返回list的配置器</span><br><span class="line">Lst1.<span class="built_in">insert</span>() 插入一个元素到list中</span><br><span class="line">Lst1.<span class="built_in">max_size</span>() 返回list能容纳的最大元素数量</span><br><span class="line">Lst1.<span class="built_in">merge</span>() 合并两个list</span><br><span class="line">Lst1.<span class="built_in">pop_back</span>() 删除最后一个元素</span><br><span class="line">Lst1.<span class="built_in">pop_front</span>() 删除第一个元素</span><br><span class="line">Lst1.<span class="built_in">push_back</span>() 在list的末尾添加一个元素</span><br><span class="line">Lst1.<span class="built_in">push_front</span>() 在list的头部添加一个元素</span><br><span class="line">Lst1.<span class="built_in">rbegin</span>() 返回指向第一个元素的逆向迭代器</span><br><span class="line">Lst1.<span class="built_in">remove</span>() 从list删除元素</span><br><span class="line">Lst1.<span class="built_in">remove_if</span>() 按指定条件删除元素</span><br><span class="line">Lst1.<span class="built_in">rend</span>() 指向list末尾的逆向迭代器</span><br><span class="line">Lst1.<span class="built_in">resize</span>() 改变list的大小</span><br><span class="line">Lst1.<span class="built_in">reverse</span>() 把list的元素倒转</span><br><span class="line">Lst1.<span class="built_in">size</span>() 返回list中的元素个数</span><br><span class="line">Lst1.<span class="built_in">sort</span>() 给list排序</span><br><span class="line">Lst1.<span class="built_in">splice</span>() 合并两个list</span><br><span class="line">Lst1.<span class="built_in">swap</span>() 交换两个list</span><br><span class="line">Lst1.<span class="built_in">unique</span>() 删除list中相邻重复的元素</span><br></pre></td></tr></table></figure>



<h3 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h3><h4 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set&#x2F;multiset"></a>set&#x2F;multiset</h4><p>set中的元素即是键值又是实值，set不允许两个元素有相同的键值。不能通过set的迭代器去修改set元素，原因是修改元素会破坏set组织。当对容器中的元素进行插入或者删除时，操作之前的所有迭代器在操作之后依然有效。</p>
<p>set元素是排好序的，且默认为升序.</p>
<p><strong>set常用成员函数</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1. begin()--返回指向第一个元素的迭代器</span><br><span class="line">2. clear()--清除所有元素</span><br><span class="line">3. count()--返回某个值元素的个数</span><br><span class="line">4. empty()--如果集合为空，返回true</span><br><span class="line">5. end()--返回指向最后一个元素的迭代器</span><br><span class="line">6. equal_range()--返回集合中与给定值相等的上下限的两个迭代器</span><br><span class="line">7. erase()--删除集合中的元素</span><br><span class="line">8. find()--返回一个指向被查找到元素的迭代器</span><br><span class="line">9. get_allocator()--返回集合的分配器</span><br><span class="line">10. insert()--在集合中插入元素</span><br><span class="line">11. lower_bound()--返回指向大于（或等于）某值的第一个元素的迭代器</span><br><span class="line">12. key_comp()--返回一个用于元素间值比较的函数</span><br><span class="line">13. max_size()--返回集合能容纳的元素的最大限值</span><br><span class="line">14. rbegin()--返回指向集合中最后一个元素的反向迭代器</span><br><span class="line">15. rend()--返回指向集合中第一个元素的反向迭代器</span><br><span class="line">16. size()--集合中元素的数目</span><br><span class="line">17. swap()--交换两个集合变量</span><br><span class="line">18. upper_bound()--返回大于某个值元素的迭代器</span><br><span class="line">19. value_comp()--返回一个用于比较元素间的值的函数</span><br></pre></td></tr></table></figure>







<h4 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map&#x2F;multimap"></a>map&#x2F;multimap</h4><p>map和multimap都需要#include<map>，唯一的不同是，map的键值key不可重复，而multimap可以，也正是由于这种区别，map支持[ ]运算符，multimap不支持[ ]运算符，在用法上没什么区别。</p>
<p>map中的元素是自动按Key升序排序，所以不能对map用sort函数；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"> </span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; ID_Name;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用&#123;&#125;赋值是从c++11开始的，因此编译器版本过低时会报错，如visual studio 2012</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; ID_Name = &#123;</span><br><span class="line">                &#123; <span class="number">2015</span>, <span class="string">&quot;Jim&quot;</span> &#125;,</span><br><span class="line">                &#123; <span class="number">2016</span>, <span class="string">&quot;Tom&quot;</span> &#125;,</span><br><span class="line">                &#123; <span class="number">2017</span>, <span class="string">&quot;Bob&quot;</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基本操作函数</span></span><br><span class="line"><span class="built_in">begin</span>() 返回指向map头部的迭代器</span><br><span class="line"><span class="built_in">clear</span>(） 删除所有元素</span><br><span class="line"><span class="built_in">count</span>() 返回指定元素出现的次数</span><br><span class="line"><span class="built_in">empty</span>() 如果map为空则返回<span class="literal">true</span></span><br><span class="line"><span class="built_in">end</span>() 返回指向map末尾的迭代器</span><br><span class="line"><span class="built_in">equal_range</span>() 返回特殊条目的迭代器对</span><br><span class="line"><span class="built_in">erase</span>() 删除一个元素</span><br><span class="line"><span class="built_in">find</span>() 查找一个元素</span><br><span class="line"><span class="built_in">get_allocator</span>() 返回map的配置器</span><br><span class="line"><span class="built_in">insert</span>() 插入元素</span><br><span class="line"><span class="built_in">key_comp</span>() 返回比较元素key的函数</span><br><span class="line"><span class="built_in">lower_bound</span>() 返回键值&gt;=给定元素的第一个位置</span><br><span class="line"><span class="built_in">max_size</span>() 返回可以容纳的最大元素个数</span><br><span class="line"><span class="built_in">rbegin</span>() 返回一个指向map尾部的逆向迭代器</span><br><span class="line"><span class="built_in">rend</span>() 返回一个指向map头部的逆向迭代器</span><br><span class="line"><span class="built_in">size</span>() 返回map中元素的个数</span><br><span class="line"><span class="built_in">swap</span>() 交换两个map</span><br><span class="line"><span class="built_in">upper_bound</span>() 返回键值&gt;给定元素的第一个位置</span><br><span class="line"><span class="built_in">value_comp</span>() 返回比较元素value的函数</span><br></pre></td></tr></table></figure>

<p><strong>用insert插入pair数据</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//数据的插入--第一种：用insert函数插入pair数据  </span><br><span class="line">#include &lt;map&gt;    </span><br><span class="line">#include &lt;string&gt;  </span><br><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">  </span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    map&lt;int, string&gt; mapStudent;  </span><br><span class="line">    mapStudent.insert(pair&lt;int, string&gt;(1, &quot;student_one&quot;));  </span><br><span class="line">    mapStudent.insert(pair&lt;int, string&gt;(2, &quot;student_two&quot;));  </span><br><span class="line">    mapStudent.insert(pair&lt;int, string&gt;(3, &quot;student_three&quot;));  </span><br><span class="line">    map&lt;int, string&gt;::iterator iter;  </span><br><span class="line">    for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)  </span><br><span class="line">       cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>用insert函数插入value_type数据</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//第二种：用insert函数插入value_type数据，下面举例说明  </span><br><span class="line">  </span><br><span class="line">#include &lt;map&gt;    </span><br><span class="line">#include &lt;string&gt;    </span><br><span class="line">#include &lt;iostream&gt;    </span><br><span class="line">using namespace std;  </span><br><span class="line">  </span><br><span class="line">int main()    </span><br><span class="line">&#123;    </span><br><span class="line">    map&lt;int, string&gt; mapStudent;    </span><br><span class="line">    mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;));    </span><br><span class="line">    mapStudent.insert(map&lt;int, string&gt;::value_type (2, &quot;student_two&quot;));    </span><br><span class="line">    mapStudent.insert(map&lt;int, string&gt;::value_type (3, &quot;student_three&quot;));    </span><br><span class="line">    map&lt;int, string&gt;::iterator iter;    </span><br><span class="line">    for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)  </span><br><span class="line">         cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl;    </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>用数组方式插入数据</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//第三种：用数组方式插入数据，下面举例说明  </span><br><span class="line">  </span><br><span class="line">#include &lt;map&gt;    </span><br><span class="line">#include &lt;string&gt;    </span><br><span class="line">#include &lt;iostream&gt;    </span><br><span class="line">using namespace std;  </span><br><span class="line">  </span><br><span class="line">int main()    </span><br><span class="line">&#123;    </span><br><span class="line">    map&lt;int, string&gt; mapStudent;    </span><br><span class="line">    mapStudent[1] = &quot;student_one&quot;;   </span><br><span class="line">    mapStudent[2] = &quot;student_two&quot;;    </span><br><span class="line">    mapStudent[3] = &quot;student_three&quot;;    </span><br><span class="line">    map&lt;int, string&gt;::iterator iter;    </span><br><span class="line">    for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)    </span><br><span class="line">        cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl;    </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是插入数据不了的，但是用数组方式就不同了，它可以覆盖以前该关键字对应的值.</p>
<h3 id="STL容器适配器"><a href="#STL容器适配器" class="headerlink" title="STL容器适配器"></a>STL容器适配器</h3><p>适配器：是使一种事物的行为类似于另外一种事物行为的一种机制”，适配器对容器进行包装，使其表现出另外一种行为。例 如，stack&lt;int, vector<int> &gt;实现了栈的功能，但其内部使用顺序容器vector<int>来存储数据。（相当于是vector<int>表现出 了栈的行为）。</p>
<p>标准库提供了三种顺序容器适配器：queue(FIFO队列)、priority_queue(优先级队列)、stack(栈)</p>
<style>.flgsdxbiiepn{zoom:67%;}</style><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/2024/03/11/cpp-%E5%B8%B8%E7%94%A8STL%E8%AE%B0%E5%BD%95/v2-42e902c425fdcdb4d0490edb8a35fa45_720w.webp" class="flgsdxbiiepn lazy" alt="img">

<p>要使用适配器，需要加入一下头文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span> <span class="comment">//stack</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span> <span class="comment">//queue、priority_queue</span></span></span><br></pre></td></tr></table></figure>

<h4 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h4><blockquote>
<p>小技巧：使用typedef定义 <code>typedef pair&lt;int, int&gt; PII</code></p>
</blockquote>
<p><strong>头文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>初始化</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//俩种方法初始化</span></span><br><span class="line"><span class="function">pair&lt;string,<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;hello&quot;</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">p = <span class="built_in">make_pair</span>(<span class="string">&quot;hello&quot;</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><strong>取值</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">p</span>(<span class="string">&quot;hello&quot;</span>,<span class="number">1</span>);</span><br><span class="line">p.first; <span class="comment">//第一个元素 =hello</span></span><br><span class="line">p.second; <span class="comment">//第二个元素 = 1</span></span><br></pre></td></tr></table></figure>

<p><strong>嵌套（套娃）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt; vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; &gt;<span class="comment">//与vector结合【再写个vector结合即可】</span></span><br><span class="line"><span class="comment">//套娃操作 用pair存储3个数据</span></span><br><span class="line"> pair&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">p</span>(<span class="number">1</span>,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">stack&lt; <span class="type">int</span>, vector&lt;<span class="type">int</span>&gt; &gt; stk;  <span class="comment">//覆盖基础容器类型，使用vector实现stk</span></span><br><span class="line">s.<span class="built_in">empty</span>();  <span class="comment">//判断stack是否为空，为空返回true，否则返回false</span></span><br><span class="line">s.<span class="built_in">size</span>();   <span class="comment">//返回stack中元素的个数</span></span><br><span class="line">s.<span class="built_in">pop</span>();    <span class="comment">//删除栈顶元素，但不返回其值</span></span><br><span class="line">s.<span class="built_in">top</span>();    <span class="comment">//返回栈顶元素的值，但不删除此元素</span></span><br><span class="line">s.<span class="built_in">push</span>(item);   <span class="comment">//在栈顶压入新元素item</span></span><br></pre></td></tr></table></figure>

<h4 id="queue-priority-queue"><a href="#queue-priority-queue" class="headerlink" title="queue &amp; priority_queue"></a>queue &amp; priority_queue</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q; <span class="comment">//priority_queue&lt;int&gt; q;</span></span><br><span class="line">q.<span class="built_in">empty</span>();  <span class="comment">//判断队列是否为空</span></span><br><span class="line">q.<span class="built_in">size</span>();   <span class="comment">//返回队列长度</span></span><br><span class="line">q.<span class="built_in">push</span>(item);   <span class="comment">//对于queue，在队尾压入一个新元素</span></span><br><span class="line">               <span class="comment">//对于priority_queue，在基于优先级的适当位置插入新元素</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//queue only:</span></span><br><span class="line">q.<span class="built_in">front</span>();  <span class="comment">//返回队首元素的值，但不删除该元素</span></span><br><span class="line">q.<span class="built_in">back</span>();   <span class="comment">//返回队尾元素的值，但不删除该元素</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//priority_queue only:</span></span><br><span class="line">q.<span class="built_in">top</span>();    <span class="comment">//返回具有最高优先级的元素值，但不删除该元素</span></span><br></pre></td></tr></table></figure>

<h3 id="string串"><a href="#string串" class="headerlink" title="string串"></a>string串</h3><p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/353910845">https://zhuanlan.zhihu.com/p/353910845</a></p>
<p>1、string构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>();<span class="comment">//创建一个空的字符串 例如: string str; </span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> string&amp; str);<span class="comment">//使用一个string对象初始化另一个string对象 </span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span>* s);<span class="comment">//使用字符串s初始化 </span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">int</span> n, <span class="type">char</span> c);<span class="comment">//使用n个字符c初始化 </span></span><br></pre></td></tr></table></figure>

<p>2、string基本赋值操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string&amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span>* s);<span class="comment">//char*类型字符串 赋值给当前的字符串 </span></span><br><span class="line">string&amp; <span class="keyword">operator</span>=(<span class="type">const</span> string &amp;s);<span class="comment">//把字符串s赋给当前的字符串 </span></span><br><span class="line">string&amp; <span class="keyword">operator</span>=(<span class="type">char</span> c);<span class="comment">//字符赋值给当前的字符串 </span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;<span class="comment">//把字符串s赋给当前的字符串 </span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> n)</span></span>;<span class="comment">//把字符串s的前n个字符赋给当前的字符串 </span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>;<span class="comment">//把字符串s赋给当前字符串 </span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> c)</span></span>;<span class="comment">//用n个字符c赋给当前字符串 </span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">int</span> start, <span class="type">int</span> n)</span></span>;<span class="comment">//将s从start开始n个字符赋值给字符串</span></span><br></pre></td></tr></table></figure>

<p>3、string存取字符操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> n);<span class="comment">//通过[]方式取字符 </span></span><br><span class="line"><span class="function"><span class="type">char</span>&amp; <span class="title">at</span><span class="params">(<span class="type">int</span> n)</span></span>;<span class="comment">//通过at方法获取字符</span></span><br></pre></td></tr></table></figure>

<p>4、string拼接操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> string&amp; str);<span class="comment">//重载+=操作符 </span></span><br><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span>* str);<span class="comment">//重载+=操作符 </span></span><br><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span> c);<span class="comment">//重载+=操作符 </span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;<span class="comment">//把字符串s连接到当前字符串结尾 </span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> n)</span></span>;<span class="comment">//把字符串s的前n个字符连接到当前字符串结尾 </span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>;<span class="comment">//同operator+=() </span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">int</span> pos, <span class="type">int</span> n)</span></span>;<span class="comment">//把字符串s中从pos开始的n个字符连接到 当前字符串结尾 </span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> c)</span></span>;<span class="comment">//在当前字符串结尾添加n个字符c</span></span><br></pre></td></tr></table></figure>

<p>5、string查找和替换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>; <span class="comment">//查找str第一次出现位置,从pos开始查找 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>; <span class="comment">//查找s第一次出现位置,从pos开始查找 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos, <span class="type">int</span> n)</span> <span class="type">const</span></span>; <span class="comment">//从pos位置查找s的前n个字符第一次位置 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>; <span class="comment">//查找字符c第一次出现位置 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//查找str最后一次位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//查找s最后一次出现位置,从pos开始查找 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos, <span class="type">int</span> n)</span> <span class="type">const</span></span>;<span class="comment">//从pos查找s的前n个字符最后一次位置 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>; <span class="comment">//查找字符c最后一次出现位置 </span></span><br><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">const</span> string&amp; str)</span></span>; <span class="comment">//替换从pos开始n个字符为字符串 </span></span><br><span class="line"><span class="function">str string&amp; <span class="title">replace</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">const</span> <span class="type">char</span>* s)</span></span>; <span class="comment">//替换从pos开始的n个字符为字符串s</span></span><br></pre></td></tr></table></figure>

<p>6、string比较操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。 </span></span><br><span class="line"><span class="comment">比较区分大小写，比较时参考字典顺序，排越前面的越小。 </span></span><br><span class="line"><span class="comment">大写的A比小写的a小。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> string &amp;s)</span> <span class="type">const</span></span>;<span class="comment">//与字符串s比较 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> <span class="type">const</span></span>;<span class="comment">//与字符串s比较</span></span><br></pre></td></tr></table></figure>

<p>7、string子串</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">substr</span><span class="params">(<span class="type">int</span> pos = <span class="number">0</span>, <span class="type">int</span> n = npos)</span> <span class="type">const</span></span>;<span class="comment">//返回由pos开始的n个字符组成的字符串 </span></span><br></pre></td></tr></table></figure>

<p>8、string插入和删除操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">const</span> <span class="type">char</span>* s)</span></span>; <span class="comment">//插入字符串 </span></span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">const</span> string&amp; str)</span></span>; <span class="comment">//插入字符串 </span></span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">char</span> c)</span></span>;<span class="comment">//在指定位置插入n个字符c </span></span><br><span class="line"><span class="function">string&amp; <span class="title">erase</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n = npos)</span></span>;<span class="comment">//删除从Pos开始的n个字符</span></span><br></pre></td></tr></table></figure>

<p>9、string和c-style字符串转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string 转 char* </span></span><br><span class="line">string str = <span class="string">&quot;itcast&quot;</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cstr = str.<span class="built_in">c_str</span>(); </span><br><span class="line"><span class="comment">//char* 转 string char* s = &quot;itcast&quot;; </span></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(s)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在c++中存在一个从const char到<em>string</em>的隐式类型转换，却不存在从一个<em>string</em>对象到<em>C_string</em>的自动类 型转换。对于<em>string</em>类型的字符串，可以通过<em>c_str()<em>函数返回</em>string</em>对象对应的<em>C_string.</em> 通常，程序员在整个程序中应坚持使用<em>string</em>类对象，直到必须将内容转化为<em>char</em>时才将其转换为C_string.</p>
<h3 id="unordered哈希表"><a href="#unordered哈希表" class="headerlink" title="unordered哈希表"></a>unordered哈希表</h3><p>unordered_set，unordered_map，unordered_muliset,unordered_multimap</p>
<h3 id="ListNode线性链表"><a href="#ListNode线性链表" class="headerlink" title="ListNode线性链表"></a>ListNode线性链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ListNode* temp1 = <span class="keyword">new</span> Solution::<span class="built_in">ListNode</span>(<span class="number">0</span>); <span class="comment">//创建新元素，</span></span><br><span class="line">ListNode* l1 = temp1; <span class="comment">//最后的结果l1指向temp1，这样可以获取temp所接收的全部元素，而temp的指针由于每次都往下移，所以每次都更新</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((c = <span class="built_in">getchar</span>()) != <span class="string">&#x27;\n&#x27;</span>)   <span class="comment">//以空格区分各个结点的值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ungetc</span>(c, stdin);  <span class="comment">//把不是空格的字符丢回去</span></span><br><span class="line">                cin &gt;&gt; num;</span><br><span class="line">                Solution::ListNode* newnode = <span class="keyword">new</span> Solution::<span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">                newnode-&gt;val = num;<span class="comment">//创建新的结点存放键盘中读入的值</span></span><br><span class="line">                newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                temp2-&gt;next = newnode;<span class="comment">//并将其赋值给temp2</span></span><br><span class="line">                temp2 = newnode; <span class="comment">//此处也可以写成  temp2=temp2-&gt;next,使指针指向下一个，以待接收新元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h3 id="bitset位序列"><a href="#bitset位序列" class="headerlink" title="bitset位序列"></a>bitset位序列</h3><p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/607895839">https://zhuanlan.zhihu.com/p/607895839</a></p>
<p><code>std::bitset</code> 是 C++ 标准库中的一个类，用于表示二进制位序列。它提供了一种方便的方式来处理二进制数据，尤其适用于位运算操作。</p>
<p><code>std::bitset</code> 类型表示一个固定长度的位序列，每个位都只能是 0 或 1。这个固定长度在创建对象时指定，并且不能在运行时更改。类似于整数类型，<code>std::bitset</code> 支持多种操作，包括位运算、位查询和位设置。</p>
<p>创建方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::bitset&lt;N&gt; bitset1; <span class="comment">// 创建一个长度为 N 的 bitset，所有位都被初始化为 0</span></span><br><span class="line"><span class="function">std::bitset&lt;N&gt; <span class="title">bitset2</span><span class="params">(value)</span></span>; <span class="comment">// 使用二进制整数 value 初始化一个长度为 N 的 bitset</span></span><br><span class="line"><span class="function">std::bitset&lt;N&gt; <span class="title">bitset3</span><span class="params">(string)</span></span>; <span class="comment">// 使用二进制字符串 string 初始化一个长度为 N 的 bitset</span></span><br><span class="line"><span class="function">std::bitset&lt;N&gt; <span class="title">bitset4</span><span class="params">(bitset)</span></span>; <span class="comment">// 使用另一个 bitset 初始化一个长度为 N 的 bitset</span></span><br></pre></td></tr></table></figure>

<p>常用操作：</p>
<ul>
<li><code>size()</code> 返回 <code>std::bitset</code> 的长度</li>
<li><code>count()</code> 返回 <code>std::bitset</code> 中值为 1 的位的数量</li>
<li><code>any()</code> 返回 <code>std::bitset</code> 中是否存在值为 1 的位</li>
<li><code>none()</code> 返回 <code>std::bitset</code> 中是否所有位都是 0</li>
<li><code>all()</code> 返回 <code>std::bitset</code> 中是否所有位都是 1</li>
<li><code>test(pos)</code> 返回 <code>std::bitset</code> 中位于 <code>pos</code> 位置的值</li>
<li><code>set(pos)</code> 将 <code>std::bitset</code> 中位于 <code>pos</code> 位置的值设为 1</li>
<li><code>reset(pos)</code> 将 <code>std::bitset</code> 中位于 <code>pos</code> 位置的值设为 0</li>
<li><code>flip(pos)</code> 将 <code>std::bitset</code> 中位于 <code>pos</code> 位置的值取反</li>
<li><code>to_ulong()</code> 返回 <code>std::bitset</code> 转换成的无符号整数值</li>
<li><code>to_ullong()</code> 返回 <code>std::bitset</code> 转换成的无符号长整数值</li>
</ul>
<h2 id="STL迭代器"><a href="#STL迭代器" class="headerlink" title="STL迭代器"></a>STL迭代器</h2><p>Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。</p>
<p>迭代器的作用：能够让迭代器与算法不干扰的相互发展，最后又能无间隙的粘合起来，重载了*，＋＋，＝＝，！＝，＝运算符，用以操作复杂的数据结构。</p>
<p>容器提供迭代器，算法使用迭代器；常见的一些迭代器类型：iterator、const_iterator、reverse_iterator和const_reverse_iterator.</p>
<h2 id="STL算法"><a href="#STL算法" class="headerlink" title="STL算法"></a>STL算法</h2><p>STL中算法大致分为四类：</p>
<ul>
<li>非可变序列算法：指不直接修改其所操作的容器内容的算法。</li>
<li>可变序列算法：指可以修改它们所操作的容器内容的算法。</li>
<li>排序算法：对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。</li>
<li>数值算法：对容器内容进行数值计算。</li>
</ul>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_49486457/article/details/123439229?spm=1001.2014.3001.5502">https://blog.csdn.net/weixin_49486457/article/details/123439229?spm=1001.2014.3001.5502</a></p>
<p>①、sort();【具有和快排一样的速度】</p>
<p><code>时间复杂度O (n*logn)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a,a+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="built_in">sort</span>(a,a+<span class="number">5</span>);<span class="comment">//搭配数组  从小到大排序</span></span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<p>②__gcd() 最大公约数<br><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/3645/">最大公约数小题</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="type">int</span> k=__gcd(n,m);<span class="comment">//最大公约数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n * m / k); <span class="comment">//最小公倍数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③max()、min()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(a,b);<span class="comment">//返回最大值</span></span><br><span class="line"><span class="built_in">min</span>(a,b);<span class="comment">//返回最小值</span></span><br></pre></td></tr></table></figure>

<p>④swap()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(a,b);<span class="comment">//交换a和b</span></span><br></pre></td></tr></table></figure>

<p>⑤lower_bound()与upper_bound()【二分查找】</p>
<ul>
<li><p>ower bound()返回数组中第一个大于等于x的数的地址：</p>
</li>
<li><p>upper bound()返回数组中第一个大于x的数的地址</p>
</li>
<li><p>将得到的地址减去数组的起始地址可得在数组中的下标</p>
</li>
</ul>
<p>⑥reverse() 【倒置】</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ector&lt;<span class="type">int</span>&gt; v=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());<span class="comment">//v的值为5，4，3，2，1  倒置</span></span><br></pre></td></tr></table></figure>

<p>⑦find()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，</span></span><br><span class="line"><span class="comment">//若存在返回其在向量中的位置</span></span><br><span class="line"><span class="built_in">find</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>⑧、erase()【删除】</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从c中删除迭代器p指定的元素，p必须指向c中的一个真实元素，不能等于c.end()</span></span><br><span class="line">c.<span class="built_in">erase</span>(p)</span><br><span class="line"><span class="comment">//从c中删除迭代器对b和e所表示的范围中的元素，返回e</span></span><br><span class="line">c.<span class="built_in">erase</span>(b,e)</span><br></pre></td></tr></table></figure>


<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2024/03/12/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">ARM体系结构</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">baimin</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.26.8">Stellar 1.26.8</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
<div class="main-mask" onclick="sidebar.toggle()"></div></div></div><div class="scripts">
<script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.26.8';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.26.8';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"codeblock":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js","memos":"/js/plugins/memos.js","marked":"/js/plugins/marked.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.8.4/lazyload.min.js","transition":"fade"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@10.3/swiper-bundle.min.css","js":"https://unpkg.com/swiper@10.3/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://cdn.bootcdn.net/ajax/libs/scrollReveal.js/4.0.9/scrollreveal.min.js","distance":"16px","duration":800,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","flying_pages":"https://cdn.bootcdn.net/ajax/libs/flying-pages/2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.umd.min.js","css":"https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.min.css","selector":null});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied","toast":"复制成功"});
  }
</script>

<!-- required -->
<script src="/js/main.js?v=1.26.8" async></script>

<!-- optional -->






<!-- inject -->

</div></body></html>
