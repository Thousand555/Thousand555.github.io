<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>八股文-C语言</title>
      <link href="/2024/04/09/%E5%85%AB%E8%82%A1%E6%96%87-C%E8%AF%AD%E8%A8%80/"/>
      <url>/2024/04/09/%E5%85%AB%E8%82%A1%E6%96%87-C%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><strong>简述编译运行一段代码的过程</strong></p><p>源程序是指未经编译的，按照一定的程序设计语言规范书写的，人类可读的文本文件，源程序就是所写好的代码。</p><p> 可执行程序，即常说的.exe程序，可以执行程序，完成计算机功能。</p><p>在C语言中，.c文件就是所谓的源文件。</p><p> 源程序到可执行程序的过程。在这个过程中，会发生如下的变化：</p><img src="/2024/04/09/%E5%85%AB%E8%82%A1%E6%96%87-C%E8%AF%AD%E8%A8%80/063ee4699231e33a1252fbe5ddbbc98c.jpeg" class="" title="img"><p>.c文件生成.exe文件的过程总共是经历了<strong>预处理，编译，汇编，链接</strong>，这四个过程。</p><p>1、预处理（预编译）</p><p>第一步发生的是预编译，使用-E指令会使程序只进行到预编译指令。经过预编译指令后的会生成一个.i文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -E &gt; test.i</span><br></pre></td></tr></table></figure><p>在预编译的过程中，主要处理源代码中的预处理指令：<strong>引入头文件、去除注释、处理所有的条件编译指令（#ifdef,#ifndef,#else,#elif,#endif）、宏的替换、添加行号和保留所有的编译器指令</strong>。</p><p>当进行预编译以后的文件中将不再存在宏，所有的宏都已经被替代。<strong>当想要判断宏是否正确或者头文件包含是否正确时，也可以通过预编译来查看</strong>。</p><p>2、编译</p><p><strong>编译过程所进行的是对预处理后的文件进行语法分析，词法分析，语义分析，符号汇总，然后生成汇编代码</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.i -S &gt; test.s</span><br></pre></td></tr></table></figure><p>3、汇编</p><p><strong>汇编过程将汇编代码转成二进制文件，二进制文件就可以让机器来读取</strong>。每一条汇编语句都会产生一句机器语言。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.s -O &gt; test.o</span><br></pre></td></tr></table></figure><p>在这里最终会生成一个重定位目标文件 .o文件，类似windows下的.obj文件。这里生成的目标文件里面就是二进制文件。另外，在这里会形成符号表，给这些符号会分配虚拟地址。</p><p>4、链接</p><p>由汇编程序生成的目标文件并不能立即就被执行，其中可能还有许多没有解决的问题。例如，某个源文件中的函数可能引用了另一个源文件中定义的某个符号（如变量或者函数调用等）；在程序中可能调用了某个库文件中的函数等等。<strong>所有这些问题，都需要经链接程序的处理方能得以解决</strong>。<strong>链接程序的主要工作就是将有关的目标文件彼此相连接，也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体</strong>。</p><p> 链接分为静态链接和动态链接：</p><ul><li><p>静态链接：后缀是.a，主要在编译的时候将库文件里面代码搬迁到可执行的文件中；</p></li><li><p>动态链接：后缀是.so,主要在执行的时候需要转换到库文件代码执行；</p></li></ul><p>两种链接的<strong>优缺点</strong>：</p><p> （1）静态的链接产生的可执行的文件体积比较的大；而动态链接的可执行文件的体积比较小；</p><p> （2）动态的链接的编译的效率比较的高；</p><p> （3）静态链接的可执行的文件执行的效率高</p><p> （4）静态链接的可执行的文件的“布局”比较好一点；</p><p>两种链接的<strong>区别</strong>：</p><p>静态链接是指把要调用的函数或者过程<strong>直接链接到可执行文件中</strong>，成为可执行文件的一部分。换句话说，<strong>函数和过程的代码就在程序的exe文件中</strong>，<strong>该文件包含了运行时所需的全部代码</strong>。静态链接的缺点是：当多个程序都<strong>调用相同函数时，内存中就会存在这个函数的多个复制，这样就浪费了内存资源</strong></p><p> 动态链接是相对于静态链接而言的。动态链接调用的函数代码并没有被复制到应用程序的可执行文件中去，而是<strong>仅仅在其中加入了所调用函数的描述信息（往往是一些重定位信息）</strong>。仅当应用程序被<strong>装入内存开始运行时</strong>，在操作系统的管理下，才在应用程序与相应的动态链接库（ dynamic link library,d）之间<strong>建立链接关系</strong>。当要执行调用，dll文件中的函数时，根据链接产生的重定位信息，操作系统才转去执行，dll文件中相应的函数代码。</p><p> 静态链接的执行程序能够在<strong>其他同类操作系统</strong>的机器上直接运行。例如，一个exe文件是在Windows2000系统上静态链接的，那么将该文件直接复制到另一台 Windows2000的机器上，是可以运行的。而动态链接的执行程序则不可以，除非把该exe文件所需的dll文件都一并复制过去，或者对方机器上也有所需的相同版本的dll文件，否则是不能保证正常运行的。</p><p><strong>静态链接库和动态链接库有什么区别</strong></p><p>静态链接库就是使用的lib文件，库中的代码最后需要链接到可执行文件中去，所以静态链接的可执行文件一般比较大一些。</p><p> 动态链接库是一个包含可由多个程序同时使用的代码和数据的库，它包含函数和数据的模块的集合。程序文件（如exe文件或d文件）在运行时加载这些模块（即所需的模块映射到调用进程的地址空间）。</p><p> 静态链接库和动态链接库的相同点是它们都实现了代码的共享，不同点是静态链接库lib文件中的代码被包含在调用的exe文件中，该lib文件中不能再包含其他动态链接库或者静态链接库了。而动态链接库dll文件可以被调用的exe动态地“引用”和“卸载”，该dll文件中可以包含其他动态链接库或者静态链接库。</p><h2 id="4字节对齐"><a href="#4字节对齐" class="headerlink" title="4字节对齐"></a><strong>4</strong>字节对齐</h2><p><strong>什么是字节对齐？</strong></p><p>在现代计算机中，内存空间都是按照字节(byte)划分的。从理论上讲对任何类型的变量的访问可以从任何地址开始，但实际情况是，访问特定类型的变量的时候经常在特定的内存地址访问，这就需要各种类型的数据按照一定规则在空间上排列，而不是顺序地一个接一个地排放，这种所谓的规则就是字节对齐。这么长一段话的意思是说：<strong>字节对齐可以提升存取效率，也就是用空间换时间</strong>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">char</span> a;</span><br><span class="line"> <span class="type">char</span> reserved[<span class="number">3</span>];<span class="comment">//使用空间换时间</span></span><br><span class="line"> <span class="type">int</span> b; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><style>.lddibaorepnp{zoom:67%;}</style><img src="/2024/04/09/%E5%85%AB%E8%82%A1%E6%96%87-C%E8%AF%AD%E8%A8%80/image-20240620100054921.png" class="lddibaorepnp" alt="image-20240620100054921"><p>注：其中的reserved成员对于程序并没有意义，只是起到了填补空间达到字节对齐的目的。当然，即使不加这个成员，<u>编译器也会自动为我们补齐</u>，加上它只是起到显式提醒。</p><p><strong>为什么需要字节对齐？</strong></p><p>因为各个硬件平台对存储空间的处理上有很大的不同，<u>一些硬件平台对某些特定类型的数据只能从某些特定地址开始存取</u>。比如有些架构的CPU在访问一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐。其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会<u>在存取效率上带来损失</u>。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。</p><p><strong>几个基本概念</strong></p><ul><li>基本数据类型的自身对齐值</li></ul><p> 例如，char型数据的自身对齐值为1字节，short类型自身对齐值为2字节，int、float、long类型自身对齐值均为4字节，double类型自身对齐值均为8字节。（32位系统）</p><ul><li>结构体或类的自身对齐值</li></ul><p> 其成员中自身对齐值最大的那个值。</p><ul><li>指定对齐值</li></ul><p> 通过预编译指令<code> #pragma pack (value)</code> 来指定的对齐值value。（注：取消自定义对齐值得指令为<code>#pragma pack ()</code>）</p><ul><li>数据成员、结构体和类的有效对齐值</li></ul><p> 其自身对齐值和指定对齐值中较小的那个值。</p><p><strong>例1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="type">char</span> a;</span><br><span class="line">   <span class="type">short</span> b;</span><br><span class="line">   <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">   <span class="type">short</span> b;</span><br><span class="line">   <span class="type">int</span> c;</span><br><span class="line">   <span class="type">char</span> a;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>对于结构体A：a是char型数据，占用1字节内存；short型数据，占用2字节内存；int型数据，占用4字节内存。因此，结构体A的自身对齐值为4，sizeof(struct A) &#x3D;8字节。由于<u>结构体类型数据是按顺序存储结构一个接一个向后排列</u>的，于是其存储方式为：</p><style>.ihhgsuuipgye{zoom:67%;}</style><img src="/2024/04/09/%E5%85%AB%E8%82%A1%E6%96%87-C%E8%AF%AD%E8%A8%80/image-20240620100514468.png" class="ihhgsuuipgye" alt="image-20240620100514468"><p>对于结构体B：同理也是4字节对齐，但是sizeof(struct B) &#x3D;12字节。</p><style>.izhfxmgwkpgn{zoom:67%;}</style><img src="/2024/04/09/%E5%85%AB%E8%82%A1%E6%96%87-C%E8%AF%AD%E8%A8%80/image-20240620100551578.png" class="izhfxmgwkpgn" alt="image-20240620100551578"><p><strong>例2：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(2) <span class="comment">//指定2字节对齐</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">   <span class="type">char</span> a;</span><br><span class="line">   <span class="type">int</span> b;</span><br><span class="line">   <span class="type">short</span> c;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack() <span class="comment">//取消指定对齐，恢复缺省对齐</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1) <span class="comment">//指定1字节对齐</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">   <span class="type">char</span> a;</span><br><span class="line">   <span class="type">int</span> b;</span><br><span class="line">   <span class="type">short</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack() <span class="comment">//取消指定对齐，恢复缺省对齐</span></span></span><br></pre></td></tr></table></figure><p>对于结构体C：由于其自身对齐值为4字节（int b），而指定对齐值为2字节，因此该结构体的有效对齐值为较小的2字节，那么sizeof(struct C) &#x3D; 8 字节。</p><style>.mkcqrwfuwbrh{zoom:67%;}</style><img src="/2024/04/09/%E5%85%AB%E8%82%A1%E6%96%87-C%E8%AF%AD%E8%A8%80/image-20240620100734179.png" class="mkcqrwfuwbrh" alt="image-20240620100734179"><p>对于结构体D：同理可知，由于其自身对齐值为4字节（int b），而指定对齐值为1字节，因此该结构体的有效对齐值为较小的1字节，那么sizeof(struct D) &#x3D; 7 字节。</p><style>.axipmpeonbyr{zoom:67%;}</style><img src="/2024/04/09/%E5%85%AB%E8%82%A1%E6%96%87-C%E8%AF%AD%E8%A8%80/image-20240620100814547.png" class="axipmpeonbyr" alt="image-20240620100814547"><h2 id="预处理相关"><a href="#预处理相关" class="headerlink" title="预处理相关"></a>预处理相关</h2><h3 id="1、typedef与define"><a href="#1、typedef与define" class="headerlink" title="1、typedef与define"></a>1、<code>typedef</code>与<code>define</code></h3><table><thead><tr><th align="center">区别</th><th align="center">define</th><th align="center">typedef</th></tr></thead><tbody><tr><td align="center">原理</td><td align="center">预处理指令，<strong>在预改处理时</strong>进行简单而机械的字符串替换，不做正确性检查，不管含义是否正确照样代入，只有在编译已被展开的源程序时，才会发现可能的错误并报错。</td><td align="center">关键字，<strong>在编译时</strong>处理，具有类型检查的功能。它在自己的作用域内给一个已经存在的类型一个别名，但是不能在一个函数定义里面使用标识符typedef。</td></tr><tr><td align="center">功能</td><td align="center">不只是可以为<strong>类型</strong>取别名，还可以定义<strong>常量、变量、编译开关等</strong>。</td><td align="center">typedef用来定义<strong>类型的别名</strong>，这些类型不仅包含内部类型(int、char等)，还包括自定义类型（如 struct)，可以起到使类型易于记忆的功能。</td></tr><tr><td align="center">作用域</td><td align="center">没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用</td><td align="center">有自己的作用域</td></tr><tr><td align="center">指针</td><td align="center">如下</td><td align="center">如下</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTPTR1 int*</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* INTPTR2;</span><br><span class="line">INTPTR1 pl, p2;</span><br><span class="line">INTPTR2 p3， p4;</span><br></pre></td></tr></table></figure><p>上述代码中，INTPTR1 p1, p2和INTPTR2 p3, p4的效果截然不同。 INTPTR1 pl, p2进行字符串替换后变成int *p1,p2 ，要表达的意义是声明一个<strong>指针变量</strong>p1和一个<strong>整型变量</strong>p2。而 INTPTR2 p3，p4，由于INTPTR2是具有含义的，告诉我们是一个指向整型数据的指针，那么p3和p4都为<strong>指针变量</strong>，这句相当于int *p3，*p4 。从这里可以看出，进行<u>define宏替换是不含任何意义的替换，仅仅为字符串替换</u>；而用 <u>typedef为一种数据类型起的别名带有一定含义</u>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTPTR1 int*</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* INTPTR2</span><br><span class="line"><span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b=<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c=<span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> INTPTR1 p1=&amp;a;</span><br><span class="line"><span class="type">const</span> INTPTR2 p2=&amp;b;</span><br><span class="line">INTPTR2 <span class="type">const</span> p3=&amp;c;</span><br></pre></td></tr></table></figure><p>上述代码中， const INTPTR1 p1表示p1是一个<strong>常量指针</strong>，即不可以通过p1去修改p1指向的内容，但是p1可以指向其他内容。而对于 const INTPTR2 p2，由于 INTPTR2表示的是个指针类型，因此用 const去限定，表示封锁了这个指针类型，因此p2是一个<strong>指针常量</strong>，不可使p2再指向其他内容，但可以通过p2修改其当前指向的内容。 INTPTR2 const p3同样声明的是一个<strong>指针常量</strong>。</p><h3 id="2、-include-filename-h-和-include-“filename-h”"><a href="#2、-include-filename-h-和-include-“filename-h”" class="headerlink" title="2、#include &lt; filename. h&gt;和#include “filename. h”"></a>2、#include &lt; filename. h&gt;和#include “filename. h”</h3><p>对于 include&lt; filename. h&gt;，编译器先从<strong>标准库路径</strong>开始搜索 filename.h，使得系统文件调用较快。而对于# include“ filename.h””，编译器先从<strong>用户的工作路径</strong>开始搜索 filename.h，然后去寻找系统路径，使得自定义文件较快。</p><h3 id="3、头文件的作用"><a href="#3、头文件的作用" class="headerlink" title="3、头文件的作用"></a>3、头文件的作用</h3><p>头文件的作用主要表现为以下两个方面：</p><ul><li>通过头文件来调用库功能。出于对源代码保密的考虑，源代码不便（或不准）向用户公布，只要向用户提供头文件和二进制的库即可。用户只需要按照头文件中的接口声明来调用库功能，而不必关心接口是怎么实现的。</li><li>头文件能加强类型安全检查。当某个接口被实现或被使用时，其方式与头文件中的声明不一致，编译器就会指出错误，大大减轻程序员调试、改错的负担。</li></ul><p><strong>在头文件中定义静态变量是否可行？</strong></p><p><strong>不可行</strong>，如果在头文件中定义静态变量，会造成资源浪费的问题，同时也可能引起程序错误。因为如果在使用了该头文件的每个C语言文件中定义静态变量，按照编译的步骤，<strong>在每个头文件中都会单独存在一个静态变量</strong>，从而会引起<strong>空间浪费</strong>或者<strong>程序错误</strong>所以，不推荐在头文件中定义任何变量，当然也包括静态变量。</p><h3 id="4、标准宏函数"><a href="#4、标准宏函数" class="headerlink" title="4、标准宏函数"></a>4、标准宏函数</h3><p>标准宏MN函数，这个宏输入两个参数并返回较小的一个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(A,B) ((A) &lt;= (B) ? (A) : (B))</span></span><br></pre></td></tr></table></figure><h3 id="不使用流程控制语句，打印出1-1000的整数"><a href="#不使用流程控制语句，打印出1-1000的整数" class="headerlink" title="不使用流程控制语句，打印出1~1000的整数"></a>不使用流程控制语句，打印出1~1000的整数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio. h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B P,P,P,P,P,P,P,P,P,P</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P L,L,L,L,L,L,L,L,L,L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L I,I,I,I,I,I,I,I,I,I,N</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I printf（<span class="string">&quot;%3d&quot;</span>，i++）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N printf（<span class="string">&quot;n&quot;</span>）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    B;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio. h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A(x) x;x;x;x;x;x;x;x;x;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">1</span>;</span><br><span class="line">    A(A(A(<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>， n++));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="关键字”-“和”"><a href="#关键字”-“和”" class="headerlink" title="关键字”#“和”##"></a>关键字”#“和”##</h3><p>“#“关键字：将宏定义中的传入参数名转换成用一对双引号括起来参数名字符串。其只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> example(instr) printf(<span class="string">&quot;the input string is:\t%s\n&quot;</span>, #instr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> example1(instr) #instr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用该宏定义时：</span></span><br><span class="line">example( abc ); <span class="comment">// 在编译时将会展开成：printf(&quot;the input string</span></span><br><span class="line">is:\t%s\n<span class="string">&quot;,&quot;</span>abc<span class="string">&quot;)</span></span><br><span class="line"><span class="string">string str = example1( abc ); // 将会展成：string str=&quot;</span>abc<span class="string">&quot;</span></span><br></pre></td></tr></table></figure><p>“##“关键字：将宏定义的多个形参转换成一个实际参数名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> exampleNum( n ) num##n</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num9 = <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span> num = exampleNum( <span class="number">9</span> ); <span class="comment">// 将会扩展成 int num = num9</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>a当用##连接形参时，##前后的空格可有可无。</li><li>连接后的实际参数名，必须为实际存在的参数名或是编译器已知的宏定义。</li><li>如果##后的参数本身也是一个宏的话，##会阻止这个宏的展开。</li></ul><h3 id="关键字volatile"><a href="#关键字volatile" class="headerlink" title="关键字volatile"></a>关键字volatile</h3><ul><li><strong>并行设备的硬件寄存器</strong>。存储器映射的硬件寄存器通常加volatile，因为寄存器随时可以被外设硬件修改。当声明指向设备寄存器的指针时一定要用volatile，它会告诉编译器不要对存储在这个地址的数据进行假设。</li><li><strong>一个中断服务程序中修改的供其他程序检测的变量</strong>。volatile提醒编译器，它后面所定义的变量随时都有可能改变。因此编译后的程序每次需要存储或读取这个变量的时候，<strong>都会直接从变量地址中读取数据</strong>。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。</li><li><strong>多线程应用中被几个任务共享的变量</strong>。单地说就是防止编译器对代码进行优化。例如：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XBYTE[<span class="number">2</span>]=<span class="number">0x55</span>;</span><br><span class="line">XBYTE[<span class="number">2</span>]=<span class="number">0x56</span>;</span><br><span class="line">XBYTE[<span class="number">2</span>]=<span class="number">0x57</span>;</span><br><span class="line">XBYTE[<span class="number">2</span>]=<span class="number">0x58</span>;</span><br></pre></td></tr></table></figure><p>对外部硬件而言，上述四条语句分别表示不同的操作，会产生四种不同的动作，但是编译器却会对上述四条语句进行优化，<strong>认为只有XBYTE[2]&#x3D;0x58</strong>（<strong>即忽略前三条语句，只产生一条机器代码</strong>）。如果键入volatile，编译器会逐一的进行编译并产生相应的机器代码（产生四条代码）。</p><h3 id="关键字static"><a href="#关键字static" class="headerlink" title="关键字static"></a>关键字static</h3><p><strong>作用</strong>：</p><ul><li>在函数体，<strong>只会被初始化一次</strong>，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。</li><li>在模块内（但在<strong>函数体外</strong>），一个被声明为<strong>静态的变量</strong>可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个<strong>本地的全局变量</strong>（只能被当前文件使用）。</li><li>在模块内，一个被声明为<strong>静态的函数</strong>只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用（<strong>只能被当前文件使用</strong>）。</li></ul><p><strong>为什么static变量只初始化一次？</strong></p><p>对于所有的对象（不仅仅是静态对象），<strong>初始化都只有一次</strong>，而由于静态变量具有“记忆”功能，初始化后，一直都没有被销毁，<strong>都会保存在内存区域中</strong>，所以不会再次初始化。存放在静态区的变量的生命周期一般比较长，它与整个程序“同生死、共存亡”，所以它只需初始化一次。而auto变量，即自动变量，由于它<strong>存放在栈区</strong>，一旦函数调用结束，就会<strong>立刻被销毁</strong>。</p><h3 id="关键字extern”C”"><a href="#关键字extern”C”" class="headerlink" title="关键字extern”C”"></a>关键字extern”C”</h3><p>extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会<strong>指示编译器这部分代码按语言的进行编译</strong>，而不是C++的。</p><h3 id="关键字const"><a href="#关键字const" class="headerlink" title="关键字const"></a>关键字const</h3><p><strong>作用</strong>：</p><ol><li>定义变量（局部变量或全局变量）为常量，例如：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100</span>;<span class="comment">//定义一个常量N</span></span><br><span class="line">N=<span class="number">50</span>; <span class="comment">//错误，常量的值不能被修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n; <span class="comment">//错误，常量在定义的时候必须初始化</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>修饰函数的参数，表示在函数体内不能修改这个参数的值。</p></li><li><p>修饰函数的返回值。</p></li></ol><ul><li>如果给用 const修饰<strong>返回值的类型为指针</strong>，那么函数返回值（即指针）的内容是不<strong>能被修改</strong>的，而且这个返回值只能赋给被 const修饰的指针。例如：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> <span class="title function_">GetString</span><span class="params">()</span> <span class="comment">//定义一个函数</span></span><br><span class="line"><span class="type">char</span> *str= GetString() <span class="comment">//错误，因为str没有被 const修饰</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *str=GetString() <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><ul><li><p>如果用 const修饰<strong>普通的返回值</strong>，如返回int变量，由于这个返回值是一个临时变量，在函数调用</p><p>  结束后这个临时变量的生命周期也就结束了，因此把这些<strong>返回值修饰为const是没有意义</strong>的。</p></li></ul><ol start="4"><li>节省空间，避免不必要的内存分配。例如：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159<span class="comment">//该宏用来定义常量</span></span></span><br><span class="line"><span class="type">const</span> doulbe Pi=<span class="number">3.14159</span><span class="comment">//此时并未将P放入只读存储器中</span></span><br><span class="line"><span class="type">double</span> i=Pi<span class="comment">//此时为Pi分配内存，以后不再分配</span></span><br><span class="line"><span class="type">double</span> I=PI<span class="comment">//编译期间进行宏替换，分配内存</span></span><br><span class="line"><span class="type">double</span> j=Pi<span class="comment">//没有内存分配再次进行宏替换，又一次分配内存</span></span><br></pre></td></tr></table></figure><p><strong>什么情况下使用const关键字？</strong></p><ul><li>修饰一般常量。一般常量是指简单类型的常量，修饰符const可以用在类型说明符前，也可以用在类型说明符后。例如：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span> x=<span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> x=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><ul><li>修饰常数组</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span> a[<span class="number">8</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a[<span class="number">8</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>修饰常对象</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>：</span></span><br><span class="line"><span class="class"><span class="title">const</span> <span class="title">A</span> <span class="title">a</span>：</span></span><br><span class="line"><span class="class"><span class="title">A</span> <span class="title">const</span> <span class="title">a</span>：</span></span><br></pre></td></tr></table></figure><ul><li>修饰常指针</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>*p； <span class="comment">//常量指针，指向常量的指针。即p指向的内存可以变，p指向的数值内容不可变</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span>*p； <span class="comment">//同上</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p；<span class="comment">//指针常量，本质是一个常量，而用指针修饰它。 即p指向的内存不可以变，但是p内存位置的数值可以变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p；<span class="comment">//指向常量的常量指针。即p指向的内存和数值都不可变</span></span><br></pre></td></tr></table></figure><ul><li>修饰常引用</li><li>修饰函数的常参数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> Fun（<span class="type">const</span> <span class="type">int</span> Var）</span><br></pre></td></tr></table></figure><ul><li>修饰函数的返回值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> FunI（)；</span><br><span class="line"><span class="type">const</span> MyClass Fun2（）；</span><br></pre></td></tr></table></figure><ul><li>在另一连接文件中引用 const常量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> i：</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> j=<span class="number">10</span>；</span><br></pre></td></tr></table></figure><h3 id="define和const定义常量"><a href="#define和const定义常量" class="headerlink" title="#define和const定义常量"></a>#define和const定义常量</h3><ul><li><p>const定义常量是有<strong>数据类型</strong>的，而#define宏定义常量却没有。</p></li><li><p>const可以有不同的作用域。</p></li><li><p>编译器可以对const进行类型<strong>安全检查</strong>， 而对后者<strong>只进行字符替换</strong>，没有类型安全检查，并且在字符替换中可能会产生意料不到的错误。</p></li><li><p>有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。</p></li></ul><h3 id="new-delete与malloc-free的区别"><a href="#new-delete与malloc-free的区别" class="headerlink" title="new&#x2F;delete与malloc&#x2F;free的区别"></a>new&#x2F;delete与malloc&#x2F;free的区别</h3><ul><li><p>new、delete是C++中的操作符，而malloc和free是标准库函数。</p></li><li><p>对于非内部数据对象来说，只使用malloc是无法完成动态对象要求的，一般在创建对象时需要调用构造函数，对象消亡时，自动的调用析构函数。而malloc、free是库函数而不是运算符，不在编译器控制范围之内，不能够自动调用构造函数和析构函数。而new在为对象申请分配内存空间时，可以自动调用构造函数，同时也可以完成对对象的初始化。同理，delete也可以自动调用析构函数。而mallloc只是做一件事，只是为变量分配了内存，同理，free也只是释放变量的内存。</p></li><li><p>new返回的是指定类型的指针，并且可以自动计算所申请内存的大小。而 malloc需要我们计算申请</p></li></ul><p>内存的大小，并且在返回时强行转换为实际类型的指针。</p><h3 id="delete和delete-区别"><a href="#delete和delete-区别" class="headerlink" title="delete和delete[]区别"></a><strong>delete</strong>和delete[]区别</h3><p>delete 释放new分配的<strong>单个对象</strong>指针指向的内存。 </p><p>delete[] 释放new分配的<strong>对象数组</strong>指针指向的内存。</p><h3 id="assert宏"><a href="#assert宏" class="headerlink" title="assert宏"></a>assert宏</h3><p>assert宏的原型定义在&lt;assert.h&gt;中，其作用是如果它的条件返回错误，则终止程序执行，原型定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">assert</span><span class="params">( <span class="type">int</span> expression )</span>;</span><br></pre></td></tr></table></figure><p>assert的作用是现计算表达式 expression ，如果其值为假（即为0），那么它先向stderr打印一条出错信息，然后通过调用 abort 来终止程序运行。请看下面的程序清单badptr.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">       FILE *fp;</span><br><span class="line">       fp = fopen( <span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span> );<span class="comment">//以可写的方式打开一个文件，如果不存在就创建一个同名文件</span></span><br><span class="line">       assert( fp );                           <span class="comment">//所以这里不会出错</span></span><br><span class="line">       fclose( fp );</span><br><span class="line">       fp = fopen( <span class="string">&quot;noexitfile.txt&quot;</span>, <span class="string">&quot;r&quot;</span> );<span class="comment">//以只读的方式打开一个文件，如果不存在就打开文件失败</span></span><br><span class="line">       assert( fp );                           <span class="comment">//所以这里出错</span></span><br><span class="line">       fclose( fp );                           <span class="comment">//程序永远都执行不到这里来</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已放弃使用assert()的缺点是，频繁的调用会极大的影响程序的性能，增加额外的开销。在调试结束后，可以通过在包含#include &lt;assert.h&gt;的语句之前插入 #define NDEBUG 来禁用assert调用，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>用法总结与注意事项</strong>：</p><p>1）在函数开始处检验传入参数的合法性如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">resetBufferSize</span><span class="params">(<span class="type">int</span> nNewSize)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//功能:改变缓冲区大小,</span></span><br><span class="line"> <span class="comment">//参数:nNewSize 缓冲区新长度</span></span><br><span class="line"> <span class="comment">//返回值:缓冲区当前长度</span></span><br><span class="line"> <span class="comment">//说明:保持原信息内容不变     nNewSize&lt;=0表示清除缓冲区</span></span><br><span class="line"> assert(nNewSize &gt;= <span class="number">0</span>);</span><br><span class="line"> assert(nNewSize &lt;= MAX_BUFFER_SIZE);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）每个assert只检验一个条件，因为同时检验多个条件时，如果断言失败，无法直观的判断是哪个条件失败，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不好：</span></span><br><span class="line">assert(nOffset&gt;=<span class="number">0</span> &amp;&amp; nOffset+nSize&lt;=m_nInfomationSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">//好：</span></span><br><span class="line">assert(nOffset &gt;= <span class="number">0</span>);</span><br><span class="line">assert(nOffset+nSize &lt;= m_nInfomationSize);</span><br></pre></td></tr></table></figure><p>3）不能使用改变环境的语句，因为assert只在DEBUG个生效，如果这么做，会使用程序在真正运行时遇到问题，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误：</span></span><br><span class="line">assert(i++ &lt; <span class="number">100</span>);</span><br><span class="line"><span class="comment">//正确：</span></span><br><span class="line">assert(i &lt; <span class="number">100</span>);</span><br><span class="line">i++;</span><br></pre></td></tr></table></figure><p>4）assert和后面的语句应空一行，以形成逻辑和视觉上的一致感。</p><p>5）有的地方，assert不能代替条件过滤。</p><p> 以下是使用断言的几个原则： </p><p> （1）使用断言捕捉不应该发生的非法情况。不要混淆非法情况与错误情况之间的区别，后者是必然存在的并且是一定要作出处理的。 </p><p> （2）使用断言对函数的参数进行确认。 </p><p> （3）在编写函数时，要进行反复的考查，并且自问：“我打算做哪些假定？”一旦确定了的假定，就要使用断言对假定进行检查。 </p><p> （4）一般教科书都鼓励程序员们进行防错性的程序设计，但要记住这种编程风格会隐瞒错误。当进行防错性编程时，如果“不可能发生”的事情的确发生了，则要使用断言进行报警。</p><p>ASSERT ()是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为FALSE (0), 程序将报告错误，并终止执行。如果表达式不为0，则继续执行后面的语句。这个宏通常原来判断程序中是否出现了明显非法的数据，如果出现了终止程序以免导致严重后果，同时也便于查找错误。 </p><p><strong>ASSERT只有在Debug版本中才有效，如果编译为Release版本则被忽略。</strong> </p><p> <strong>比较好的在程序中使用assert的地方</strong>：</p><p> <strong>(1)空指针检查</strong></p><p> 例如，针对一个函数的参数进行空指针检查。你可以这样使用：assert (pointer !&#x3D; NULL);，产生的错误会像这样：Assertion ‘pointer !&#x3D; ((void *)0)’ failed。这样，当出现空指针时，你的程序就会退出，并很好的给出错误信息。</p><p> <strong>(2)检查函数参数的值</strong></p><p> 例如，如果一个函数只能在它的一个参数foo为正值的时候被调用，你可以在函数开始时这样写:assert (foo &gt; 0);，这将帮助你检测函数的错误使用，这也给源代码阅读者很清晰的印象，那就是在这里对函数的参数值有限制。</p><h3 id="sizeof和strlen"><a href="#sizeof和strlen" class="headerlink" title="sizeof和strlen"></a>sizeof和strlen</h3><p>strlen与 sizeof的差别表现在以下5个方面：</p><ul><li>sizeof是运算符（是不是被弄糊涂了？事实上， sizeof既是关键字，也是运算符，但不是函数），而strlen是函数。 sizeof后如果是类型，则必须加括号，如果是变量名，则可以不加括弧。</li><li>sizeof运算符的结果类型是 size_t，它在头文件中 typedef为 unsigned int类型。该类型保证能够容纳实现所建立的最大对象的字节大小。</li><li>sizeof可以用类型作为参数， strlen只能用char*作参数，而且必须是以“0结尾的。 sizeof还可以以函数作为参数，如int g（），则 sizeof（g（））的值等于 sizeof（ int的值，在32位计算机下，该值为4。</li><li>大部分编译程序的 sizeof都是在<strong>编译</strong>的时候计算的，所以可以通过 sizeof（x）来定义数组维数。而 strlen则是在<strong>运行期</strong>计算的，用来计算字符串的实际长度，不是类型占内存的大小。例如， charstr[20] &#x3D; “0123456789”，字符数组str是<strong>编译期</strong>大小已经固定的数组，在32位机器下，为sizeof（char）*20&#x3D;20，而其 strlen大小则是在<strong>运行期</strong>确定的，所以其值为字符串的实际长度10。</li><li>当数组作为参数传给函数时，传递的是指针，而不是数组，即传递的是数组的首地址。</li></ul><p><strong>例1</strong>：不使用sizeof，如何求int占用的字节数？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MySizeof(Value) (char *)(&amp;value+1)-(char*)&amp;value</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i ;</span><br><span class="line"><span class="type">double</span> f;</span><br><span class="line"><span class="type">double</span> *q;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,MySizeof(i));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,MySizeof(f));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,MySizeof(a));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>,MySizeof(q));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中， <code>（char*）&amp; Value </code>返回 Value的地址的第一个字节， <code>（char*）（&amp; Value+1）</code> 返回value的地址的下一个地址的第一个字节，所以它们之差为它所占的字节数。</p><p><strong>例2</strong>：比较：strlen(“\0”)&#x3D;?与sizeof(“\0”)&#x3D;?</p><p><strong>结果比较</strong>：strlen(“\0”) &#x3D;0，sizeof(“\0”)&#x3D;2。</p><p><strong>具体含义</strong>：<strong>strlen</strong>用来计算<strong>字符串的长度</strong>（在C&#x2F;C++中，字符串是以**”\0”<strong>作为结束符的），它从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描直到碰到第一个字符串结束符\0为止，然后返回计数器值。</strong>sizeof<strong>是C语言的关键字，它以</strong>字节的形式<strong>给出了其操作数的</strong>存储大小**，操作数可以是一个表达式或括在括号内的类型名，操作数的存储大小由操作数的类型决定。</p><h3 id="struct与union的区别"><a href="#struct与union的区别" class="headerlink" title="struct与union的区别"></a>struct与union的区别</h3><p>struct（结构体）与 union（联合体）是C语言中两种不同的数据结构，两者都是常见的复合结构，其区别主要表现在以下两个方面。</p><ul><li>结构体与联合体虽然都是由多个不同的数据类型成员组成的，但不同之处在于联合体中所有成员<strong>共用一块地址空间</strong>，即联合体只存放了一个被选中的成员，而结构体中所有成员占用空间是累加的，其所有成员都存在，不同成员会存放在不同的地址。在计算一个<u>结构型变量</u>的总长度时，其内存空间大小等于<strong>所有成员长度之和</strong>（需要考虑字节对齐），而在<u>联合体</u>中，所有成员不能同时占用内存空间，它们不能同时存在，所以<strong>一个联合型变量的长度等于其最长的成员的长度</strong>。</li><li>对于联合体的不同成员赋值，<strong>将会对它的其他成员重写</strong>，原来成员的值就不存在了，而对结构体的不同成员赋值是互不影响的。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span><span class="type">double</span> i; <span class="type">int</span> k[<span class="number">5</span>]; <span class="type">char</span> c;&#125;DATE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title function_">data</span><span class="params">( <span class="type">int</span> cat; DATE cow;<span class="type">double</span> dog;）too;</span></span><br><span class="line"><span class="params">DATE max;</span></span><br><span class="line"><span class="params"><span class="built_in">printf</span> (<span class="string">&quot;%d&quot;</span>, <span class="keyword">sizeof</span>(too)+<span class="keyword">sizeof</span>(max));</span></span><br></pre></td></tr></table></figure><p>以上代码中，假设为32位机器，int型占4个字节， double型占8个字节，char型占1个字节，而DATE是一个联合型变量，联合型变量共用空间，uion里面最大的变量类型是int[5]，所以占用20个字节，它的大小是20，而由于 union中 double占了8个字节，因此 union是要8个字节对齐，所占内存空间为8的倍数。为了实现8个字节对齐，所占空间为24.而data是一个结构体变量，每个变量分开占用空间，依次为 sizeof（int）+ sizeof（DATE）+ sizeof（ double）&#x3D;4+24+8&#x3D;36按照8字节对齐，占用空间为40，所以结果为40+24&#x3D;64。</p><h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h3><p>左值是指可以出现在等号左边的变量或表达式，它最重要的特点就是<strong>可写</strong>（可寻址）。也就是说，它的值<strong>可以被修改</strong>，如果一个<strong>变量或表达式的值不能被修改</strong>，那么它就不能作为左值。右值是指<strong>只可以出现在等号右边的变量或表达式</strong>。它最重要的特点是<strong>可读</strong>。一般的使用场景都是把一个右值赋值给一个左值。通常，左值可以作为右值，但是右值不一定是左值。</p><h3 id="短路求值"><a href="#短路求值" class="headerlink" title="短路求值"></a>短路求值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">0</span>||(j++)&gt;<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%D\r\n&quot;</span>,j);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为1。</p><p>输出为什么不是2，而是1呢？其实，这里就涉及一个短路计算的问题。由于i语句是个条件判断语句，里面是有两个简单语句进行或运算组合的复合语句，因为或运算中，只要参与或运算的两个表达式的值<strong>其中一个为真</strong>，则整个运算结果为真，而由于变量i的值为6，已经大于0了，而该语句已经为true，则<u>不需要执行后续的j+操作</u>来判断真假，所以后续的j++操作不需要执行，j的值仍然为1。</p><p>因为短路计算的问题，对于&amp;&amp;操作，由于在两个表达式的返回值中，如果有一个为假则整个表达式的值都为假，如果前一个语句的返回值为 false，则无论后一个语句的返回值是真是假，整个条件判断都为假，不用执行后一个语句，而a&gt;b的返回值为 false，程序不执行表达式n&#x3D;c&gt;d，所以，n的值保持为初值2。</p><h3 id="a和a-的区别"><a href="#a和a-的区别" class="headerlink" title="++a和a++的区别"></a>++a和a++的区别</h3><p>a++的具体运算过程为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">temp=a+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br></pre></td></tr></table></figure><p>++a的具体运算过程为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=a+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br></pre></td></tr></table></figure><p>后置自增运算符需要把原来变量的值复制到一个<strong>临时的存储空间</strong>，等运算结束后才会返回这个临时变量的值，所以<strong>前置自增运算符效率比后置自增要高</strong>。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="全局变量和静态变量的区别"><a href="#全局变量和静态变量的区别" class="headerlink" title="全局变量和静态变量的区别"></a>全局变量和静态变量的区别</h3><ul><li>全局变量的作用域为程序块，而局部变量的作用域为当前函数。</li><li>内存存储方式不同，全局变量（静态全局变量，静态局部变量）分配在全局数据区（静态存储空间），后者分配在栈区。</li><li>生命周期不同。全局变量随主程序创建而创建，随主程序销毁而销毁，局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在了。</li><li>使用方式不同。通过声明为全局变量，程序的各个部分都可以用到，而局部变量只能在局部使用。</li></ul><h3 id="全局变量可不可以定义在可被多个-C文件包含的头文件中"><a href="#全局变量可不可以定义在可被多个-C文件包含的头文件中" class="headerlink" title="全局变量可不可以定义在可被多个.C文件包含的头文件中"></a>全局变量可不可以定义在可被多个.C文件包含的头文件中</h3><p>可以，在不同的C文件中以static形式来声明<strong>同名全局变量</strong>。</p><p>可以在不同的C文件中声明同名的全局变量，前提是其中<strong>只能有一个C文件中对此变量赋初值</strong>，此时连接不会出错。</p><h3 id="局部变量能否和全局变量重名"><a href="#局部变量能否和全局变量重名" class="headerlink" title="局部变量能否和全局变量重名"></a>局部变量能否和全局变量重名</h3><p>能，局部会屏蔽全局。</p><p>局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。</p><p>对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>1、解释以下数组</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(a[<span class="number">1</span>]+<span class="number">1</span>)、*(&amp;a[<span class="number">1</span>][<span class="number">1</span>])、(*(a+<span class="number">1</span>))[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>第一个： 因为a[1]是第2行的地址，a[1]+1偏移一个单位（得到第2行第2列的地址），然后解引用取值，得到<code>a[1][1]</code>；</p><p>第二个：[]优先级高，<code>a[1][1]</code>取地址再取值。</p><p>第三个：a+1相当于&amp;a[1]，所以* (a+1）&#x3D;a[1]，因此<code>*(a+1)[1]=a[1][1]</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">(<span class="type">int</span>*)(&amp;a+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>对于数组int a[5]；a表示数组首元素的地址，而&amp;a表示数组的首地址。</p><p> a有两层含义：一是a表示数组<strong>首元素的地址</strong>（类型为int*）；二是<strong>a表示一个大小为5的int数组</strong>（重要）<strong>。数组名本身在计算中会自动转化成第一个元素的地址，</strong>但<strong>sizeof测试的时候不做计算，不转化</strong>。由此可以看出，在计算 *（a+1） 的时候，可以把a看成int类型的指针，a+1表示的是数组第二个元素的指针，由此 *(a+1) 的值为2。但是， sizeof（a） 是把a作为一个<strong>数组类型</strong>来测试大小，结果是数组占用的<strong>字节数</strong>，由此 sizeof（a）&#x3D;20</p><p> &amp;a是一个指向<code>int(*)[5]</code>的指针。由于&amp;a是一个指针，那么在32位机器上， sizeof（&amp;a）&#x3D;4 ，但是**&amp;a+1的值取决于&amp;a指向的类型<strong>，由于&amp;a指向<code> int(*)[5]</code> ，所以 &amp;a+1&#x3D;&amp;a+ sizeof(int(*)[5])&#x3D;&amp;a+20 。&amp;a是数组的首地址，由此&amp;a+1表示a向后移动了</strong>5个int**从而指向a[5]，所以ptr指向的是a[5]，由于ptr是 int * 类型，那么ptr-1就指向a[4]，所以 *(ptr-1)&#x3D;a[4]&#x3D;5。</p><p> 由此可知 <code>（int*）&amp;（a+1）</code> 指向了数组a最后一个元素之后的下一个内存单元开始的4个字节 (int *) 内存.</p><p><strong>2、数组下标可以为负数吗？</strong></p><p>可以，因为下标只是给出了一个与<strong>当前地址的偏移量</strong>而已，只要根据这个偏移量能定位得到目标地址即可。下面给出一个下标为负数的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p=&amp;a[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>（i=<span class="number">-4</span>；i&lt;=<span class="number">0</span>；i++）</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %x\n&quot;</span>, p[i], &amp;p[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果为</span></span><br><span class="line"><span class="comment">//0 b3ecf480</span></span><br><span class="line"><span class="comment">//1 b3ecf484</span></span><br><span class="line"><span class="comment">//2 b3ecf488</span></span><br><span class="line"><span class="comment">//3 b3ecf48c</span></span><br><span class="line"><span class="comment">//4 b3ecf490</span></span><br></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="数组指针和指针数组"><a href="#数组指针和指针数组" class="headerlink" title="数组指针和指针数组"></a>数组指针和指针数组</h3><p><strong>数组指针</strong>就是指向数组的指针，它表示的是一个指针，这个指针指向的是一个数组，它的重点是指针<code>(*p)</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio. h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib. h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> b[<span class="number">12</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="type">int</span> (*p)[<span class="number">4</span>];</span><br><span class="line">    p = b;</span><br><span class="line">    <span class="built_in">printf</span>（<span class="string">&quot;%d\n&quot;</span>， **(++p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例程序的输出结果为 5。p是一个数组指针，它指向一个<strong>包含有4个int</strong>类型数组的指针，刚开始p被初始化为指向数组b的首地址，++p相当于把p所指向的地址<strong>向后移动4个int</strong>所占用的空间，此时p指向数组{5,6,7,8}，语句<code>*（++p）</code>表示的是这个数组中<strong>第一个元素</strong>的地址(可以理解p为指向二维数组的指针，｛1,2,3,4｝，｛5,6,7,8｝，｛9,10,11,12｝。p指向的就是｛1,2,3,4｝的地址，<code>*p</code>就是指向元素，｛1,2,3,4｝， <code>**p</code>指向的就是1，语句**（++p）会输出这个数组的第一个元素5。</p><p><strong>指针数组</strong>表示的是一个数组，而数组中的元素是指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> *p[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> a[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    p[<span class="number">0</span>] = &amp;a[<span class="number">0</span>];</span><br><span class="line">    p[<span class="number">1</span>] = &amp;a[<span class="number">1</span>];</span><br><span class="line">    p[<span class="number">2</span>] = &amp;a[<span class="number">2</span>];</span><br><span class="line">    p[<span class="number">3</span>] = &amp;a[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果为1234。</p><h3 id="函数指针和指针函数"><a href="#函数指针和指针函数" class="headerlink" title="函数指针和指针函数"></a>函数指针和指针函数</h3><p>1)<strong>函数指针</strong></p><p><strong>函数指针</strong>：如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个<strong>函数的地址</strong>。而且函数名表示的就是这个地址。既然是地址我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称<strong>函数指针</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>(*p)(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>这个语句就定义了一个指向函数的指针变量 p。首先它是一个指针变量，所以要有一个<code>(*p)</code>；其次前面的 int 表示这个指针变量可以指向返回值类型为 int 型的函数；后面括号中的两个 int 表示这个指针变量可以指向有两个参数且都是 int 型的函数。所以合起来就是：定义了一个指针变量 p，该指针变量可以指向返回值类型为 int 型，且有两个整型参数的函数。p 的类型为<code>int(*)(int,int)</code>。</p><p>函数指针的定义就是将“函数声明”中的“函数名”改成“（指针变量名）<em>”</em>。但是这里需要注意的是：<em>“</em>（指针变量名）”<strong>两端的括号不能省略</strong>，括号改变了运算符的优先级。如果省略了括号，就不是定义函数指针而是一个函数声明了，即声明了一个返回值类型为指针型的函数。</p><p><strong>最后需要注意的是，指向函数的指针变量没有++和–运算。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Max</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>; <span class="comment">//函数声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>(*p)(<span class="type">int</span>, <span class="type">int</span>); <span class="comment">//定义一个函数指针</span></span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    p = Max; <span class="comment">//把函数Max赋给指针变量p, 使p指向Max函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please enter a and b:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    c = (*p)(a, b); <span class="comment">//通过函数指针调用Max函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\nb = %d\nmax = %d\n&quot;</span>, a, b, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="comment">//定义Max函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        z = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        z = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1)<strong>指针函数</strong></p><p>首先它是一个函数，只不过这个函数的返回值是一个地址值。函数返回值必须用同类型的指针变量来接受，也就是说，指针函数一定有“函数返回值”，而且，在主调函数中，函数返回值必须赋给同类型的指针变量。</p><p><code>类型名 *函数名(函数参数列表);</code></p><p>其中，后缀运算符括号“()”表示这是一个函数，其前缀运算符星号“*”表示此函数为指针型函数，其函数值为指针，即它带回来的值的类型为指针，当调用这个函数后，将得到一个“指向返回值为…的指针（地址），“类型名”表示函数返回的指针指向的类型”。</p><p>“(函数参数列表)”中的括号为函数调用运算符，在调用语句中，即使函数不带参数，其参数表的一对括号也不能省略。其示例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">pfun</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">float</span> *<span class="title function_">find</span><span class="params">(<span class="type">float</span>(*pionter)[<span class="number">4</span>],<span class="type">int</span> n)</span>;<span class="comment">//函数声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> score[][<span class="number">4</span>]=&#123;&#123;<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>&#125;,&#123;<span class="number">56</span>,<span class="number">89</span>,<span class="number">34</span>,<span class="number">45</span>&#125;,&#123;<span class="number">34</span>,<span class="number">23</span>,<span class="number">56</span>,<span class="number">45</span>&#125;&#125;;</span><br><span class="line">    <span class="type">float</span> *p;</span><br><span class="line">    <span class="type">int</span> i,m;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the number to be found:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the score of NO.%d are:\n&quot;</span>,m);</span><br><span class="line">    p=find(score,m<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5.2f\t&quot;</span>,*(p+i));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> *<span class="title function_">find</span><span class="params">(<span class="type">float</span>(*pionter)[<span class="number">4</span>],<span class="type">int</span> n)</span><span class="comment">/*定义指针函数*/</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> *pt;</span><br><span class="line">    pt=*(pionter+n);</span><br><span class="line">    <span class="keyword">return</span>(pt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序中，函数find()被定义为指针函数，其形参pointer是指针指向包含4个元素的一维数组的指针变量。pointer+n指向score的第n+1行。*(pointer+1)指向第一行的第0个元素。pt是一个指针变量，它指向浮点型变量。main()函数中调用find()函数，将score数组的首地址传给pointer。</p><h3 id="数组名和指针的区别"><a href="#数组名和指针的区别" class="headerlink" title="数组名和指针的区别"></a>数组名和指针的区别</h3><ul><li><strong>数据保存方面</strong></li></ul><p>指针保存的是地址（保存目标数据地址，自身地址由编译器分配），内存访问偏移量为4个字节，无论其中保存的是何种数据均已地址类型进行解析。</p><p>数组保存的数据。数组名表示的是第一个元素的地址，内存偏移量是保存数据类型的内存偏移量；只有对数组名取地址（&amp;数组名）时数组名才表示整个数组，<strong>内存偏移量是整个数组的大小（sizeof(数组名)）</strong>。</p><ul><li><strong>数据访问方面</strong></li></ul><p>指针对数据的访问方式是间接访问，需要用到解引用符号（*指针）。</p><p>数组对数据的访问则是直接访问，可通过下标访问或数组名+元素偏移量的方式。</p><ul><li><strong>使用环境</strong></li></ul><p>指针多用于动态数据结构（如链表，等等）和动态内存开辟。</p><p>数组多用于存储固定个数且类型统一的数据结构（如线性表等等）和隐式分配。</p><h3 id="指针进行强制类型转换后与地址进行加法运算，结果是什么？"><a href="#指针进行强制类型转换后与地址进行加法运算，结果是什么？" class="headerlink" title="指针进行强制类型转换后与地址进行加法运算，结果是什么？"></a>指针进行强制类型转换后与地址进行加法运算，结果是什么？</h3><p>假设在32位机器上，在对齐为4的情况下,sizeof(long)的结果为4字节，sizeof(char*)的结果为4字节，sizeof(short int)的结果与 sizeof(short)的结果都为2字节， sizeof(char)的结果为1字节， sizeof(int)的结果为4字节，由于32位机器上是4字节对齐，以如下结构体为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BBB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> num;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> data;</span><br><span class="line">    <span class="type">char</span> ha;</span><br><span class="line">    <span class="type">short</span> ba[<span class="number">5</span>];</span><br><span class="line">&#125;*p;</span><br></pre></td></tr></table></figure><p>当<code> p=0x100000; 则 p+0×200=? (ulong)p+0x200=? (char*)p+0x200=?</code></p><p>其实,在32位机器下,<code>sizeof(struct BBB)=sizeof(*p)=4+4+2+2+1+3/*补齐*/+2*5+2/*补齐*/=24字节</code>，而 p&#x3D;0x100000 ,那么<code>p+0x200=0x1000000+0x200*24</code>指针加法，加出来的是指针所指类型的字节长度的整倍数，就是p偏移sizeof(p)*0x200。</p><p><code>(ulong)p+0x200=0x10000010+0x200 </code>经过ulong后,已经不再是指针加法，而变成一个数值加法了。</p><p><code>(char*)p+0x200=0x1000000+0×200*sizeof(char) </code>结果类型是char*。</p><h3 id="指针常量和常量指针"><a href="#指针常量和常量指针" class="headerlink" title="指针常量和常量指针"></a>指针常量和常量指针</h3><p>1、<strong>指针常量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="type">const</span> p</span><br></pre></td></tr></table></figure><p>p是一个常量类型的指针，<strong>不能修改这个指针的指向</strong>，但是这个指针所指向的地址上存储的<strong>值可以修改</strong>。</p><p>2、<strong>常量指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *p</span><br></pre></td></tr></table></figure><p>常量指针指向一个常量，不能通过指针来修改这个指针<strong>指向的值</strong>。</p><p>1、 <strong>指向常量的常量指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p</span><br></pre></td></tr></table></figure><p>必须同时满足上述1和2中的内容，<strong>既不可以修改指针的值，也不可以修改指针指向的值</strong>。</p><h3 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h3><p>1、<strong>相同点</strong></p><ul><li><p>都是地址的概念，指针指向某一内存、它的内容是所指内存的地址；引用则是某块内存的别名。</p></li><li><p>从内存分配上看：两者都占内存，程序为指针会分配内存，一般是4个字节；而引用的本质是指针</p><p>  常量，指向对象不能变，但指向对象的值可以变。</p></li></ul><p>2、<strong>不同点</strong></p><ul><li><p>指针是实体，而引用是别名。</p></li><li><p>指针和引用的自增（++）运算符意义不同，指针是对内存地址自增，而引用是对值的自增。</p></li><li><p>引用使用时无需解引用(*)，指针需要解引用；</p></li><li><p>引用只能在定义时被初始化一次，之后不可变；指针可变。</p></li><li><p>引用不能为空，指针可以为空。</p></li><li><p>“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小，在32</p><p>  位系统指针变量一般占用4字节内存。</p></li></ul><p>3、<strong>相互转换</strong></p><ul><li><strong>指针转引用</strong>：把指针用*就可以转换成对象，可以用在引用参数当中。</li><li><strong>引用转指针</strong>：把引用类型的对象用&amp;取地址就获得指针了。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> &amp;x)</span>&#123;&#125;<span class="comment">//此时调用fun可使用 ： fun（*p）;</span></span><br><span class="line"><span class="comment">//p是指针，加个*号后可以转换成该指针指向的对象，此时fun的形参是一个引用值,</span></span><br><span class="line"><span class="comment">//p指针指向的对象会转换成引用X。</span></span><br></pre></td></tr></table></figure><h3 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h3><p>1、相关概念</p><ul><li><p>野指针是指向不可用内存的指针，当指针被创建时，指针不可能自动指向NULL，这时，默认值是随机的，此时的指针成为野指针。</p></li><li><p>当指针被free或delete释放掉时，如果没有把指针设置为NULL，则会产生野指针，因为释放掉的仅仅是指针指向的内存，并没有把指针本身释放掉。</p></li><li><p>第三个造成野指针的原因是指针操作超越了变量的作用范围。</p></li></ul><p>2、避免</p><ul><li>对指针进行初始化。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将指针初始化为NULL。</span></span><br><span class="line"><span class="type">char</span> * p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//用malloc分配内存</span></span><br><span class="line"><span class="type">char</span> * p = (<span class="type">char</span> * )<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line"><span class="comment">//用已有合法的可访问的内存地址对指针初始化</span></span><br><span class="line"><span class="type">char</span> num[ <span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">char</span> *p = num;</span><br></pre></td></tr></table></figure><ul><li>指针用完后释放内存，将指针赋NULL。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete(p);</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>注：malloc函数分配完内存后需注意：</p><p>a. 检查是否分配成功（若分配成功，返回内存的首地址；分配不成功，返回NULL。可以通过if语句来判断）</p><p>b. 清空内存中的数据（malloc分配的空间里可能存在垃圾值，用memset或bzero 函数清空内存）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//s是需要置零的空间的起始地址； n是要置零的数据字节个数。</span></span><br><span class="line"><span class="type">void</span> bzero（<span class="type">void</span> *s, <span class="type">int</span> n）;</span><br><span class="line"><span class="comment">// 如果要清空空间的首地址为p，value为值，size为字节数。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memset</span><span class="params">(<span class="type">void</span> *start, <span class="type">int</span> value, <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a><strong>智能指针</strong></h3><p>智能指针是一个类，用来存储指针（指向动态分配对象的指针）。</p><p>C++程序设计中使用堆内存是非常频繁的操作，堆内存的申请和释放都由程序员自己管理。程序员自己管理堆内存可以提高了程序的效率，但是整体来说堆内存的管理是麻烦的，C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。</p><p><strong>智能指针的内存泄漏</strong></p><p>为了解决循环引用导致的内存泄漏，引入了弱指针 weak_ptr ， weak_ptr 的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但是不会指向引用计数的共享内存，但是可以检测到所管理的对象是否已经被释放，从而避免非法访问。</p><h2 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h2><p>1、求解整型数的二进制表示中1的个数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> countx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        countx++;</span><br><span class="line">        x = x&amp;(x<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> countx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,func(<span class="number">9999</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、求解二进制中0的个数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CountZeroBit</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        num |= (num + <span class="number">1</span>); <span class="comment">//算法转换</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">25</span>;</span><br><span class="line">    <span class="type">int</span> ret = CountZeroBit(value);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d的二进制位中0的个数为%d\n&quot;</span>,value, ret);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、交换两个变量的值，不使用第三个变量。</p><p>方法1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a + b;</span><br><span class="line">b = a - b;</span><br><span class="line">a = a - b;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = a^b;<span class="comment">// 只能对int,char..</span></span><br><span class="line">b = a^b;</span><br><span class="line">a = a^b;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">a ^= b ^= a;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="写个函数在main函数执行前先运行"><a href="#写个函数在main函数执行前先运行" class="headerlink" title="写个函数在main函数执行前先运行"></a>写个函数在main函数执行前先运行</h3><p><strong>attribute</strong>可以设置函数属性（Function Attribute）、变量属性（Variable Attribute）和类型属性（Type Attribute）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">before</span><span class="params">()</span> __<span class="title function_">attribute__</span><span class="params">((constructor))</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">after</span><span class="params">()</span> __<span class="title function_">attribute__</span><span class="params">((destructor))</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is function %s\n&quot;</span>,__func__);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is function %s\n&quot;</span>,__func__);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this is function %s\n&quot;</span>,__func__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// this is function before</span></span><br><span class="line"><span class="comment">// this is function main</span></span><br><span class="line"><span class="comment">// this is function after</span></span><br></pre></td></tr></table></figure><h3 id="C语言是怎么进行函数调用的"><a href="#C语言是怎么进行函数调用的" class="headerlink" title="C语言是怎么进行函数调用的"></a>C语言是怎么进行函数调用的</h3><p>大多数CPU上的程序实现<strong>使用栈来支持函数调用操作</strong>，栈被用来传递函数参数、存储返回信息、临时保存寄存器原有的值以备恢复以及用来存储局部变量。</p><p>函数调用操作所使用的栈部分叫做<strong>栈帧结构</strong>，每个函数调用都有属于自己的栈帧结构，栈帧结构由两个指针指定，帧指针（指向起始），栈指针（指向栈顶），函数对大多数数据的访问都是基于帧指针。下面是结构图：</p><style>.opykqsaigtyo{zoom:67%;}</style><img src="/2024/04/09/%E5%85%AB%E8%82%A1%E6%96%87-C%E8%AF%AD%E8%A8%80/image-20240620092854360.png" class="opykqsaigtyo" alt="image-20240620092854360"><p>栈指针和帧指针一般都有专门的寄存器，通常使用ebp寄存器作为帧指针，使用esp寄存器做栈指针。</p><p><strong>帧指针指向栈帧结构的头，存放着上一个栈帧的头部地址，栈指针指向栈顶。</strong></p><h3 id="void-函数的返回值问题"><a href="#void-函数的返回值问题" class="headerlink" title="void 函数的返回值问题"></a><strong>void</strong> 函数的返回值问题</h3><p>void 函数可以写return;表示程序结束，但是没有返回值。</p><p> 在软件开发过程中有一种很常见的编程方法，就是即使将参数传给无返回值的void函数也能实现对原始参数值的修改。</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="C语言中内存分配的方式"><a href="#C语言中内存分配的方式" class="headerlink" title="C语言中内存分配的方式"></a>C语言中内存分配的方式</h3><ul><li><strong>静态存储区分配</strong></li></ul><p>内存分配在程序编译之前完成，且在程序的整个运行期间都存在，例如全局变量、静态变量等。</p><ul><li><strong>栈上分配</strong></li></ul><p>在函数执行时，函数内的局部变量的存储单元在栈上创建，函数执行结束时这些存储单元自动释放。</p><ul><li><strong>堆上分配</strong></li></ul><h3 id="堆与栈的区别"><a href="#堆与栈的区别" class="headerlink" title="堆与栈的区别"></a><strong>堆与栈的区别</strong></h3><ul><li><strong>申请方式</strong></li></ul><p>栈的空间由操作系统自动分配&#x2F;释放，堆上的空间手动分配&#x2F;释放。</p><ul><li><strong>申请大小的限制</strong></li></ul><p>栈空间有限。在Windows下,栈是向<strong>低地址</strong>扩展的数据结 构，是一块<strong>连续的内存的区域</strong>。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是 一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow溢出。因此，能<strong>从栈获得的空间较小</strong>。</p><p>堆是很大的自由存储区。堆是向<strong>高地址</strong>扩展的数据结构，是不连续的内存区域。这是由于系统是用<strong>链表来存储的空闲内存地址的</strong>，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小<strong>受限于计算机系统中有效的虚拟内存</strong>。由此可见，堆获得的空间比较灵活，也比较大。</p><ul><li><strong>申请效率</strong></li></ul><p>栈由系统自动分配，速度较快。但程序员是无法控制的。</p><p>堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.</p><h3 id="栈在C语言中的作用"><a href="#栈在C语言中的作用" class="headerlink" title="栈在C语言中的作用"></a>栈在C语言中的作用</h3><ul><li><p>C语言中栈用来存储临时变量，临时变量包括<strong>函数参数和函数内部定义的临时变量</strong>。函数调用中和函数调用相关的<strong>函数返回地址</strong>，函数中的临时变量，寄存器等均保存在栈中，函数调动返回后从栈中恢复寄存器和临时变量等函数运行场景。</p></li><li><p>多线程编程的基础是栈，<strong>栈是多线程编程的基石</strong>，每一个线程都最少有一个自己专属的栈，用来存储本线程运行时各个函数的临时变量和维系函数调用和函数返回时的函数调用关系和函数运行场景。 操作系统最基本的功能是支持多线程编程，支持中断和异常处理，每个线程都有专属的栈，中断和异常处理也具有专属的栈，栈是操作系统多线程管理的基石。</p></li></ul><h3 id="C语言函数参数压栈顺序"><a href="#C语言函数参数压栈顺序" class="headerlink" title="C语言函数参数压栈顺序"></a>C语言函数参数压栈顺序</h3><p>从右至左。</p><p>C语言参数入栈顺序的好处就是可以动态变化参数个数。如果是自左向右的入栈方式，最前面的参数被压在栈底。除非知道参数个数，否则是无法通过栈指针的相对位移求得最左边的参数。这样就变成了左边参数的个数不确定，正好和动态参数个数的方向相反。因此，Ｃ语言函数参数采用自右向左的入栈顺序，主要原因是为了支持可变长参数形式。</p><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>简单地说就是申请了一块内存空间，使用完毕后没有释放掉。</p><p>它的一般表现方式是程序运行时间越长，占用内存越多，最终用尽全部内存，整个系统崩溃。由程序申请的一块内存，且没有任何一个指针指向它，那么这块内存就泄露了。</p><p><strong>如何判断</strong></p><ul><li><p>良好的编码习惯，尽量在涉及内存的程序段，检测出内存泄露。当程式稳定之后，在来检测内存泄露时，无疑增加了排除的困难和复杂度。使用了内存分配的函数，一旦使用完毕,要记得要使用其相应的函数释放掉。</p></li><li><p>将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。</p></li><li><p>Boost 中的smart pointer。</p></li><li><p>一些常见的工具插件，如ccmalloc、Dmalloc、Leaky等等。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RT-Thread：STM32移植记录</title>
      <link href="/2024/03/31/RT-Thread%EF%BC%9ASTM32%E7%A7%BB%E6%A4%8D%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/03/31/RT-Thread%EF%BC%9ASTM32%E7%A7%BB%E6%A4%8D%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="资料来源"><a href="#资料来源" class="headerlink" title="资料来源"></a>资料来源</h2><p><a href="https://blog.csdn.net/m0_47329175/article/details/130349890">https://blog.csdn.net/m0_47329175/article/details/130349890</a></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>RT-Thread Nano：<a href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-nano/an0038-nano-introduction">https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-nano/an0038-nano-introduction</a></p><style>.xldagfymucho{zoom:67%;}</style><img src="/2024/03/31/RT-Thread%EF%BC%9ASTM32%E7%A7%BB%E6%A4%8D%E8%AE%B0%E5%BD%95/image-20240331151909449.png" class="xldagfymucho" alt="image-20240331151909449"><p>文件夹内容组成：</p><table><thead><tr><th>文件夹</th><th>描述</th></tr></thead><tbody><tr><td>bsp</td><td>板级支持包</td></tr><tr><td>components&#x2F;finsh</td><td>RT-Thread组件</td></tr><tr><td>include</td><td>头文件</td></tr><tr><td>include&#x2F;libc</td><td>头文件</td></tr><tr><td>libcpu</td><td>与处理器相关的接口文件</td></tr><tr><td>src</td><td>RT-Thread内核源码</td></tr></tbody></table><h2 id="精简文件"><a href="#精简文件" class="headerlink" title="精简文件"></a>精简文件</h2><p>先额外复制一份源码，再修改。</p><p>1、打开rt-thread文件夹，将以下无用文件删除</p><style>.zsrxgfqqdldo{zoom:50%;}</style><img src="/2024/03/31/RT-Thread%EF%BC%9ASTM32%E7%A7%BB%E6%A4%8D%E8%AE%B0%E5%BD%95/image-20240331152513335.png" class="zsrxgfqqdldo" alt="image-20240331152513335"><p>2、打开rt-thread&#x2F;bsp文件夹，将以下无用文件删除</p><style>.uboiwujfmwgw{zoom:50%;}</style><img src="/2024/03/31/RT-Thread%EF%BC%9ASTM32%E7%A7%BB%E6%A4%8D%E8%AE%B0%E5%BD%95/image-20240331152200942.png" class="uboiwujfmwgw" alt="image-20240331152200942"><p>3、打开rt-thread&#x2F;libcpu文件夹，将以下无用文件删除（这里MCU为STM32F103）：</p><style>.lzkrsebfojuf{zoom:67%;}</style><img src="/2024/03/31/RT-Thread%EF%BC%9ASTM32%E7%A7%BB%E6%A4%8D%E8%AE%B0%E5%BD%95/image-20240331152305061.png" class="lzkrsebfojuf" alt="image-20240331152305061"><style>.hgukmbvscwwr{zoom: 50%;}</style><img src="/2024/03/31/RT-Thread%EF%BC%9ASTM32%E7%A7%BB%E6%A4%8D%E8%AE%B0%E5%BD%95/image-20240331152349550.png" class="hgukmbvscwwr" alt="image-20240331152349550"><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>使用CubeMX新建一个工程并生成代码，把修改后的<code>RT-Thread</code>目录及文件移动到工程目录：</p><style>.wxndkiwlunyr{zoom:67%;}</style><img src="/2024/03/31/RT-Thread%EF%BC%9ASTM32%E7%A7%BB%E6%A4%8D%E8%AE%B0%E5%BD%95/image-20240331153320077.png" class="wxndkiwlunyr" alt="image-20240331153320077"><p>在<code>RT-Thread</code>目录下新建一个rt_thread.mk文件，添加以下内容：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#file rt_thread.mk</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rt-thread头文件</span></span><br><span class="line">C_INCLUDES += -I./rt-thread/bsp     \</span><br><span class="line">-I./rt-thread/src \</span><br><span class="line">-I./rt-thread/<span class="keyword">include</span> \</span><br><span class="line">-I./rt-thread/<span class="keyword">include</span>/libcpu/arm/cortex-m3 \</span><br><span class="line">-I./rt-thread/components/finsh \</span><br><span class="line">-I./rt-thread/components/device \</span><br><span class="line"></span><br><span class="line"><span class="comment"># rt-thread c源码</span></span><br><span class="line">C_SOURCES += <span class="variable">$(<span class="built_in">wildcard</span> ./rt-thread/bsp/*.c)</span>               \</span><br><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> ./rt-thread/libcpu/cortex-m3/*.c)</span>  \</span><br><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> ./rt-thread/src/*.c)</span>\</span><br><span class="line"></span><br><span class="line"><span class="comment"># rt-thread 汇编接口源码</span></span><br><span class="line">ASM_SOURCES += <span class="variable">$(<span class="built_in">wildcard</span> ./rt-thread/libcpu/cortex-m3/*.S)</span>  \</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在工程目录的Makefile文件中添加rt_thread.mk文件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include ./rt-thread/rt_thread.mk</span></span><br></pre></td></tr></table></figure><style>.cnpatjlhkvnd{zoom:67%;}</style><img src="/2024/03/31/RT-Thread%EF%BC%9ASTM32%E7%A7%BB%E6%A4%8D%E8%AE%B0%E5%BD%95/image-20240331155112658.png" class="cnpatjlhkvnd" alt="image-20240331155112658"><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>测试：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mingw32-make</span><br></pre></td></tr></table></figure><style>.pmubiotgwkmf{zoom:67%;}</style><img src="/2024/03/31/RT-Thread%EF%BC%9ASTM32%E7%A7%BB%E6%A4%8D%E8%AE%B0%E5%BD%95/image-20240331155232213.png" class="pmubiotgwkmf" alt="image-20240331155232213"><p>出现错误。</p><p>SysTick_Handler、PendSV_Handler、HardFault_Handler这三个函数重复定义，因为在接口文件 <strong>context_gcc.S</strong> 中已经实现了，此时应该将 <strong>stm32f10x_it.c</strong> 中的这三个中断处理函数屏蔽掉。</p><style>.dwcgmouufdpm{zoom:67%;}</style><img src="/2024/03/31/RT-Thread%EF%BC%9ASTM32%E7%A7%BB%E6%A4%8D%E8%AE%B0%E5%BD%95/image-20240331155643828.png" class="dwcgmouufdpm" alt="image-20240331155643828"><p>待定。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> RT-Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32-VSCode和OpenOCD环境配置</title>
      <link href="/2024/03/31/STM32-VSCode%E5%92%8COpenOCD%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2024/03/31/STM32-VSCode%E5%92%8COpenOCD%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="资料来源"><a href="#资料来源" class="headerlink" title="资料来源"></a>资料来源</h2><p><a href="https://blog.csdn.net/m0_47329175/article/details/122607874">https://blog.csdn.net/m0_47329175/article/details/122607874</a></p><h2 id="VS-Code配置"><a href="#VS-Code配置" class="headerlink" title="VS Code配置"></a>VS Code配置</h2><p>先安装STM32CubeMx，参考<a href="https://blog.csdn.net/m0_47329175/article/details/121189421">https://blog.csdn.net/m0_47329175/article/details/121189421</a></p><p>其他所需软件如下：</p><ul><li>GNU Arm Embedded Toolchain</li><li>Mingw-w64</li><li>VSCode</li></ul><h3 id="GNU-Arm-Embedded-Toolchain"><a href="#GNU-Arm-Embedded-Toolchain" class="headerlink" title="GNU Arm Embedded Toolchain"></a>GNU Arm Embedded Toolchain</h3><p>下载：<a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads">https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads</a></p><h4 id="Mingw-w64"><a href="#Mingw-w64" class="headerlink" title="Mingw-w64"></a>Mingw-w64</h4><p>下载：<a href="https://www.mingw-w64.org/">https://www.mingw-w64.org/</a></p><h3 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h3><p>下载：<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p><h2 id="OpenOCD配置"><a href="#OpenOCD配置" class="headerlink" title="OpenOCD配置"></a>OpenOCD配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>下载：<a href="https://github.com/xpack-dev-tools/openocd-xpack/releases">https://github.com/xpack-dev-tools/openocd-xpack/releases</a></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>来源：<a href="https://blog.csdn.net/kangkanglhb88008/article/details/126037321">https://blog.csdn.net/kangkanglhb88008/article/details/126037321</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openocd -f scripts/interface/stlink.cfg -f scripts/target/stm32f1x.cfg -c init -c <span class="string">&quot;reset halt; wait_halt; flash write_image erase build/项目15.bin 0x08000000&quot;</span> -c reset -c shutdown</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li>openocd -f scripts&#x2F;interface&#x2F;stlink.cfg -f scripts&#x2F;target&#x2F;stm32f1x.cfg 用于连接OpenOCD</li><li>-c表示要执行的选项，-c init 用于初始化</li><li>-c “reset halt; wait_halt; flash write_image erase build&#x2F;项目15.bin 0x08000000” 表示执行命令，其中 <strong>reset halt; wait_hal</strong> 先停止单片机 （分号不能少），<strong>这句非常重要</strong></li><li>-c reset -c shutdown，表示复位单片机，且退出OpenOCD</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式工具-makefile</title>
      <link href="/2024/03/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B7%A5%E5%85%B7-Makefile/"/>
      <url>/2024/03/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B7%A5%E5%85%B7-Makefile/</url>
      
        <content type="html"><![CDATA[<h2 id="资料来源"><a href="#资料来源" class="headerlink" title="资料来源"></a>资料来源</h2><p><strong>推荐</strong></p><p><a href="https://www.ruanyifeng.com/blog/2015/02/make.html">https://www.ruanyifeng.com/blog/2015/02/make.html</a></p><p><a href="https://blog.csdn.net/weixin_38391755/article/details/80380786">https://blog.csdn.net/weixin_38391755/article/details/80380786</a></p><p><strong>全面</strong></p><p>书籍《跟我一起写Makefile》，整理：<a href="https://haoel.blog.csdn.net/article/details/2886">https://haoel.blog.csdn.net/article/details/2886</a></p><p><a href="https://chegva.com/3761.html">https://chegva.com/3761.html</a></p><h2 id="一、make、Makefile和-mk的概念"><a href="#一、make、Makefile和-mk的概念" class="headerlink" title="一、make、Makefile和.mk的概念"></a>一、make、Makefile和.mk的概念</h2><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>make这个词，英语的意思是”制作”。make命令直接用了这个意思，就是要做出某个文件。比如，要做出文件a.txt，就可以执行下面的命令。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make a.txt</span><br></pre></td></tr></table></figure></blockquote><p>但是，如果你真的输入这条命令，它并不会起作用。因为make命令本身并不知道，如何做出a.txt，需要有人告诉它，如何调用其他命令完成这个目标。</p><p>比如，假设文件 a.txt 依赖于 b.txt 和 c.txt ，是后面两个文件连接（cat命令）的产物。那么，make 需要知道下面的规则。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.txt: b.txt c.txt</span><br><span class="line"><span class="built_in">cat</span> b.txt c.txt &gt; a.txt</span><br></pre></td></tr></table></figure></blockquote><p>也就是说，make a.txt 这条命令的背后，实际上分成两步：第一步，确认 b.txt 和 c.txt 必须已经存在，第二步使用 cat 命令 将这个两个文件合并，输出为新文件。</p><p>像这样的规则，都写在一个叫做Makefile的文件中，make命令依赖这个文件进行构建。Makefile文件也可以写为makefile， 或者用命令行参数指定为其他文件名。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make -f rules.txt</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ make --file=rules.txt</span><br></pre></td></tr></table></figure></blockquote><p>上面代码指定make命令依据rules.txt文件中的规则，进行构建。</p><p>总之，make只是一个根据指定的Shell命令进行构建的工具。它的规则很简单，你规定要构建哪个文件、它依赖哪些源文件，当那些文件有变动时，如何重新构建它。</p><h3 id="Makefile、-mk"><a href="#Makefile、-mk" class="headerlink" title="Makefile、.mk"></a>Makefile、.mk</h3><p>make命令执行时，需要一个makefile文件，以告诉make命令需要怎么样的去编译和链接程序。<strong>makefile说明make make解释makefile</strong>。</p><p>Makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。</p><p>不同产商的make各不相同，也有不同的语法，一般使用的是GNU的make。</p><p>在Makefile使用include关键字可以把别的Makefile包含进来，一般命名为xxx.mk，也可以其他命名。</p><h2 id="二、Makefile文件的格式"><a href="#二、Makefile文件的格式" class="headerlink" title="二、Makefile文件的格式"></a>二、Makefile文件的格式</h2><p>构建规则都写在Makefile文件里面，要学会如何make命令，就必须学会如何编写Makefile文件。</p><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>Makefile文件由一系列规则（rules）构成。每条规则的形式如下。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt; </span><br><span class="line">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure></blockquote><p>上面第一行冒号前面的部分，叫做”目标”（target），冒号后面的部分叫做”前置条件”（prerequisites）；第二行必须由一个tab键起首，后面跟着”命令”（commands）。</p><p>“目标”是必需的，不可省略；”前置条件”和”命令”都是可选的，但是两者之中必须至少存在一个。</p><p>每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。下面就详细讲解，每条规则的这三个组成部分。</p><h3 id="2-2-目标（target）"><a href="#2-2-目标（target）" class="headerlink" title="2.2 目标（target）"></a>2.2 目标（target）</h3><p>一个目标（target）就构成一条规则。目标通常是文件名，指明make命令所要构建的对象，比如上文的 a.txt 。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。</p><p>除了文件名，目标还可以是某个操作的名字，这称为”伪目标”（phony target）。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">   <span class="built_in">rm</span> *.o</span><br></pre></td></tr></table></figure></blockquote><p>上面代码的目标是clean，它不是文件名，而是一个操作的名字，属于”伪目标 “，作用是删除对象文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make  clean</span><br></pre></td></tr></table></figure></blockquote><p>但是，如果当前目录中，正好有一个文件叫做clean，那么这个命令不会执行。因为make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。</p><p>为了避免这种情况，可以明确声明clean是”伪目标”，写法如下。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">     <span class="built_in">rm</span> *.o temp</span><br></pre></td></tr></table></figure></blockquote><p>声明clean是”伪目标”之后，make就不会去检查是否存在一个叫做clean的文件，而是每次运行都执行对应的命令。像.PHONY这样的内置目标名还有不少，可以查看<a href="https://www.gnu.org/software/make/manual/html_node/Special-Targets.html#Special-Targets">手册</a>。</p><p>如果make命令运行时没有指定目标，默认会执行Makefile文件的<strong>第一个</strong>目标。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br></pre></td></tr></table></figure></blockquote><p>上面代码执行Makefile文件的第一个目标。</p><h3 id="2-3-前置条件（prerequisites）"><a href="#2-3-前置条件（prerequisites）" class="headerlink" title="2.3 前置条件（prerequisites）"></a>2.3 前置条件（prerequisites）</h3><p>前置条件通常是一组文件名，之间用空格分隔。它指定了”目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），”目标”就需要重新构建。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result.txt: source.txt</span><br><span class="line"><span class="built_in">cp</span> source.txt result.txt</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，构建 result.txt 的前置条件是 source.txt 。如果当前目录中，source.txt 已经存在，那么<code>make result.txt</code>可以正常运行，否则必须再写一条规则，来生成 source.txt 。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source.txt:</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;this is the source&quot;</span> &gt; source.txt</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，source.txt后面没有前置条件，就意味着它跟其他文件都无关，只要这个文件还不存在，每次调用<code>make source.txt</code>，它都会生成。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make result.txt</span><br><span class="line">$ make result.txt</span><br></pre></td></tr></table></figure></blockquote><p>上面命令连续执行两次<code>make result.txt</code>。第一次执行会先新建 source.txt，然后再新建 result.txt。第二次执行，make发现 source.txt 没有变动（时间戳晚于 result.txt），就不会执行任何操作，result.txt 也不会重新生成。</p><p>如果需要生成多个文件，往往采用下面的写法。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span>: file1 file2 file3</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，source 是一个伪目标，只有三个前置文件，没有任何对应的命令。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make <span class="built_in">source</span></span><br></pre></td></tr></table></figure></blockquote><p>执行<code>make source</code>命令后，就会一次性生成 file1，file2，file3 三个文件。这比下面的写法要方便很多。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make file1</span><br><span class="line">$ make file2</span><br><span class="line">$ make file3</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-4-命令（commands）"><a href="#2-4-命令（commands）" class="headerlink" title="2.4 命令（commands）"></a>2.4 命令（commands）</h3><p>命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建”目标”的具体指令，它的运行结果通常就是生成目标文件。</p><p>每行命令之前必须有一个tab键。如果想用其他键，可以用内置变量.RECIPEPREFIX声明。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.RECIPEPREFIX = &gt;</span><br><span class="line">all:</span><br><span class="line">&gt; <span class="built_in">echo</span> Hello, world</span><br></pre></td></tr></table></figure></blockquote><p>上面代码用.RECIPEPREFIX指定，大于号（&gt;）替代tab键。所以，每一行命令的起首变成了大于号，而不是tab键。</p><p>需要注意的是，<u>每行命令在一个单独的shell中执行</u>。这些Shell之间没有继承关系。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var-lost:</span><br><span class="line"><span class="built_in">export</span> foo=bar</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;foo=[$<span class="variable">$foo</span>]&quot;</span></span><br></pre></td></tr></table></figure></blockquote><p>上面代码执行后（<code>make var-lost</code>），取不到foo的值。因为两行命令在两个不同的进程执行。一个解决办法是将两行命令写在一行，中间用分号分隔。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var-kept:</span><br><span class="line"><span class="built_in">export</span> foo=bar; <span class="built_in">echo</span> <span class="string">&quot;foo=[$<span class="variable">$foo</span>]&quot;</span></span><br></pre></td></tr></table></figure></blockquote><p>另一个解决办法是在换行符前加反斜杠转义。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var-kept:</span><br><span class="line"><span class="built_in">export</span> foo=bar; \</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;foo=[$<span class="variable">$foo</span>]&quot;</span></span><br></pre></td></tr></table></figure></blockquote><p>最后一个方法是加上<code>.ONESHELL:</code>命令。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.ONESHELL:</span><br><span class="line">var-kept:</span><br><span class="line"><span class="built_in">export</span> foo=bar; </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;foo=[$<span class="variable">$foo</span>]&quot;</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="三、Makefile文件的语法"><a href="#三、Makefile文件的语法" class="headerlink" title="三、Makefile文件的语法"></a>三、Makefile文件的语法</h2><h3 id="3-1-注释"><a href="#3-1-注释" class="headerlink" title="3.1 注释"></a>3.1 注释</h3><p>井号（#）在Makefile中表示注释。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是注释</span></span><br><span class="line">result.txt: source.txt</span><br><span class="line"><span class="comment"># 这是注释</span></span><br><span class="line"><span class="built_in">cp</span> source.txt result.txt <span class="comment"># 这也是注释</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="3-2-回声（echoing）"><a href="#3-2-回声（echoing）" class="headerlink" title="3.2 回声（echoing）"></a>3.2 回声（echoing）</h3><p>正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>:</span><br><span class="line"><span class="comment"># 这是测试</span></span><br></pre></td></tr></table></figure></blockquote><p>执行上面的规则，会得到下面的结果。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 这是测试</span></span><br></pre></td></tr></table></figure></blockquote><p>在命令的前面加上@，就可以关闭回声。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>:</span><br><span class="line">@<span class="comment"># 这是测试</span></span><br></pre></td></tr></table></figure></blockquote><p>现在再执行<code>make test</code>，就不会有任何输出。</p><p>由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>:</span><br><span class="line">@<span class="comment"># 这是测试</span></span><br><span class="line">@<span class="built_in">echo</span> TODO</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-3-通配符"><a href="#3-3-通配符" class="headerlink" title="3.3 通配符"></a>3.3 通配符</h3><p>通配符（wildcard）用来指定一组符合条件的文件名。Makefile 的通配符与 Bash 一致，主要有星号（*）、问号（？）和 […] 。比如， *.o 表示所有后缀名为o的文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">     <span class="built_in">rm</span> -f *.o</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-4-模式匹配"><a href="#3-4-模式匹配" class="headerlink" title="3.4 模式匹配"></a>3.4 模式匹配</h3><p>make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%.o: %.c</span><br></pre></td></tr></table></figure></blockquote><p>等同于下面的写法。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1.o: f1.c</span><br><span class="line">f2.o: f2.c</span><br></pre></td></tr></table></figure></blockquote><p>使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。</p><h3 id="3-5-变量和赋值符"><a href="#3-5-变量和赋值符" class="headerlink" title="3.5 变量和赋值符"></a>3.5 变量和赋值符</h3><p>Makefile 允许使用等号自定义变量。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">txt = Hello World</span><br><span class="line"><span class="built_in">test</span>:</span><br><span class="line">@<span class="built_in">echo</span> $(txt)</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，变量 txt 等于 Hello World。调用时，变量需要放在 $( ) 之中。</p><p><u>调用Shell变量，需要在美元符号前，再加一个美元符号</u>，这是因为make命令会对美元符号转义。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>:</span><br><span class="line">@<span class="built_in">echo</span> $<span class="variable">$HOME</span></span><br></pre></td></tr></table></figure></blockquote><p>有时，变量的值可能指向另一个变量。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1 = $(v2)</span><br></pre></td></tr></table></figure></blockquote><p>上面代码中，变量 v1 的值是另一个变量 v2。这时会产生一个问题，v1 的值到底在定义时扩展（静态扩展），还是在运行时扩展（动态扩展）？如果 v2 的值是动态的，这两种扩展方式的结果可能会差异很大。</p><p>为了解决类似问题，Makefile一共提供了四个赋值运算符 （&#x3D;、:&#x3D;、？&#x3D;、+&#x3D;），它们的区别请看<a href="https://stackoverflow.com/questions/448910/makefile-variable-assignment">StackOverflow</a>。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">VARIABLE = value</span><br><span class="line"><span class="comment"># 在执行时扩展，允许递归扩展。</span></span><br><span class="line"></span><br><span class="line">VARIABLE := value</span><br><span class="line"><span class="comment"># 在定义时扩展。</span></span><br><span class="line"></span><br><span class="line">VARIABLE ?= value</span><br><span class="line"><span class="comment"># 只有在该变量为空时才设置值。</span></span><br><span class="line"></span><br><span class="line">VARIABLE += value</span><br><span class="line"><span class="comment"># 将值追加到变量的尾端。</span></span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">1、“=”</span><br><span class="line">“=”赋值：make会将整个makefile展开后，再决定变量的值。也就是说，变量的值将会是整个makefile中最后被指定的值。如例：</span><br><span class="line">x = foo</span><br><span class="line">y = $(x) bar</span><br><span class="line">x = ABC</span><br><span class="line">在上例中，y的值将会是 ABC bar ，而不是 foo bar 。</span><br><span class="line"></span><br><span class="line">2、“:=”</span><br><span class="line">“:=”赋值：“:”表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。</span><br><span class="line">x := foo</span><br><span class="line">y := $(x) bar</span><br><span class="line">x := abc</span><br><span class="line">在上例中，y的值将会是 foo bar ，而不是 abc bar 。</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-6-内置变量（Implicit-Variables）"><a href="#3-6-内置变量（Implicit-Variables）" class="headerlink" title="3.6 内置变量（Implicit Variables）"></a>3.6 内置变量（Implicit Variables）</h3><p>make命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(make) 指向当前使用的make工具。这主要是为了跨平台的兼容性，详细的内置变量清单见<a href="https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html">手册</a>。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">$(CC) -o output input.c</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-7-自动变量（Automatic-Variables）"><a href="#3-7-自动变量（Automatic-Variables）" class="headerlink" title="3.7 自动变量（Automatic Variables）"></a>3.7 自动变量（Automatic Variables）</h3><p>make命令还提供一些自动变量，它们的值与当前规则有关。主要有以下几个。</p><p><strong>（1）$@</strong></p><p>$@指代当前目标，就是Make命令当前构建的那个目标。比如，<code>make foo</code>的 ​$@ 就指代foo。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.txt b.txt: </span><br><span class="line"><span class="built_in">touch</span> <span class="variable">$@</span></span><br></pre></td></tr></table></figure></blockquote><p>等同于下面的写法。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.txt:</span><br><span class="line"><span class="built_in">touch</span> a.txt</span><br><span class="line">b.txt:</span><br><span class="line"><span class="built_in">touch</span> b.txt</span><br></pre></td></tr></table></figure></blockquote><p><strong>（2）$&lt;</strong></p><p>$&lt; 指代第一个前置条件。比如，规则为 t: p1 p2，那么​$&lt; 就指代p1。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.txt: b.txt c.txt</span><br><span class="line">    <span class="built_in">cp</span> $&lt; <span class="variable">$@</span> </span><br></pre></td></tr></table></figure></blockquote><p>等同于下面的写法。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.txt: b.txt c.txt</span><br><span class="line"><span class="built_in">cp</span> b.txt a.txt </span><br></pre></td></tr></table></figure></blockquote><p><strong>（3）$?</strong></p><p>$? 指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，$?就指代p2。</p><p><strong>（4）$^</strong></p><p>$^ 指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 ​$^ 就指代 p1 p2 。</p><p><strong>（5）$*</strong></p><p>$* 指代匹配符 % 匹配的部分， 比如% 匹配 f1.txt 中的f1 ，​$* 就表示 f1。</p><p><strong>（6）$(@D) 和 $(@F)</strong></p><p>$(@D) 和 $(@F) 分别指向 $@ 的目录名和文件名。比如，$@是 src&#x2F;input.c，那么$(@D) 的值为 src ，$(@F) 的值为 input.c。</p><p><strong>（7）$(&lt;D) 和 $(&lt;F)</strong></p><p>$(&lt;D) 和 $(&lt;F) 分别指向 $&lt; 的目录名和文件名。</p><p>所有的自动变量清单，请看<a href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html">手册</a>。下面是自动变量的一个例子。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dest/%.txt: src/%.txt</span><br><span class="line">@[ -d dest ] || <span class="built_in">mkdir</span> dest</span><br><span class="line"><span class="built_in">cp</span> $&lt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure></blockquote><p>上面代码将 src 目录下的 txt 文件，拷贝到 dest 目录下。首先判断 dest 目录是否存在，如果不存在就新建，然后，$&lt; 指代前置文件（src&#x2F;%.txt）， ​$@ 指代目标文件（dest&#x2F;%.txt）。</p><h3 id="3-8-判断和循环"><a href="#3-8-判断和循环" class="headerlink" title="3.8 判断和循环"></a>3.8 判断和循环</h3><p>Makefile使用 Bash 语法，完成判断和循环。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ifeq ($(CC),gcc)</span><br><span class="line">libs=$(libs_for_gcc)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">libs=$(normal_libs)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure></blockquote><p>上面代码判断当前编译器是否 gcc ，然后指定不同的库文件。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LIST = one two three</span><br><span class="line">all:</span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> $(LIST); <span class="keyword">do</span> \</span><br><span class="line">     <span class="built_in">echo</span> $<span class="variable">$i</span>; \</span><br><span class="line"> <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> one two three; <span class="keyword">do</span> \</span><br><span class="line">     <span class="built_in">echo</span> <span class="variable">$i</span>; \</span><br><span class="line"> <span class="keyword">done</span></span><br></pre></td></tr></table></figure></blockquote><p>上面代码的运行结果。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-9-函数"><a href="#3-9-函数" class="headerlink" title="3.9 函数"></a>3.9 函数</h3><p>Makefile 还可以使用函数，格式如下。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="keyword">function</span> arguments)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="variable">$&#123;function arguments&#125;</span></span><br></pre></td></tr></table></figure></blockquote><p>Makefile提供了许多<a href="https://www.gnu.org/software/make/manual/html_node/Functions.html">内置函数</a>，可供调用。下面是几个常用的内置函数。</p><p><strong>（1）shell 函数</strong></p><p>shell 函数用来执行 shell 命令</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srcfiles := $(shell <span class="built_in">echo</span> src/&#123;00..99&#125;.txt)</span><br></pre></td></tr></table></figure></blockquote><p><strong>（2）wildcard 函数</strong></p><p>wildcard 函数用来在 Makefile 中，替换 Bash 的通配符。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srcfiles := $(wildcard src/*.txt)</span><br></pre></td></tr></table></figure></blockquote><p><strong>（3）subst 函数</strong></p><p>subst 函数用来文本替换，格式如下。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(subst from,to,text)</span><br></pre></td></tr></table></figure></blockquote><p>下面的例子将字符串”feet on the street”替换成”fEEt on the strEEt”。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(subst ee,EE,feet on the street)</span><br></pre></td></tr></table></figure></blockquote><p>下面是一个稍微复杂的例子。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">comma:= ,</span><br><span class="line">empty:=</span><br><span class="line"><span class="comment"># space变量用两个空变量作为标识符，当中是一个空格</span></span><br><span class="line">space:= $(empty) $(empty)</span><br><span class="line">foo:= a b c</span><br><span class="line">bar:= $(subst $(space),$(comma),$(foo))</span><br><span class="line"><span class="comment"># bar is now `a,b,c&#x27;.</span></span><br></pre></td></tr></table></figure></blockquote><p><strong>（4）patsubst函数</strong></p><p>patsubst 函数用于模式匹配的替换，格式如下。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(patsubst pattern,replacement,text)</span><br></pre></td></tr></table></figure></blockquote><p>下面的例子将文件名”x.c.c bar.c”，替换成”x.c.o bar.o”。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(patsubst %.c,%.o,x.c.c bar.c)</span><br></pre></td></tr></table></figure></blockquote><p><strong>（5）替换后缀名</strong></p><p>替换后缀名函数的写法是：变量名 + 冒号 + 后缀名替换规则。它实际上patsubst函数的一种简写形式。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min: $(OUTPUT:.js=.min.js)</span><br></pre></td></tr></table></figure></blockquote><p>上面代码的意思是，将变量OUTPUT中的后缀名 .js 全部替换成 .min.js 。</p><h2 id="四、Makefile-的实例"><a href="#四、Makefile-的实例" class="headerlink" title="四、Makefile 的实例"></a>四、Makefile 的实例</h2><p><strong>（1）执行多个目标</strong></p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: cleanall cleanobj cleandiff</span><br><span class="line"></span><br><span class="line">cleanall : cleanobj cleandiff</span><br><span class="line">     <span class="built_in">rm</span> program</span><br><span class="line"></span><br><span class="line">cleanobj :</span><br><span class="line">     <span class="built_in">rm</span> *.o</span><br><span class="line"></span><br><span class="line">cleandiff :</span><br><span class="line">     <span class="built_in">rm</span> *.diff</span><br></pre></td></tr></table></figure></blockquote><p>上面代码可以调用不同目标，删除不同后缀名的文件，也可以调用一个目标（cleanall），删除所有指定类型的文件。</p><p><strong>（2）编译C语言项目</strong></p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o </span><br><span class="line"> cc -o edit main.o kbd.o command.o display.o</span><br><span class="line"></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line"> cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line"> cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line"> cc -c command.c</span><br><span class="line">display.o : display.c defs.h</span><br><span class="line"> cc -c display.c</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">  <span class="built_in">rm</span> edit main.o kbd.o command.o display.o</span><br><span class="line"></span><br><span class="line">.PHONY: edit clean</span><br></pre></td></tr></table></figure></blockquote><h2 id="五、其他知识（重要）"><a href="#五、其他知识（重要）" class="headerlink" title="五、其他知识（重要）"></a>五、其他知识（重要）</h2><h3 id="默认执行"><a href="#默认执行" class="headerlink" title="默认执行"></a>默认执行</h3><p>在默认的方式下，也就是只输入make命令，会依次进行：</p><ol><li>make会在当前目录下找名字叫“Makefile”或“makefile”的文件；</li><li>如果找到，它会找文件中的第一个目标文件（target）；</li><li>先判断（target）所依赖的文件是否存在，make会在当前文件中找到该依赖文件的依赖性，按照其依赖逐次生成相应的文件（即递归）；</li><li>若（target）所依赖的文件的修改时间要比（target）这个文件新，或者（target）不存在，那么就会执行后面所定义的命令来生成这个文件；</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错。而对于所定义的命令的错误，或是编译不成功，make根本不理。</span><br><span class="line">make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么make不工作。</span><br></pre></td></tr></table></figure><h3 id="自动推导"><a href="#自动推导" class="headerlink" title="自动推导"></a>自动推导</h3><p>GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。</p><p>  make只要看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。</p><p>比如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">main.o : main.c defs.h</span><br><span class="line">cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">cc -c utils.c</span><br></pre></td></tr></table></figure><p>可以简写为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main.o : defs.h</span><br><span class="line">kbd.o : defs.h command.h</span><br><span class="line">command.o : defs.h command.h</span><br><span class="line">display.o : defs.h buffer.h</span><br><span class="line">insert.o : defs.h buffer.h</span><br><span class="line">search.o : defs.h buffer.h</span><br><span class="line">files.o : defs.h buffer.h command.h</span><br><span class="line">utils.o : defs.h</span><br></pre></td></tr></table></figure><p>也可以简写成这种风格，不过文件的依赖关系不是特别清晰：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span> : defs.h</span><br><span class="line">kbd.o command.o files.o : command.h</span><br><span class="line">display.o insert.o search.o files.o : buffer.h</span><br></pre></td></tr></table></figure><h3 id="引用其它的Makefile（-mk）"><a href="#引用其它的Makefile（-mk）" class="headerlink" title="引用其它的Makefile（.mk）"></a>引用其它的Makefile（.mk）</h3><p><strong>在include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和可以用一个或多个空格隔开。</strong></p><p>例如，有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和f.mk，那么，下面的语句：</p>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> foo.make *.mk <span class="variable">$(bar)</span></span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> foo.make a.mk b.mk c.mk e.mk f.mk</span><br></pre></td></tr></table></figure><p>make命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在<u>当前的位置</u>。如果文件都没有指定绝对路径或是相对路径的话，make会在<strong>当前目录</strong>下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.如果make执行时，有“-I”或“--include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。</span><br><span class="line"></span><br><span class="line">2.如果目录/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。</span><br></pre></td></tr></table></figure><p>如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误；</p><p>它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。</p><p>如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-include</span>&lt;filename&gt;</span><br></pre></td></tr></table></figure><h3 id="隐含规则使用的变量"><a href="#隐含规则使用的变量" class="headerlink" title="隐含规则使用的变量"></a>隐含规则使用的变量</h3><p>隐含规则中使用的变量分成两种：一种是命令相关的，如“CC”；一种是参数<br>相的关，如“CFLAGS”。</p><p><strong>1、关于命令的变量。</strong></p><ul><li>CC<br>  C语言编译程序。默认命令是“cc”。</li><li>AS<br>  汇编语言编译程序。默认命令是“as”</li><li>CXX<br>  C++语言编译程序。默认命令是“g++”。</li><li>CPP<br>  C程序的预处理器（输出是标准输出设备）。默认命令是“$(CC) –E”。</li></ul><p><strong>2、关于命令参数的变量</strong></p><p>下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。</p><ul><li>CFLAGS<br>  C语言编译器参数。</li><li>LDFLAGS<br>  链接器参数。（如：“ld”）</li><li>ASFLAGS<br>  汇编语言编译器参数。（当明显地调用“.s”或“.S”文件时）。</li><li>CXXFLAGS<br>  C++语言编译器参数。</li><li>CPPFLAGS<br>  C预处理器参数。（ C 和 Fortran 编译器也会用到）。</li></ul><h3 id="定义模式规则"><a href="#定义模式规则" class="headerlink" title="定义模式规则"></a>定义模式规则</h3><p>可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有”%”字符。”%”的意思是表示一个或多个任意字符。在依赖目标中同样可以使用”%”，只是依赖目标中的”%”的取值，取决于其目标。</p><p>有一点需要注意的是，”%”的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入Makefile时，而模式规则中的”%”则发生在运行时。</p><p>模式规则中，至少在规则的目标定义中要包含”%”，否则，就是一般的规则。目标中的”%”定义表示对文件名的匹配，”%”表示长度任意的非空字符串。例如：”%.c”表示以”.c”结尾的文件名（文件名的长度至少为3），而”s.%.c”则表示以”s.”开头，”.c”结尾的文件名（文件名的长度至少为 5）。</p><p>下面这个例子表示了,把所有的[.c]文件都编译成[.o]文件。其中，”$@”表示所有的目标的挨个值，”$&lt;”表示了所有依赖目标的挨个值，这些奇怪的变量叫”自动化变量”</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%.o : %.c</span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>自动化变量加上”D”或是”F”的含义，例如：</p><ul><li>$(@D)<br>  表示”$@”的目录部分（不以斜杠作为结尾），如果”​$@”值是”dir&#x2F;foo.o”，那么”$(@D)”就是”dir”，而如果”$@”中没有包含斜杠的话，其值就是”.”（当前目录）。</li><li>$(@F)<br>  表示”$@”的文件部分，如果”$@”值是”dir&#x2F;foo.o”，那么”$(@F)”就是”foo.o”，”​$(@F)”相当于函数”​$(notdir $@)”。</li></ul><p>其他的同理。</p><h2 id="实战分析【重要！】"><a href="#实战分析【重要！】" class="headerlink" title="实战分析【重要！】"></a>实战分析【重要！】</h2><p>来源：<a href="https://www.cnblogs.com/jzcn/p/17012331.html">https://www.cnblogs.com/jzcn/p/17012331.html</a></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Makefile</span></span><br><span class="line"><span class="comment"># 编译的.o文件和.c文件在同一路径下</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">$(info &quot;start...&quot;)</span></span><br><span class="line"><span class="comment"># 可执行文件名</span></span><br><span class="line">PROJECT_NAME = app</span><br><span class="line"> </span><br><span class="line"><span class="comment">##################################### 项目路径 #####################################</span></span><br><span class="line">PROJECT_PATH ?= $&#123;shell pwd&#125;</span><br><span class="line">OBJ_DIR := <span class="variable">$(PROJECT_PATH)</span>/build</span><br><span class="line"> </span><br><span class="line"><span class="comment">##################################### 设置编译器，默认使用GCC #####################################</span></span><br><span class="line">CC ?= gcc</span><br><span class="line"> </span><br><span class="line"><span class="comment">##################################### 所需头文件的路径 #####################################</span></span><br><span class="line">CFLAGS += -I<span class="variable">$(PROJECT_PATH)</span>/lib/inc</span><br><span class="line"> </span><br><span class="line"><span class="comment">##################################### 编译和链接参数 #####################################</span></span><br><span class="line">CFLAGS ?= -O3 -g0 -Wall -Wshadow -Wundef -Wmissing-prototypes</span><br><span class="line">LDFLAGS ?= -lm</span><br><span class="line"> </span><br><span class="line"><span class="comment">##################################### 收集需要编译的源文件 #####################################</span></span><br><span class="line">CSRCS += <span class="variable">$(PROJECT_PATH)</span>/application/main.c</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(PROJECT_PATH)</span>/lib/lib.mk</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">##################################### 将文件名替换为.o文件 #####################################</span></span><br><span class="line">CXX_OBJCTS = <span class="variable">$(<span class="built_in">patsubst</span>  %.c, <span class="variable">$(OBJ_DIR)</span>/%.o, $(<span class="built_in">notdir</span> <span class="variable">$(CSRCS)</span>)</span>)</span><br><span class="line">SOURSE_DIR = <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$(CSRCS)</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">vpath</span> %.c <span class="variable">$(SOURSE_DIR)</span></span><br><span class="line"> </span><br><span class="line"><span class="variable">$(OBJ_DIR)</span>/%.o: %.c</span><br><span class="line">@<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment">#@echo &quot;CC $&lt;&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="section">all: <span class="variable">$(CXX_OBJCTS)</span></span></span><br><span class="line">@<span class="variable">$(CC)</span> -o <span class="variable">$(PROJECT_NAME)</span>  <span class="variable">$(CXX_OBJCTS)</span> <span class="variable">$(LDFLAGS)</span></span><br><span class="line"> </span><br><span class="line"><span class="section">clean: </span></span><br><span class="line">@rm -f <span class="variable">$(PROJECT_NAME)</span> <span class="variable">$(CXX_OBJCTS)</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><ol><li><p>查找所有.c文件</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式一</span></span><br><span class="line">CSRCS += $(PROJECT_PATH)/application/main.c</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式二</span></span><br><span class="line">CXX_SOURCES = $(foreach dir,$(CSRCS), $(wildcard $(dir)/*.c))</span><br></pre></td></tr></table></figure><p> <strong>注意：</strong>方式一是直接将所有的 .c 文件追加到 CSRCS 变量中，方式二是将搜索路径下的所有 .c 文件，并追加到 CSRCS 变量中。</p></li><li><p>将所有的 .c 文件换成 .o 文件</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式一</span></span><br><span class="line">COBJS = $(CSRCS:.c=.o)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式二</span></span><br><span class="line">COBJS= $(patsubst  %.c, %.o, $(CSRCS))</span><br></pre></td></tr></table></figure><p> <strong>注意：</strong>方式一和方式二原理都是一样的，其目的是将所有的 .c 文件换成 .o 文件而已</p></li><li><p>生成 .o 文件</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">/%</span><span class="language-bash">.o: %.c</span></span><br><span class="line"><span class="meta prompt_">@$</span><span class="language-bash">(CC) $(CFLAGS) -c $&lt; -o <span class="variable">$@</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">@<span class="built_in">echo</span> <span class="string">&quot;CC $&lt;&quot;</span></span></span><br></pre></td></tr></table></figure><p> <strong>注意：</strong>第2点只是将 .c 文件 换成了 .o 文件名，得到的只是文件名称而已，这里才是根据相应的目标生成 .o 文件</p></li><li><p>链接成可执行文件<br> 将所有的 .o 文件链接成可执行文件</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">@$</span><span class="language-bash">(CC) -o $(PROJECT_NAME)  $(CXX_OBJCTS) $(LDFLAGS)</span></span><br></pre></td></tr></table></figure></li><li><p>清理所有的 .o 文件</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@rm -f $(PROJECT_NAME) $(CXX_OBJCTS)</span><br></pre></td></tr></table></figure></li></ol><p><strong>注意：</strong>以上就是 make 的编译流程，但是编译生成的 .o 文件和.c 文件是在同一目录下的，不满足我们的需求，接着网下看</p><ol><li><p>将所有的 .o 文件放到指定目录下</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CXX_OBJCTS = $(patsubst  %.c, $(OBJ_DIR)/%.o, $(notdir $(CSRCS)))</span><br></pre></td></tr></table></figure><p> <strong>注意：</strong> notdir $(CSRCS) 函数是去掉文件路径，只保留文件名，如此便可以在替换后缀的时候，在文件前面加上指定路径</p></li><li><p>完成指定路径下的所有 .o 文件的目标</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">(OBJ_DIR)/%.o: %.c</span></span><br><span class="line"><span class="meta prompt_">@$</span><span class="language-bash">(CC) $(CFLAGS) -c $&lt; -o <span class="variable">$@</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">@<span class="built_in">echo</span> <span class="string">&quot;CC $&lt;&quot;</span></span></span><br></pre></td></tr></table></figure><p> <strong>注意：</strong>这里的作用在源文件中查找能制作目标的文件，因为这里的目标和源文件不在同一目录下，所以需要完成第8点的操作</p></li><li><p>vpath 和 VPATH<br> 这里我也不是很理解，在自动目标中需要将源文件路径加入 vpath 或 VPATH 中，如下所示：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式一</span></span><br><span class="line">VPATH += :$(SRC_DIR)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式二</span></span><br><span class="line">SOURSE_DIR = $(dir $(CSRCS))</span><br><span class="line">vpath %.c $(SOURSE_DIR)</span><br></pre></td></tr></table></figure><p> <strong>注意：</strong>函数 dir 的作用是提取所有文件的路径</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 嵌入式工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式工具-gcc</title>
      <link href="/2024/03/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B7%A5%E5%85%B7-gcc/"/>
      <url>/2024/03/27/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B7%A5%E5%85%B7-gcc/</url>
      
        <content type="html"><![CDATA[<h2 id="gcc使用"><a href="#gcc使用" class="headerlink" title="gcc使用"></a>gcc使用</h2><p>参考：<a href="https://www.cnblogs.com/testlife007/p/6555404.html">https://www.cnblogs.com/testlife007/p/6555404.html</a></p><h3 id="gcc基本用法"><a href="#gcc基本用法" class="headerlink" title="gcc基本用法"></a>gcc基本用法</h3><p>使用gcc编译器时，必须给出一系列必要的调用参数和文件名称。<strong>不同参数的先后顺序对执行结果没有影响，只有在使用同类参数时的先后顺序才需要考虑</strong>。如果使用了多个 -L 的参数来定义库目录，gcc会根据多个 -L 参数的先后顺序来执行相应的库目录。</p><p>很多gcc参数都由多个字母组成，所以gcc参数不支持单字母的组合，Linux中常被叫短参数（short options），如 -dr 与 -d -r 的含义不一样。gcc编译器的调用参数大约有100多个，其中多数参数我们可能根本就用不到，这里只介绍其中最基本、最常用的参数。</p><p><strong>gcc最基本的用法是</strong>：gcc [options] [filenames]，options最常用的有以下参数：</p><ul><li><p><strong>-c</strong>  </p><p>  <strong>只编译，不链接成为可执行文件</strong>。编译器只是由输入的 .c 等源代码文件<strong>生成 .o 为后缀的目标文件</strong>，通常用于编译不包含主程序的子程序文件。</p></li><li><p><strong>-o output_filename</strong>  </p><p>  确定<strong>输出文件的名称</strong>为output_filename。同时这个名称不能和源文件同名。如果不给出这个选项，gcc就给出默认的可执行文件 a.out 。</p></li><li><p><strong>-g</strong></p><p>  <strong>产生符号调试</strong>工具（GNU的 gdb）所必要的符号信息。想要对源代码进行调试，就必须加入这个选项。</p></li><li><p><strong>-O</strong></p><p>  对程序进行<strong>优化编译、链接</strong>。采用这个选项，整个源代码会在编译、链接过程中进行优化处理，这样产生的可执行文件的执行效率可以提高，但是编译、链接的速度就相应地要慢一些，而且对执行文件的调试会产生一定的影响，造成一些执行效果与对应源文件代码不一致等一些令人“困惑”的情况。因此，<strong>一般在编译输出软件发行版时使用此选项</strong>。</p></li><li><p><strong>-O2</strong></p><p>  比 -O 更好的优化编译、链接。当然整个编译链接过程会更慢。</p></li><li><p><strong>-Idirname</strong></p><p>  将 dirname 所指出的目录加入到程序<strong>头文件目录列表</strong>中，是在预编译过程中使用的参数。</p><p>  C程序中的头文件包含两种情况：<br>  #include &lt;stdio.h&gt;<br>  #include “stdio.h”<br>  其中，使用尖括号（&lt;&gt;），预处理程序 cpp 在系统默认包含文件目录（如&#x2F;usr&#x2F;include）中搜索相应的文件；使用双引号，预处理程序 cpp 首先在当前目录中搜寻头文件，如果没有找到，就到指定的 dirname 目录中去寻找。<br>  在程序设计中，<strong>如果需要的这种包含文件分别分布在不同的目录中，就需要逐个使用 -I 选项给出搜索路径</strong>。</p></li><li><p><strong>-Ldirname</strong><br>  将dirname所指出的目录加入到<strong>程序函数库文件的目录列表</strong>中，是在链接过程中使用的参数。在默认状态下，链接程序 ld 在系统默认路径中（如 &#x2F;usr&#x2F;lib）寻找所需要的库文件。这个选项告诉链接程序，首先到 -L 指定的目录中去寻找，然后到系统默认路径中寻找；如果函数库存放在多个目录下，就需要依次使用这个选项，给出相应的存放目录。</p></li><li><p><strong>-lname</strong><br>  <strong>链接时装载名为 libname.a 的函数库</strong>。该函数库位于系统默认的目录或者由 -L 选项确定的目录下。例如，-lm 表示链接名为 libm.a 的数学函数库。</p></li></ul><p>编译过程的分步执行：为了更好地理解gcc的工作过程，我们可以让在gcc工作的<strong>4个阶段</strong>中的任何一个阶段中停止下来。相关的参数有：</p><ul><li><strong>-E</strong><br>  预编译后停下来，生成后缀为 <strong>.i 的预编译文件</strong>。</li><li><strong>-c</strong><br>  编译后停下来，生成后缀为 <strong>.o 的目标文件</strong>。</li><li><strong>-S</strong><br>  汇编后停下来，生成后缀为 <strong>.s 的汇编源文件</strong>。</li></ul><p>说明：</p><p>在编译一个包含许多源文件的工程时，若只用一条gcc命令来完成编译是非常浪费时间的。假如项目中有100个源文件需要编译，并且每个源文件中都包含一万行代码，如果像上面那样仅用一条gcc命令来完成编译工作，那么gcc需要将每个源文件都重新编译一遍，然后再全部链接起来。很显然，这样浪费的时间相当多，尤其是当用户只是修改了其中某个文件的时候，完全没有必要将每个文件都重新编译一遍，因为很多已经生成的目标文件是不会发生改变的。要解决这个问题，需要借助像<strong>make</strong>这样的工具。</p><h3 id="警告提示功能选项"><a href="#警告提示功能选项" class="headerlink" title="警告提示功能选项"></a>警告提示功能选项</h3><p>gcc包含完整的出错检查和警告提示功能，它们可以帮助Linux程序员写出更加专业的代码。</p><p><strong>(1) -pedantic 选项</strong></p><p>当gcc在编译不符合ANSI&#x2F;ISO C 语言标准的源代码时，将产生相应的警告信息。</p><p> <strong>(2) -Wall 选项</strong></p><p>除了 -pedantic 之外，gcc 还有一些其他编译选项，也能够产生有用的警告信息。这些选项大多以 -W 开头。其中最有价值的当数 -Wall 了，使用它能够使 gcc 产生尽可能多的警告信息。</p><p><strong>(3) -Werror 选项</strong></p><p>在处理警告方面，另一个常用的编译选项是 -Werror。<strong>它要求 gcc 将所有的警告当成错误进行处理，这在使用自动编译工具（如 Make 等）时非常有用</strong>。如果编译时带上 -Werror 选项，那么 gcc 会在所有产生警告的地方停止编译，迫使程序员对自己的代码进行修改。只有当相应的警告信息消除时，才可能将编译过程继续朝前推进。</p><p><strong>(4) -Wcast-align 选项</strong></p><p>当源程序中地址不需要对齐的指针指向一个地址需要对齐的变量地址时，则产生一个警告。例如，char * 指向一个 int * 地址，而通常在机器中 int 变量类型是需要地址能被2或4整除的对齐地址。</p><p><strong>(5) 其他常用选项</strong></p><ul><li>-v  ： 输出 gcc 工作的详细过程</li><li>–target-help：显示目前所用的gcc支持CPU类型</li><li>-Q：显示编译过程的统计数据和每一个函数名</li></ul><h3 id="库操作选项"><a href="#库操作选项" class="headerlink" title="库操作选项"></a>库操作选项</h3><p>在<a href="http://lib.csdn.net/base/linux">Linux</a>下开发软件时，完全不使用第三方函数库的情况是比较少见的，通常来讲都需要借助一个或多个函数库的支持才能够完成相应的功能。</p><p>从程序员的角度看，函数库实际上就是一些头文件（.h）和库文件（.so 或 .a）的集合。虽然Linux下的大多数函数都默认将头文件放到 &#x2F;usr&#x2F;include&#x2F; 目录下，而库文件则放到 &#x2F;usr&#x2F;lib&#x2F; 目录下，但并不是所有的情况都是这样。正因如此，gcc 在编译时必须有自己的办法来查找所需要的头文件和库文件。常用的方法有：</p><p><strong>(1) -I</strong> </p><p>可以向 gcc 的头文件搜索路径中添加新的目录。</p><p><strong>(2) -L</strong> </p><p>如果使用了不在标准位置的库文件，那么可以通过 -L 选项向 gcc 的库文件搜索路径中添加新的目录。</p><p><strong>(3) -l</strong> </p><p>Linux下的库文件在命名时有一个约定，就是应该以 lib 这3个字母开头，由于所有的库文件都遵循了同样的规范，因此在用 -l 选项指定链接的库文件名时可以省去 lib 这3个字母。例如，gcc 在对 -lfoo 进行处理时，会自动去链接名为 libfoo.so 的文件。</p><p><strong>(4) -static</strong></p><p>Linux下的库文件分为两大类，分别是：动态链接库（通常以 .so 结尾）和静态链接库（通常以 .a 结尾）。</p><p>两者的差别仅在程序执行时所需的代码是在运行时动态加载的，还是在编译时静态加载的。默认情况下，gcc 在链接时优先使用动态链接库，只有当动态链接库不存在时才考虑使用静态链接库。如果需要的话，可以在编译时加上 -static 选项，强制使用静态链接库。</p><p><strong>(5) -shared</strong></p><p>生成一个共享的目标文件，它能够与其他的目标一起链接生成一个可执行的文件。</p><h3 id="调试选项"><a href="#调试选项" class="headerlink" title="调试选项"></a>调试选项</h3><p>对于Linux程序员来讲，<strong>gdb（GNU Debugger）</strong>通过与 gcc 的配合使用，为基于Linux的软件开发提供了一个完善的调试环境。常用的有：</p><p><strong>(1) -g 和 -ggdb</strong></p><p>默认情况下，gcc 在编译时不会将调试符号插入到生成的二进制代码中，因为这样会增加可执行文件的大小。如果需要在编译时生成调试符号信息，可以使用 gcc 的 -g 或 -ggdb 选项。</p><p>gcc 在产生调试符号时，同样采用了分级的思路，开发人员可以通过在 -g 选项后附加数字1、2、3指定在代码中加入调试信息的多少。默认的级别是2（-g2），此时产生的调试信息包括：扩展的符号表、行号、局部或外部变量信息。级别3（-g3）包含级别2中的所有调试信息以及源代码中定义的宏。级别1（-g1）不包含局部变量和与行号有关的调试信息，因此只能够用于回溯跟踪和堆栈转储。</p><p>回溯追踪：指的是监视程序在运行过程中函数调用历史。</p><p>堆栈转储：则是一种以原始的十六进制格式保存程序执行环境的方法。</p><p>注意：使用任何一个调试选项都会使最终生成的二进制文件的大小急剧增加，同时增加程序在执行时的开销，因此，调试选项通常仅在软件的开发和调试阶段使用。</p><p><strong>(2) -p 和 -pg</strong></p><p>会将剖析（Profiling）信息加入到最终生成的二进制代码中。剖析信息对于找出程序的性能瓶颈很有帮助，是协助Linux程序员开发出高性能程序的有力工具。</p><p><strong>(3) -save-temps</strong></p><p>保存编译过程中生成的一些列中间文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gcc test.c -o <span class="built_in">test</span> -save-temps</span></span><br></pre></td></tr></table></figure><p><strong>除了生成执行文件test之外，还保存了test.i 和 test.s 中间文件，供用户查询调试。</strong></p><h3 id="交叉编译选项"><a href="#交叉编译选项" class="headerlink" title="交叉编译选项"></a>交叉编译选项</h3><p>通常情况下使用 gcc 编译的目标代码都与使用的机器是一致的，但 gcc 也支持交叉编译的功能，<strong>能够编译其他不同CPU的目标代码</strong>。<br>使用 gcc 开发嵌入式系统，我们几乎都是以通用的PC机（X86）平台来做宿主机，通过 gcc 的交叉编译功能对其他嵌入式CPU的开发任务。</p><p>（具体的选项设置，此处省略）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 嵌入式工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发板服务器-个人博客网站</title>
      <link href="/2024/03/27/%E5%BC%80%E5%8F%91%E6%9D%BF%E6%9C%8D%E5%8A%A1%E5%99%A8-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"/>
      <url>/2024/03/27/%E5%BC%80%E5%8F%91%E6%9D%BF%E6%9C%8D%E5%8A%A1%E5%99%A8-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LVGL学习记录</title>
      <link href="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><h2 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h2><p>github项目：<a href="https://github.com/lvgl/lv_port_linux_frame_buffer">https://github.com/lvgl/lv_port_linux_frame_buffer</a></p><p>下载源码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/lvgl/lv_port_linux_frame_buffer.git</span><br><span class="line"><span class="built_in">cd</span> lv_port_linux_frame_buffer/</span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><p>编译项目：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改源码目录下的Makefile，将“CC ?= gcc”改成：</span>  </span><br><span class="line">CC := arm-linux-gnueabihf-gcc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>编译完，会生成一个demo二进制示例文件，拷到开发板直接运行即可。</p><h2 id="中文显示"><a href="#中文显示" class="headerlink" title="中文显示"></a>中文显示</h2><p>下载ttf或otf格式字库，这里使用win10下的”windows&#x2F;fonts”目录中的simhei.ttf字体：</p><style>.kzkfrfyijkjc{zoom:67%;}</style><p>复制到其他地方，打开网站： <a href="https://lvgl.io/tools/fontconverter">https://lvgl.io/tools/fontconverter</a></p><style>.odijretpcrkf{zoom:50%;}</style><p>选项说明：</p><ul><li>Name：字库名称lv_font_stliti_24</li><li>Size：字符大小24</li><li>Bpp：每个像素的比特（位），位数越大效果越好，字库尺寸越大。</li><li>Font compression：启用字体压缩（减小大小，但导致渲染速度变慢）</li><li>Horizontal subpixel rendering：水平子像素渲染（可能会提高字体质量，但会导致更大的字体库）</li><li>Try to use glyph color info from font to create grayscale icons：尝试使用字体中的字形颜色信息创建灰度图标。由于灰色色调是通过透明度模拟的，所以仅在对比度背景上效果会很好。</li><li>Range：选择字符范围，我们只选择了ASCII码表。可以选择多个范围，用空格分隔。<ul><li>基本汉字：0x4E00-0x9FA5</li><li>数字、拉丁字母、标点符号：0x20-0x7E</li></ul></li><li>Symbols：如果在Range中选择全字库范围将得到一个很大的字库，占用很多空间。在项目中我们只用到少量中文，将这些中文写在Symbols中，这样生成的字库很小。</li></ul><p>设置后，点击“Convert”下载”simhei30.c”字体，将其导入工程项目中。</p><p>Makefile设置：</p><style>.gplwltniffky{zoom:67%;}</style><p>main.c中设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明字体</span></span><br><span class="line">LV_FONT_DECLARE(simhei30);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置字体格式</span></span><br><span class="line">lv_obj_set_style_text_font(label_weather, &amp;simhei30, LV_STATE_DEFAULT);</span><br></pre></td></tr></table></figure><h1 id="移植到Linux环境"><a href="#移植到Linux环境" class="headerlink" title="移植到Linux环境"></a>移植到Linux环境</h1><p>主要参考<a href="https://blog.csdn.net/weixin_44550536/article/details/131714105%E3%80%82">https://blog.csdn.net/weixin_44550536/article/details/131714105。</a></p><p>其他参考 <a href="https://www.cnblogs.com/jzcn/p/17011647.html%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BA%8C%E3%80%82">https://www.cnblogs.com/jzcn/p/17011647.html的方式二。</a></p><h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>git拉取指定分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/lvgl/lvgl.git -b release/v8.3</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/lvgl/lv_drivers.git -b release/v8.3</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/lvgl/lv_port_linux_frame_buffer.git</span><br></pre></td></tr></table></figure><p>无法git拉取，则手动下载指定版本的zip包。</p><p><a href="https://github.com/lvgl/lvgl/tree/release/v8.3">https://github.com/lvgl/lvgl/tree/release/v8.3</a></p><p><a href="https://github.com/lvgl/lv_drivers/tree/release/v8.3">https://github.com/lvgl/lv_drivers/tree/release/v8.3</a></p><p><a href="https://github.com/lvgl/lv_port_linux_frame_buffer">https://github.com/lvgl/lv_port_linux_frame_buffer</a></p><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><ol><li>创建 lvgl_demo 文件夹；</li><li>将 lvgl、lv_drivers 复制到 lvgl_demo 中；</li><li>将 lv_port_linux_frame_buffer 仓库中的 main.c 文件和 makefile 文件复制到 lvgl_demo 中；</li><li>将 lvgl 中的 lv_conf_template.h 文件复制到 lvgl_demo 中并且改名为 lv_conf.h；</li><li>将 lv_drivers 中的 lv_drv_conf_template.h 文件复制到 lvgl_demo 中并且改名为 lv_drv_conf.h；</li><li>创建好的工程目录如图所示：</li></ol><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240326221443410.png" class="" title="image-20240326221443410"><h2 id="文件修改"><a href="#文件修改" class="headerlink" title="文件修改"></a>文件修改</h2><h3 id="修改-lv-conf-h"><a href="#修改-lv-conf-h" class="headerlink" title="修改 lv_conf.h"></a>修改 lv_conf.h</h3><p>使能：</p><style>.bifvmwkjmiwx{zoom: 67%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327091743990.png" class="bifvmwkjmiwx" alt="image-20240327091743990"><p>根据实际情况适当扩大内存：</p><style>.rumleurjejtb{zoom:67%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327091845504.png" class="rumleurjejtb" alt="image-20240327091845504"><p>可以修改刷新频率，默认为 30ms：</p><style>.ykdnxqordktg{zoom:67%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327091929865.png" class="ykdnxqordktg" alt="image-20240327091929865"><p>配置 Tick：</p><style>.fxvtqkrxeovw{zoom:67%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327092120873.png" class="fxvtqkrxeovw" alt="image-20240327092120873"><p>使能 widgets demo：</p><style>.tlcdsisdwixm{zoom:67%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327092217648.png" class="tlcdsisdwixm" alt="image-20240327092217648"><h3 id="修改-lv-drv-conf-h"><a href="#修改-lv-drv-conf-h" class="headerlink" title="修改 lv_drv_conf.h"></a>修改 lv_drv_conf.h</h3><p>使能：</p><style>.pyiymrfefhbx{zoom:67%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327092308512.png" class="pyiymrfefhbx" alt="image-20240327092308512"><p>使能 frame buffer 设备（一般为fb0）：</p><style>.cfknshfrxrvf{zoom:67%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327094653000.png" class="cfknshfrxrvf" alt="image-20240327094653000"><p>使能event1 设备（根据自己的情况修改）：</p><style>.bponrkinzyqx{zoom:67%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327094732943.png" class="bponrkinzyqx" alt="image-20240327094732943"><h3 id="修改-main-c"><a href="#修改-main-c" class="headerlink" title="修改 main.c"></a>修改 main.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lvgl/lvgl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lvgl/demos/lv_demos.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lv_drivers/display/fbdev.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lv_drivers/indev/evdev.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISP_BUF_SIZE (800 * 480)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    lv_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Linux frame buffer device init*/</span></span><br><span class="line">    fbdev_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*A small buffer for LittlevGL to draw the screen&#x27;s content*/</span></span><br><span class="line">    <span class="type">static</span> <span class="type">lv_color_t</span> buf[DISP_BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Initialize a descriptor for the buffer*/</span></span><br><span class="line">    <span class="type">static</span> <span class="type">lv_disp_draw_buf_t</span> disp_buf;</span><br><span class="line">    lv_disp_draw_buf_init(&amp;disp_buf, buf, <span class="literal">NULL</span>, DISP_BUF_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Initialize and register a display driver*/</span></span><br><span class="line">    <span class="type">static</span> <span class="type">lv_disp_drv_t</span> disp_drv;</span><br><span class="line">    lv_disp_drv_init(&amp;disp_drv);</span><br><span class="line">    disp_drv.draw_buf   = &amp;disp_buf;</span><br><span class="line">    disp_drv.flush_cb   = fbdev_flush;</span><br><span class="line">    disp_drv.hor_res    = <span class="number">800</span>;</span><br><span class="line">    disp_drv.ver_res    = <span class="number">480</span>;</span><br><span class="line">    lv_disp_drv_register(&amp;disp_drv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Linux input device init */</span></span><br><span class="line">    evdev_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize and register a display input driver */</span></span><br><span class="line">    <span class="type">lv_indev_drv_t</span> indev_drv;</span><br><span class="line">    lv_indev_drv_init(&amp;indev_drv);      <span class="comment">/*Basic initialization*/</span></span><br><span class="line"></span><br><span class="line">    indev_drv.type = LV_INDEV_TYPE_POINTER;</span><br><span class="line">    indev_drv.read_cb = evdev_read;</span><br><span class="line">    <span class="type">lv_indev_t</span> * my_indev = lv_indev_drv_register(&amp;indev_drv); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Create a Demo*/</span></span><br><span class="line">    lv_demo_widgets();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Handle LVGL tasks*/</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        lv_timer_handler();</span><br><span class="line">        usleep(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Set in lv_conf.h as `LV_TICK_CUSTOM_SYS_TIME_EXPR`*/</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">custom_tick_get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint64_t</span> start_ms = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(start_ms == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv_start</span>;</span></span><br><span class="line">        gettimeofday(&amp;tv_start, <span class="literal">NULL</span>);</span><br><span class="line">        start_ms = (tv_start.tv_sec * <span class="number">1000000</span> + tv_start.tv_usec) / <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv_now</span>;</span></span><br><span class="line">    gettimeofday(&amp;tv_now, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">uint64_t</span> now_ms;</span><br><span class="line">    now_ms = (tv_now.tv_sec * <span class="number">1000000</span> + tv_now.tv_usec) / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> time_ms = now_ms - start_ms;</span><br><span class="line">    <span class="keyword">return</span> time_ms;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="修改-Makefile"><a href="#修改-Makefile" class="headerlink" title="修改 Makefile"></a>修改 Makefile</h3><p>指定编译器：</p><style>.xmhkbpbdurtr{zoom:50%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327085111265.png" class="xmhkbpbdurtr" alt="image-20240327085111265"><p>添加 lv_drivers.mk，注释掉鼠标样式源文件：</p><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240326223755408.png" class="" title="image-20240326223755408"><p>修改下构建目标名称：</p><style>.jpythmkegdfj{zoom:50%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240326223923584.png" class="jpythmkegdfj" alt="image-20240326223923584"><h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><style>.tfojjfwpkque{zoom:67%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327100056089.png" class="tfojjfwpkque" alt="image-20240327100056089"><style>.wtdfdgszsrxt{zoom:67%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327100257588.png" class="wtdfdgszsrxt" alt="image-20240327100257588"><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>不过，开发板运行会出现错误：</p><style>.uhxpieelopjl{zoom:67%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327101933178.png" class="uhxpieelopjl" alt="image-20240327101933178"><p>查看lvgl_demo文件信息，发现尽管在Makefile文件中修改了编译器的名称，但编译器还是使用x86本地的：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file lvgl_demo</span><br></pre></td></tr></table></figure><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327100821828.png" class="" title="image-20240327100821828"><p>修改Makefile，把”CC <strong>?&#x3D;</strong> arm-linux-gnueabihf-gcc“改成”CC  <strong>&#x3D;</strong> arm-linux-gnueabihf-gcc“</p><style>.nllzdlyxycfr{zoom:67%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327101857995.png" class="nllzdlyxycfr" alt="image-20240327101857995"><p>再次编译后出现<code>&#39;-Wshift-negative-value&#39;</code> 类似错误：</p><style>.pwgxenqofmyo{zoom:67%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327101502923.png" class="pwgxenqofmyo" alt="image-20240327101502923"><p>在Makefile中删除该参数：</p><style>.dqcqwcxsbium{zoom:67%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327101613081.png" class="dqcqwcxsbium" alt="image-20240327101613081"><h1 id="Gui-Guider使用"><a href="#Gui-Guider使用" class="headerlink" title="Gui Guider使用"></a>Gui Guider使用</h1><h3 id="安装与初步使用"><a href="#安装与初步使用" class="headerlink" title="安装与初步使用"></a>安装与初步使用</h3><p>参考：<a href="https://blog.csdn.net/qq_28576837/article/details/136674279">https://blog.csdn.net/qq_28576837/article/details/136674279</a></p><p>目前主要有SquareLine Studio和Gui Guider两种LVGL UI的软件，由于前者收费，这里使用NXP 开发的Guider进行UI界面设计。</p><p>下载：<a href="https://www.nxp.com.cn/design/design-center/software/development-software/gui-guider:GUI-GUIDER">https://www.nxp.com.cn/design/design-center/software/development-software/gui-guider:GUI-GUIDER</a></p><style>.htbzyqqwrjdd{zoom:50%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327144313414.png" class="htbzyqqwrjdd" alt="image-20240327144313414"><p>不同版本的Guider支持的LVGL不同，这里v1.7.0版本支持V7.10.1和v8.3.10的LVGL。</p><style>.uvmkrrtuvwzp{zoom:50%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327144344951.png" class="uvmkrrtuvwzp" alt="image-20240327144344951"><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327144637195.png" class="" title="image-20240327144637195"><p>安装成功后，按照以下顺序新建工程：</p><p>1、新建：</p><style>.jkhclbjhgviu{zoom:33%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327144645955.png" class="jkhclbjhgviu" alt="image-20240327144645955"><p>2、选择LVGL版本：</p><style>.jskefstbfoop{zoom: 33%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327144713766.png" class="jskefstbfoop" alt="image-20240327144713766"><p>3、选择模拟器设备模版：</p><style>.gcbqmsqbflic{zoom:33%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327144740096.png" class="gcbqmsqbflic" alt="image-20240327144740096"><p>4、选择应用模版，可以选择空模板：</p><style>.wkvgzzjhgibd{zoom:33%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327144950837.png" class="wkvgzzjhgibd" alt="image-20240327144950837"><p>5、配置项目信息：</p><p>1）设置工程名称：必须以字母开头，且只能包含字母、数字和下划线，长度在3到36个字母之间；</p><p>2）设置工程保存的目录，生成的代码将保存在该目录下；</p><p>3）设置屏幕色彩深度，根据实际的硬件屏幕来选择即可；</p><p>4）设置面板大小，选根据实际的硬件屏幕来选择即可；</p><ol start="5"><li>设置缩放类型，默认即可。</li></ol><style>.sbjrxtyrnnux{zoom:33%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327145407822.png" class="sbjrxtyrnnux" alt="image-20240327145407822"><p>6、结果</p><style>.ohpiefmqhhyf{zoom:50%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327145458831.png" class="ohpiefmqhhyf" alt="image-20240327145458831"><p>7、添加控件并生成代码，运行测试</p><style>.osxtojgdfrfd{zoom:50%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327222736008.png" class="osxtojgdfrfd" alt="image-20240327222736008"><h3 id="移植到linux项目工程"><a href="#移植到linux项目工程" class="headerlink" title="移植到linux项目工程"></a>移植到linux项目工程</h3><p><strong>【前提条件】：保证已构建一个能正常在linux环境下编译和运行的lvgl工程，再进行如下操作。</strong></p><p>1、找到新建工程的目录，<code>custom</code>和<code>generated</code>文件夹里面全部都是UI相关的文件：</p><style>.thmiicqbypbk{zoom:50%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327213621414.png" class="thmiicqbypbk" alt="image-20240327213621414"><style>.eeglwuennspm{zoom:50%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327213640460.png" class="eeglwuennspm" alt="image-20240327213640460"><style>.trfujsooapvz{zoom:50%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327213712094.png" class="trfujsooapvz" alt="image-20240327213712094"><p>2、在lvgl_demo目录下创建文件夹”my_gui”，把Guider新建工程下<strong>custom</strong>和<strong>generate</strong>目录中的.c和.h文件复制到里面：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> my_gui</span><br></pre></td></tr></table></figure><style>.ikpesbjykddq{zoom:50%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327221200337.png" class="ikpesbjykddq" alt="image-20240327221200337"><style>.tglclkodqjga{zoom:50%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327221247843.png" class="tglclkodqjga" alt="image-20240327221247843"><style>.ecglnibvludt{zoom:50%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327221315186.png" class="ecglnibvludt" alt="image-20240327221315186"><p>结果如下：</p><style>.khggyhpgzpzj{zoom:50%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327222105119.png" class="khggyhpgzpzj" alt="image-20240327222105119"><p>3、依次修改上面<strong>全部</strong><code>.c</code>和<code>.h</code>文件中的<code>#include &quot;lvgl.h&quot;</code>，根据实际情况指定lvgl的头文件位置，例如：</p><style>.mxpglzyhyakj{zoom:50%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327222227601.png" class="mxpglzyhyakj" alt="image-20240327222227601"><style>.afosspbuduta{zoom:50%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327221523001.png" class="afosspbuduta" alt="image-20240327221523001"><p>4、在原来的”main.c”文件中，作以下修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my_gui/gui_guider.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my_gui/events_init.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">lv_ui guider_ui;</span><br></pre></td></tr></table></figure><style>.uvpdfwtbusln{zoom:50%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327162913690.png" class="uvpdfwtbusln" alt="image-20240327162913690"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setup_ui(&amp;guider_ui);</span><br><span class="line">events_init(&amp;guider_ui);</span><br></pre></td></tr></table></figure><style>.pcwkfggrhrup{zoom:50%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327162518627.png" class="pcwkfggrhrup" alt="image-20240327162518627"><p>5、在my_gui目录下，新建<code>my_gui.mk</code>的Makefile文件，添加内容：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MY_GUI_DIR_NAME ?= my_gui</span><br><span class="line"></span><br><span class="line">CFLAGS += -I<span class="variable">$(MY_GUI_DIR_NAME)</span>/<span class="variable">$(MY_GUI_DIR_NAME)</span></span><br><span class="line"></span><br><span class="line">CSRCS += <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(LVGL_DIR)</span>/<span class="variable">$(MY_GUI_DIR_NAME)</span>/*.c)</span></span><br></pre></td></tr></table></figure><p>6、编译</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：在试验过程中发现，使用如下高级控件，若原来的lvgl版本和Guider里面的lvgl版本不一致，会导致编译过程，无法找到指定的控件程序实现的函数接口，编译出错。需根据原来的lvgl版本进行适当使用控件。</p><style>.acwgvesjfmwd{zoom:67%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240327222836632.png" class="acwgvesjfmwd" alt="image-20240327222836632"><h1 id="模块学习"><a href="#模块学习" class="headerlink" title="模块学习"></a>模块学习</h1><p>英文文档：</p><p><a href="https://docs.lvgl.io/master/overview/obj.html">https://docs.lvgl.io/master/overview/obj.html</a></p><p>中文文档：</p><p><a href="https://lvgl.100ask.net/master/overview/style.html">https://lvgl.100ask.net/master/overview/style.html</a></p><p><a href="https://deepinout.com/lvgl-tutorials">https://deepinout.com/lvgl-tutorials</a></p><h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><h2 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h2><h2 id="仪表盘"><a href="#仪表盘" class="headerlink" title="仪表盘"></a>仪表盘</h2><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><h2 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h2><h2 id="其他移植"><a href="#其他移植" class="headerlink" title="其他移植"></a>其他移植</h2><h3 id="移植情况"><a href="#移植情况" class="headerlink" title="移植情况"></a>移植情况</h3><p>这里使用韦东山大佬的“嵌入式Linux相机”项目的数据采集部分，过程如图：</p><style>.dwhybxmghkyi{zoom:67%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240329103503974.png" class="dwhybxmghkyi" alt="image-20240329103503974"><h3 id="camera相关代码移植"><a href="#camera相关代码移植" class="headerlink" title="camera相关代码移植"></a>camera相关代码移植</h3><p>camera部分移植了韦东山大佬“嵌入式Linux相机”相关项目的代码，编译过程发现缺少’jconfig.h’头文件，后面重新编译了libjpeg库，添加安装目录的linclude目录下的<code>jconfig.h</code>头文件：</p><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240329192608688.png" class="" title="image-20240329192608688"><p>重新编译项目后，在链接过程出错：</p><style>.mxogettqwokm{zoom:67%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240329192728297.png" class="mxogettqwokm" alt="image-20240329192728297"><p>该部分需要在Makefile文件的<code>LDFLAGS</code>目标添加<strong>jpeg</strong>的<code> -L$(LVGL_DIR)/modules/video2lcd/convert/jpeg/lib/</code>链接目录和<code>-ljpeg</code>链接参数：</p><style>.nycdofhkckmc{zoom:67%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240329195424549.png" class="nycdofhkckmc" alt="image-20240329195424549"><h3 id="jpeg移植"><a href="#jpeg移植" class="headerlink" title="jpeg移植"></a>jpeg移植</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#下载</span></span><br><span class="line">wget https://www.ijg.org/files/jpegsrc.v9b.tar.gz</span><br><span class="line"><span class="comment">#配置</span></span><br><span class="line"><span class="built_in">cd</span> jpeg-9b</span><br><span class="line"><span class="built_in">mkdir</span> ../jpeg</span><br><span class="line">./configure CC=arm-linux-gnueabihf-gcc --prefix=/home/thousand/imx6ull/project/smart_fruit_scale/modules/video2lcd/convert/jpeg --host=arm-linux-gnueabihf</span><br><span class="line"><span class="comment">#编译</span></span><br><span class="line">make</span><br><span class="line"><span class="comment">#安装到../jpeg目录</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>安装完后，使用<code>tree ../jpeg</code>查看安装目录的结构，其中<code>bin</code>和<code>lib</code>目录需移植到开发板的根文件系统中，编程时只需包含<code>lib</code>目录下的头文件即可。</p><style>.sbhwgkhoyuzq{zoom:67%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240329191821781.png" class="sbhwgkhoyuzq" alt="image-20240329191821781"><p>开发板也要移植<code>lib</code>库，否则运行程序出现错误：</p><style>.wqvvnriyhlit{zoom:50%;}</style><img src="/2024/03/26/LVGL%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240329201430164.png" class="wqvvnriyhlit" alt="image-20240329201430164"><p>为了不破坏软链接关系，先打包再传输到开发板的系统：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -czf libjpeg.tar.gz xxxx/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1>]]></content>
      
      
      
        <tags>
            
            <tag> LVGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式项目-基于STM32和RT-Thread的智能家居语音控制系统</title>
      <link href="/2024/03/25/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8ESTM32%E5%92%8CRT-Thread%E7%9A%84%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E8%AF%AD%E9%9F%B3%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/03/25/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8ESTM32%E5%92%8CRT-Thread%E7%9A%84%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E8%AF%AD%E9%9F%B3%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><h1 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h1><h1 id="软件开发"><a href="#软件开发" class="headerlink" title="软件开发"></a>软件开发</h1><h1 id="测试与调试"><a href="#测试与调试" class="headerlink" title="测试与调试"></a>测试与调试</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 嵌入式项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式项目-基于imx6ull和OpenCV的水果识别与称重系统</title>
      <link href="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>利用imx6ull开发板，通过摄像头拍摄水果照片输入到系统中，经相关识别算法检测后，称重传感器对水果进行称重，屏幕显示相关结果，扬声器辅以相关语音提示，最终计算价格并在数据库中记录结账的信息。</p><h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><h2 id="模块组成"><a href="#模块组成" class="headerlink" title="模块组成"></a>模块组成</h2><style>.poisechdzbcb{zoom:67%;}</style><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240324153734781.png" class="poisechdzbcb" alt="image-20240324153734781"><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><style>.hgcvlonratyd{zoom:67%;}</style><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240330194147804.png" class="hgcvlonratyd" alt="image-20240330194147804"><h2 id="技术使用"><a href="#技术使用" class="headerlink" title="技术使用"></a>技术使用</h2><p>技术栈：Linux系统移植、Linux驱动移植与开发、Linux C应用编程、<del>Linux网络编程</del>、imx6ull ARM SoC应用、lvgl应用、数据库应用等。</p><p>其他工具：cmake、gdb调试器、arm-linux-gnueabihf-gcc交叉编译器</p><h1 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h1><p>硬件组成：</p><ul><li>正点原子imx6ull mini开发板</li><li>USB摄像头</li><li>RGB屏幕</li><li>称重传感器</li><li>音频模块（待定…）</li></ul><h1 id="Linux系统移植"><a href="#Linux系统移植" class="headerlink" title="Linux系统移植"></a>Linux系统移植</h1><h2 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h2><p>使用“gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf”。</p><h2 id="uboot编译"><a href="#uboot编译" class="headerlink" title="uboot编译"></a>uboot编译</h2><p>使用正点原子imx6ull的默认uboot配置，仅负责启动kernel：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> uboot-imx-2016.03/</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_14x14_ddr512_emmc_defconfig</span><br><span class="line">make V=1 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j12</span><br></pre></td></tr></table></figure><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240324181823362.png" class="" title="image-20240324181823362"><h2 id="kernel配置与编译"><a href="#kernel配置与编译" class="headerlink" title="kernel配置与编译"></a>kernel配置与编译</h2><p>使用正点原子kernel的默认配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- imx_alientek_emmc_defconfig</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于正点原子的内核源码默认没有开启<strong>UVC设备类</strong>驱动，需要自己添加：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig</span><br></pre></td></tr></table></figure><style>.ufvrjiwcqzdi{zoom:50%;}</style><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240324192811419.png" class="ufvrjiwcqzdi" alt="image-20240324192811419"><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240324193520598.png" class="" title="image-20240324193520598"><style>.dwkskjpfbnkx{zoom:50%;}</style><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240324193152051.png" class="dwkskjpfbnkx" alt="image-20240324193152051"><style>.muwnnxnquwkb{zoom:50%;}</style><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240324193302372.png" class="muwnnxnquwkb" alt="image-20240324193302372"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编译</span></span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- all -j16</span><br></pre></td></tr></table></figure><p>后面系统启动，插入USB摄像头，会有相关提示，&#x2F;dev目录下会出现video1设备。若只有一个&#x2F;dev&#x2F;video0设备，则内核的USB驱动配置出错。</p><style>.cochhlbdilpk{zoom:50%;}</style><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240325083810252.png" class="cochhlbdilpk" alt="image-20240325083810252"><style>.ceyoqesifwtb{zoom:50%;}</style><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240325095718854.png" class="ceyoqesifwtb" alt="image-20240325095718854"><h2 id="rootfs配置与编译"><a href="#rootfs配置与编译" class="headerlink" title="rootfs配置与编译"></a>rootfs配置与编译</h2><p>使用buildroot工具构建rootfs：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入配置界面</span></span><br><span class="line"><span class="built_in">cd</span> buildroot-2019.02.6/</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p><strong>Target options</strong>配置：</p><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240324165548768.png" class="" title="image-20240324165548768"><p><strong>Toolchain</strong>配置</p><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240324170102584.png" class="" title="image-20240324170102584"><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240324170223832.png" class="" title="image-20240324170223832"><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240324170240448.png" class="" title="image-20240324170240448"><p><strong>System configuration</strong>根据自己习惯设置：</p><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240324170704480.png" class="" title="image-20240324170704480"><p>编译测试：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make</span><br></pre></td></tr></table></figure><p>若出现问题参考文档后面的<strong>问题记录</strong>部分。</p><h3 id="其他软件包"><a href="#其他软件包" class="headerlink" title="其他软件包"></a>其他软件包</h3><p>相关软件包包括：</p><ul><li>openssh</li><li><del>Python</del></li><li><del>OpenCV</del></li><li><del>http&#x2F;https</del></li></ul><h4 id="openssh"><a href="#openssh" class="headerlink" title="openssh"></a>openssh</h4><p>添加<strong>ssh</strong>功能方便后续进行“网络根文件系统启动”，如图：</p><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240324180011764.png" class="" title="image-20240324180011764"><h2 id="SD卡烧录"><a href="#SD卡烧录" class="headerlink" title="SD卡烧录"></a>SD卡烧录</h2><p>参考：<a href="https://blog.csdn.net/qq153471503/article/details/126775959">https://blog.csdn.net/qq153471503/article/details/126775959</a></p><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><style>.tccloahrkyuq{zoom:67%;}</style><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240325142730042.png" class="tccloahrkyuq" alt="image-20240325142730042"><p>将一张SD卡分成了三部分：</p><ul><li>第一部分：分区格式为<strong>原始格式</strong>，用于存放uboot；</li><li>第二部分：扇区起始地址默认2048，大小为50MB，分区格式为<strong>FAT</strong>，用于存放内核和设备树；</li><li>第三部分：大小为SD卡剩余的空间，分区格式为<strong>Ext3或Ext4</strong>，用于存放rootfs文件系统。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看tf卡的设备</span></span><br><span class="line">sudo fdisk -l</span><br><span class="line"><span class="comment">#若ubuntu只有一个盘且无分区(sdb1…表示sd卡中的分区)，则设备为/dev/sdb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#进入tf卡设备</span></span><br><span class="line">sudo fdisk /dev/sdb</span><br><span class="line"><span class="comment">#删除分区：d</span></span><br><span class="line"><span class="comment">#添加分区：n</span></span><br><span class="line"><span class="comment">#查看分区：p</span></span><br><span class="line"><span class="comment">#保存操作：w</span></span><br><span class="line"><span class="comment">#注：修改后，需要用w保存修改。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#按p检查是否存在原分区，有的话按d删除</span></span><br><span class="line"><span class="comment">#删除原分区后，按n新建两个分区，第一个分区大小根据zImage和设备树文件等大小；第二个分区用尽剩余容量。</span></span><br><span class="line"><span class="comment">#按w写入修改后的信息，再按p检查结果是否有误，最后按q退出</span></span><br></pre></td></tr></table></figure><p>设置sdb1分区格式为FAT：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkfs.vfat /dev/sdb1</span><br></pre></td></tr></table></figure><p>设置sdb2分区格式为Ext3或Ext4都可以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkfs.ext3 /dev/sdb2</span><br><span class="line">sudo mkfs.ext4 /dev/sdb2</span><br></pre></td></tr></table></figure><h3 id="uboot烧录"><a href="#uboot烧录" class="headerlink" title="uboot烧录"></a>uboot烧录</h3><p>将得到的u-boot.imx文件拷贝：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">dd</span> <span class="keyword">if</span>=u-boot.imx of=/dev/sdb bs=1k seek=1 conv=fsync</span><br></pre></td></tr></table></figure><h3 id="kernel和dtbs拷贝"><a href="#kernel和dtbs拷贝" class="headerlink" title="kernel和dtbs拷贝"></a>kernel和dtbs拷贝</h3><p>创建挂载点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /mountpoint</span><br></pre></td></tr></table></figure><p>挂载分区一：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/sdb1 /mountpoint</span><br></pre></td></tr></table></figure><p>使用cp命令将zImage和相关*.dtb文件拷贝进&#x2F;mountpoint目录，然后取消挂载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> linux-imx-4.1.15/</span><br><span class="line">sudo <span class="built_in">cp</span> <span class="built_in">arch</span>/arm/boot/zImage /mountpoint</span><br><span class="line">sudo <span class="built_in">cp</span> <span class="built_in">arch</span>/arm/boot/dts/imx6ull-alientek-emmc.dtb /mountpoint</span><br><span class="line"></span><br><span class="line">sudo <span class="built_in">sync</span></span><br><span class="line">sudo umount /mountpoint</span><br></pre></td></tr></table></figure><h3 id="rootfs拷贝"><a href="#rootfs拷贝" class="headerlink" title="rootfs拷贝"></a>rootfs拷贝</h3><p>挂载分区二：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/sdb2 /mountpoint</span><br></pre></td></tr></table></figure><p>解压文件系统文件系统包rootfs.tar：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> buildroot-2019.02.6</span><br><span class="line">sudo tar -xf output/images/rootfs.tar -C /mountpoint</span><br></pre></td></tr></table></figure><p>然后取消挂载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">sync</span></span><br><span class="line">sudo umount /mountpoint</span><br></pre></td></tr></table></figure><h2 id="系统运行测试"><a href="#系统运行测试" class="headerlink" title="系统运行测试"></a>系统运行测试</h2><p>上电启动开发板，设置uboot启动参数，检查是否正确启动内核与系统：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置</span></span><br><span class="line">setenv bootargs <span class="string">&#x27;console=ttymxc0,115200 root=/dev/mmcblk0p2 rootwait rw&#x27;</span></span><br><span class="line">setenv bootcmd <span class="string">&#x27;fatload mmc 0:1 80800000 zImage; fatload mmc 0:1 83000000 imx6ull-alientek-emmc.dtb; bootz 80800000 - 83000000;&#x27;</span></span><br><span class="line">saveenv</span><br><span class="line"><span class="comment">#启动</span></span><br><span class="line">boot</span><br></pre></td></tr></table></figure><p>可以开启网络和tftp功能，方便开发阶段进行调试：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#uboot网络配置</span></span><br><span class="line">setenv ipaddr 192.168.123.66<span class="comment">#设置开发板IP地址</span></span><br><span class="line">setenv netmask 255.255.255.0<span class="comment">#子网掩码配置</span></span><br><span class="line">setenv ethaddr  b8:ae:1d:01:00:00<span class="comment">#设置网卡mac地址，48bit 的地址不和其他重复即可</span></span><br><span class="line"></span><br><span class="line">setenv gatewayip 192.168.123.1<span class="comment">#设置网关</span></span><br><span class="line">setenv serverip 192.168.123.166<span class="comment">#设置tftp服务IP地址</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#tftp传输文件，前面设置serverip变量后主机ip地址可省略</span></span><br><span class="line">tftpboot [内存地址] [[主机ip地址:]文件名]</span><br><span class="line"><span class="comment">#uboot加载设备树到内存中</span></span><br><span class="line">tftp 80800000 imx6ull-alientek-emmc.dtb</span><br><span class="line"><span class="comment">#uboot加载内核到内存中</span></span><br><span class="line">tftp 83000000 zImage</span><br><span class="line"><span class="comment">#启动kernel</span></span><br><span class="line">setenv bootargs <span class="string">&#x27;console=ttymxc0,115200 root=/dev/mmcblk0p2 rootwait rw&#x27;</span></span><br><span class="line">bootz 80800000 - 83000000</span><br></pre></td></tr></table></figure><h2 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h2><h3 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h3><p>检查系统的网卡：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><style>.hgxsrkbqyifx{zoom:50%;}</style><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240324185250769.png" class="hgxsrkbqyifx" alt="image-20240324185250769"><p>网络设置，<code>vi /etc/init.d/rcS</code>打开该文件，在“&#x2F;etc&#x2F;init.d&#x2F;rcS”文件中加入：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 up</span><br><span class="line">ifconfig eth0 192.168.123.66 netmask 255.255.255.0</span><br><span class="line">route add default gw 192.168.123.1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;nameserver 192.168.123.1&quot;</span> &gt; /etc/resolv.conf</span><br></pre></td></tr></table></figure><style>.bqncpuywgwpf{zoom:50%;}</style><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240324185433027.png" class="bqncpuywgwpf" alt="image-20240324185433027"><p>重启系统后，检查网络：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure><style>.dhfrvcaabwms{zoom:50%;}</style><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240324190427418.png" class="dhfrvcaabwms" alt="image-20240324190427418"><h3 id="开启ssh"><a href="#开启ssh" class="headerlink" title="开启ssh"></a>开启ssh</h3><p>uboot启动kernel进入linux系统后，ssh无法正常工作。修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件，修改对应的内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#PermitRootLogin yes</span><br><span class="line">#PermitEmptyPasswords yes</span><br></pre></td></tr></table></figure><style>.gjiblndikhae{zoom:67%;}</style><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240901170114696.png" class="gjiblndikhae" alt="image-20240901170114696"><style>.yfpstqbykzxl{zoom:67%;}</style><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240901170039777.png" class="yfpstqbykzxl" alt="image-20240901170039777"><p>重启后，ssh连接正常。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ubuntu新建ssh_tets.txt文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ssh test.&quot;</span> &gt;&gt; ssh_test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#开发板系统重启后，利用ssh的scp进行传输文件</span></span><br><span class="line">reboot</span><br><span class="line">scp thousand@192.168.123.166:/home/thousand/ssh_test.txt ./</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="驱动移植"><a href="#驱动移植" class="headerlink" title="驱动移植"></a>驱动移植</h1><p>该系统涉及的相关驱动包括：</p><ul><li>usb（官方内核自带）</li><li>显示屏eLCDIF（官方内核自带）</li><li>网络接口（官方内核自带）</li><li>传感器ADC或者IIO（移植）</li><li>电容屏触摸（官方内核自带）</li></ul><p>大部分直接使用正点原子官方自带的驱动，称重传感器的ADC或者IIO等驱动需要自己移植。</p><h2 id="称重传感器驱动"><a href="#称重传感器驱动" class="headerlink" title="称重传感器驱动"></a>称重传感器驱动</h2><p>若称重传感器输出的是模拟量信号，则需要使用imx6ull的内部ADC；若传感器内部集成了ADC，对外提供IIC或SPI接口，则使用Linux的IIO子系统获取相应的数值。</p><p>这里使用内置ADC的称重传感器，ADC为HX711转换芯片，故传感器驱动使用Linux的IIO驱动框架，开发相应驱动，获取传感器的数值。</p><h1 id="应用开发"><a href="#应用开发" class="headerlink" title="应用开发"></a>应用开发</h1><p>应用程序分为各模块进行开发，整体以LVGL框架为中心，响应其他需要显示的任务，如待机息屏、拍摄显示、识别结果、结账结果、提示和其他需显示信息，辅以音频对各模块状态进行提示，最后的结果存储到数据库中。</p><p>软件采用多线程设计，各工作任务相互联系，完成整个工作流程。</p><p>其他功能补充：为开发板添加OTA远程自动升级等。</p><h2 id="图像采集"><a href="#图像采集" class="headerlink" title="图像采集"></a>图像采集</h2><p>主要是应用v4l2框架，驱动USB摄像头采集原始数据，将原始YUV数据转换成RGB数据进行下一步处理。</p><h3 id="摄像头采集"><a href="#摄像头采集" class="headerlink" title="摄像头采集"></a>摄像头采集</h3><p>USB摄像头用的是UVC（USB Video Class）标准类，免驱。v4l2（Video for linux2）是linux提供的视频设备编程API。</p><style>.xwxgmxbqhtsu{zoom: 50%;}</style><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240324200305022.png" class="xwxgmxbqhtsu" alt="image-20240324200305022"><h3 id="图像格式转换"><a href="#图像格式转换" class="headerlink" title="图像格式转换"></a>图像格式转换</h3><p>USB摄像头一般都支持输出YUV数据，YUV是一种颜色空间，通常需要转成RGB使用（bmp保存或LCD显示，等），其中YUYV是YUV的一种，也叫YUV422。</p><p>这里把YUV422转成RGB565，参考：<a href="https://blog.csdn.net/hp0773/article/details/8813987%E3%80%82">https://blog.csdn.net/hp0773/article/details/8813987。</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RANGE_LIMIT(x) (x &gt; 255 ? 255 : (x &lt; 0 ? 0 : x))</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">YUV422ToRGB565</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* inbuf, <span class="type">void</span>* outbuf, <span class="type">int</span> width, <span class="type">int</span> height)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> rows, cols;</span><br><span class="line"><span class="type">int</span> y, u, v, r, g, b;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *yuv_buf;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> *rgb_buf;</span><br><span class="line"><span class="type">int</span> y_pos,u_pos,v_pos;</span><br><span class="line"> </span><br><span class="line">yuv_buf = (<span class="type">unsigned</span> <span class="type">char</span> *)inbuf;</span><br><span class="line">rgb_buf = (<span class="type">unsigned</span> <span class="type">short</span> *)outbuf;</span><br><span class="line"> </span><br><span class="line">y_pos = <span class="number">0</span>;</span><br><span class="line">u_pos = <span class="number">1</span>;</span><br><span class="line">v_pos = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (rows = <span class="number">0</span>; rows &lt; height; rows++) &#123;</span><br><span class="line"><span class="keyword">for</span> (cols = <span class="number">0</span>; cols &lt; width; cols++) &#123;</span><br><span class="line">y = yuv_buf[y_pos];</span><br><span class="line">u = yuv_buf[u_pos] - <span class="number">128</span>;</span><br><span class="line">v = yuv_buf[v_pos] - <span class="number">128</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// R = Y + 1.402*(V-128)</span></span><br><span class="line"><span class="comment">// G = Y - 0.34414*(U-128)</span></span><br><span class="line"><span class="comment">// B = Y + 1.772*(U-128)</span></span><br><span class="line">r = RANGE_LIMIT(y + v + ((v * <span class="number">103</span>) &gt;&gt; <span class="number">8</span>));</span><br><span class="line">g = RANGE_LIMIT(y - ((u * <span class="number">88</span>) &gt;&gt; <span class="number">8</span>) - ((v * <span class="number">183</span>) &gt;&gt; <span class="number">8</span>));</span><br><span class="line">b = RANGE_LIMIT(y + u + ((u * <span class="number">198</span>) &gt;&gt; <span class="number">8</span>));</span><br><span class="line"> </span><br><span class="line">*rgb_buf++ = (((r &amp; <span class="number">0xf8</span>) &lt;&lt; <span class="number">8</span>) | ((g &amp; <span class="number">0xfc</span>) &lt;&lt; <span class="number">3</span>) | ((b &amp; <span class="number">0xf8</span>) &gt;&gt; <span class="number">3</span>));</span><br><span class="line"> </span><br><span class="line">y_pos += <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (cols &amp; <span class="number">0x01</span>) &#123;</span><br><span class="line">u_pos += <span class="number">4</span>;</span><br><span class="line">v_pos += <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="水果识别"><a href="#水果识别" class="headerlink" title="水果识别"></a>水果识别</h2><p>使用本地实现的OpenCV识别水果程序、调用YOLO识别项目本地部署，对水果进行识别。</p><p>这里暂时调用百度的在线识别接口进行识别，在百度图像识别网站按要求注册并配置。</p><p>1、移植openssl库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.openssl.org/source/old/1.1.1/openssl-1.1.1.tar.gz</span><br><span class="line">tar -xvf openssl-1.1.1.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> openssl-1.1.1</span><br><span class="line"><span class="built_in">mkdir</span> ~/openssl_install</span><br><span class="line">./config no-asm shared no-async --prefix=$(<span class="built_in">pwd</span>)/install --cross-compile-prefix=arm-linux-gnueabihf-</span><br><span class="line"> <span class="comment">#no-asm:  在交叉编译过程中不使用汇编代码代码加速编译过程；</span></span><br><span class="line"> <span class="comment">#shared: 生成动态连接库。</span></span><br><span class="line"> <span class="comment">#no-async: 交叉编译工具链没有提供GNU C的ucontext库</span></span><br><span class="line"> <span class="comment">#–prefix=: 安装路径</span></span><br><span class="line"> <span class="comment">#–cross-compile-prefix=: 交叉编译工具</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#打开Makefile</span></span><br><span class="line">vi Makefile</span><br><span class="line"><span class="comment"># 修改CROSS_COMPILE=arm-linux-gnueabihf-</span></span><br><span class="line"><span class="comment"># 删除所有的-m64</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#编译和安装</span></span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>查看install目录和install&#x2F;lib：</p><style>.nqqiaszrbegr{zoom:67%;}</style><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240901161606641.png" class="nqqiaszrbegr" alt="image-20240901161606641"><style>.cciydphozeki{zoom:67%;}</style><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240901170814958.png" class="cciydphozeki" alt="image-20240901170814958"><p>复制“lib”目录下的库文件到开发板根文件系统的”&#x2F;lib”目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开发板中ssh网络传参</span></span><br><span class="line">scp -r thousand@192.168.123.166:/home/thousand/imx6ull/project/smart_fruit_scale/modules/identify/openssl-1.1.1l/install/lib/* ~/</span><br><span class="line"><span class="built_in">mv</span> ~/lib openssl_lib</span><br><span class="line"><span class="built_in">cp</span> openssl_lib/* /lib</span><br><span class="line"></span><br><span class="line"><span class="comment">#主机中nfs挂载的根文件系统下操作：</span></span><br><span class="line"><span class="built_in">cd</span> install</span><br><span class="line"><span class="built_in">cp</span> -r lib/* /home/thousand/licheepi/nfs/rootfs/lib</span><br></pre></td></tr></table></figure><p>2、移植libcurl库</p><p>下载源码：<a href="https://github.com/curl/curl/releases%EF%BC%8Ccurl-8.0.0%E7%89%88%E6%9C%AC%E3%80%82">https://github.com/curl/curl/releases，curl-8.0.0版本。</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> curl-8.0.0</span><br><span class="line">./configure --prefix=$(<span class="built_in">pwd</span>)/install --host=arm-linux-gnueabihf CC=arm-linux-gnueabihf-gcc --with-openssl=$(<span class="built_in">pwd</span>)/../openssl-1.1.1l/install/</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>查看install目录：</p><style>.pkibwvbepsnw{zoom:67%;}</style><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240901161531895.png" class="pkibwvbepsnw" alt="image-20240901161531895"><p>复制bin、include、lib文件夹目录文件到开发板对应的目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开发板中ssh网络传参</span></span><br><span class="line">scp -r thousand@192.168.123.166:/home/thousand/imx6ull/project/smart_fruit_scale/modules/identify/curl-8.0.0/install/ ~/</span><br><span class="line"><span class="built_in">cp</span> -r /lib/install/* /lib/install/* /lib/install/* /lib</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/sdb2 /mountpoint</span><br><span class="line">sudo <span class="built_in">rm</span> -rf /mountpoint/</span><br><span class="line"><span class="built_in">cd</span> /buildroot2019</span><br><span class="line">sudo tar -xf output/images/rootfs.tar -C /mountpoint</span><br><span class="line">sudo <span class="built_in">cp</span> -rf /home/thousand/imx6ull/project/smart_fruit_scale/modules/identify/openssl-1.1.1l/install /mountpoint/files/</span><br><span class="line">sudo <span class="built_in">cp</span> -rf /home/thousand/imx6ull/project/smart_fruit_scale/modules/identify/curl-8.0.0/install /mountpoint/files/</span><br><span class="line">sudo <span class="built_in">cp</span> /home/thousand/imx6ull/project/smart_fruit_scale/build/bin/smart_fruit_scale /mountpoint/files/</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/opt/curl/bin:/opt/openssl/bin</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/lib:/usr/lib:/usr/local/lib:/opt/curl/lib:/opt/openssl/lib</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、识别程序</p><p>图像base64和url编码，<code>base64.c</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base64.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Base64 编码表</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> base64_chars[] =</span><br><span class="line">    <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span></span><br><span class="line">    <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span></span><br><span class="line">    <span class="string">&quot;0123456789+/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Base64 编码函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span>* <span class="title function_">base64_encode</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *input, <span class="type">size_t</span> length)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="literal">NULL</span> || length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 检查输入参数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> enc_len = <span class="number">4</span> * ((length + <span class="number">2</span>) / <span class="number">3</span>);  <span class="comment">// 计算 Base64 编码后的长度</span></span><br><span class="line">    <span class="type">char</span> *encoded = (<span class="type">char</span> *)<span class="built_in">malloc</span>(enc_len + <span class="number">1</span>);  <span class="comment">// 分配编码后的字符串空间</span></span><br><span class="line">    <span class="keyword">if</span> (encoded == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 检查内存分配</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; length) &#123;</span><br><span class="line">        <span class="comment">// 获取3个字节的数据</span></span><br><span class="line">        <span class="type">int</span> octet_a = i &lt; length ? input[i++] : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> octet_b = i &lt; length ? input[i++] : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> octet_c = i &lt; length ? input[i++] : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将这3个字节组合成一个24位的整数</span></span><br><span class="line">        <span class="type">int</span> triple = (octet_a &lt;&lt; <span class="number">16</span>) | (octet_b &lt;&lt; <span class="number">8</span>) | octet_c;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将24位整数分割成4个6位的数并查找 Base64 编码字符</span></span><br><span class="line">        encoded[j++] = base64_chars[(triple &gt;&gt; <span class="number">18</span>) &amp; <span class="number">0x3F</span>];</span><br><span class="line">        encoded[j++] = base64_chars[(triple &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x3F</span>];</span><br><span class="line">        encoded[j++] = base64_chars[(triple &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x3F</span>];</span><br><span class="line">        encoded[j++] = base64_chars[triple &amp; <span class="number">0x3F</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加必要的 &#x27;=&#x27; 填充</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; (<span class="number">3</span> - length % <span class="number">3</span>) % <span class="number">3</span>; k++) &#123;</span><br><span class="line">        encoded[enc_len - <span class="number">1</span> - k] = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    encoded[enc_len] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 终止符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> encoded;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// URL 编码函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span>* <span class="title function_">url_encode</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">size_t</span> length)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *encoded = (<span class="type">char</span> *)<span class="built_in">malloc</span>(length * <span class="number">3</span> + <span class="number">1</span>);  <span class="comment">// 分配足够的空间</span></span><br><span class="line">    <span class="keyword">if</span> (encoded == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 内存分配失败</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pstr = str;</span><br><span class="line">    <span class="type">char</span> *pbuf = encoded;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pstr[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; pstr[i] &lt;= <span class="string">&#x27;z&#x27;</span>) ||</span><br><span class="line">            (pstr[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; pstr[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) ||</span><br><span class="line">            (pstr[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; pstr[i] &lt;= <span class="string">&#x27;9&#x27;</span>) ||</span><br><span class="line">            pstr[i] == <span class="string">&#x27;-&#x27;</span> || pstr[i] == <span class="string">&#x27;_&#x27;</span> ||</span><br><span class="line">            pstr[i] == <span class="string">&#x27;.&#x27;</span> || pstr[i] == <span class="string">&#x27;~&#x27;</span>) &#123;</span><br><span class="line">            *pbuf++ = pstr[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(pbuf, <span class="string">&quot;%%%02X&quot;</span>, pstr[i]);</span><br><span class="line">            pbuf += <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *pbuf = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> encoded;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件数据</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span>* <span class="title function_">read_file</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">size_t</span> *filesize)</span> &#123;</span><br><span class="line">    FILE *file = fopen(filename, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;File open error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fseek(file, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    <span class="type">size_t</span> size = ftell(file);</span><br><span class="line">    fseek(file, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *data = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Memory allocation error&quot;</span>);</span><br><span class="line">        fclose(file);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fread(data, <span class="number">1</span>, size, file);</span><br><span class="line">    fclose(file);</span><br><span class="line"></span><br><span class="line">    *filesize = size;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取图片并转为 URL 编码</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">getbase64</span><span class="params">(<span class="type">char</span>* photoname)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> filesize;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *filedata = read_file(photoname, &amp;filesize);</span><br><span class="line">    <span class="keyword">if</span> (filedata == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to read the file\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 文件读取失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *base64_encoded = base64_encode(filedata, filesize);</span><br><span class="line">    <span class="built_in">free</span>(filedata);  <span class="comment">// 释放文件数据内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (base64_encoded == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Base64 encoding failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// Base64 编码失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到编码头部后面的逗号位置</span></span><br><span class="line">    <span class="type">char</span> *comma_pos = <span class="built_in">strchr</span>(base64_encoded, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (comma_pos != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 移除编码头，只保留逗号后面的内容</span></span><br><span class="line">        base64_encoded = comma_pos + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *url_encoded = url_encode(base64_encoded, <span class="built_in">strlen</span>(base64_encoded));</span><br><span class="line">    <span class="built_in">free</span>(base64_encoded);  <span class="comment">// 释放Base64编码后的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (url_encoded == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;URL encoding failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// URL 编码失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> url_encoded;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>base64.h</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BASE46_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASE46_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">getbase64</span><span class="params">(<span class="type">char</span>* photoname)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//BASE46_H</span></span></span><br></pre></td></tr></table></figure><p><code>fruit_identify.c</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cjson/cJSON.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base64/base64.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">access_token_callback</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, <span class="type">void</span> *stream)</span> </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *buf = (<span class="type">char</span> *)<span class="built_in">malloc</span> (size * nmemb + <span class="number">8</span> );</span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="string">&#x27;\0&#x27;</span>,size * nmemb + <span class="number">8</span>);</span><br><span class="line"><span class="built_in">strncpy</span>(buf, ptr, size * nmemb);</span><br><span class="line"></span><br><span class="line">cJSON *json= cJSON_Parse(buf);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *access_token_result = (<span class="type">char</span> *)stream;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncpy</span>(access_token_result,cJSON_GetObjectItem(json,<span class="string">&quot;access_token&quot;</span>)-&gt;valuestring,<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//printf(&quot;stream:%s\n&quot;,(char *)stream);</span></span><br><span class="line"></span><br><span class="line">cJSON_Delete(json);</span><br><span class="line"><span class="built_in">free</span>(buf);</span><br><span class="line"><span class="keyword">return</span> size * nmemb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">post_access_token</span><span class="params">(<span class="type">char</span> *access_token)</span></span><br><span class="line">&#123;</span><br><span class="line">CURL *curl;</span><br><span class="line">CURLcode result_code;</span><br><span class="line"><span class="type">int</span> error_code = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> url[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">char</span> access_token_url[] = <span class="string">&quot;https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&quot;</span>;</span><br><span class="line"><span class="type">char</span> AK[] = <span class="string">&quot;HQeSf9Hh0lBSzNfB6McynDSP&quot;</span>;</span><br><span class="line"><span class="type">char</span> SK[] = <span class="string">&quot;IVWFBPBVf2kb2JZvuf10G5dJfW1jt6pI&quot;</span>;</span><br><span class="line"><span class="type">char</span> access_token_result[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">curl = curl_easy_init();</span><br><span class="line"><span class="keyword">if</span> (curl) &#123;</span><br><span class="line"><span class="comment">//std::string url = access_token_url + &quot;&amp;client_id=&quot; + AK + &quot;&amp;client_secret=&quot; + SK;</span></span><br><span class="line"><span class="built_in">sprintf</span>(url,<span class="string">&quot;%s&amp;client_id=%s&amp;client_secret=%s&quot;</span>,access_token_url,AK,SK);</span><br><span class="line"><span class="comment">//printf(&quot;url: %s\n&quot;,url );</span></span><br><span class="line">curl_easy_setopt(curl, CURLOPT_URL, url);</span><br><span class="line">curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, <span class="number">0</span>);</span><br><span class="line">curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">curl_easy_setopt(curl, CURLOPT_WRITEDATA, access_token_result);</span><br><span class="line">curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, access_token_callback);</span><br><span class="line">result_code = curl_easy_perform(curl);</span><br><span class="line"><span class="keyword">if</span> (result_code != CURLE_OK) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;curl_easy_perform() failed: %s\n&quot;</span>,</span><br><span class="line">curl_easy_strerror(result_code));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf(&quot;access_token_result:%s\n&quot;,access_token_result);</span></span><br><span class="line"><span class="built_in">strcpy</span>(access_token,access_token_result);</span><br><span class="line">curl_easy_cleanup(curl);</span><br><span class="line">error_code = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;curl_easy_init() failed.&quot;</span>);</span><br><span class="line">error_code = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> error_code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">identify_callback</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, <span class="type">void</span> *stream)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取到的body存放在ptr中，先将其转换为string格式</span></span><br><span class="line"><span class="type">char</span> *buf = (<span class="type">char</span> *)<span class="built_in">malloc</span> (size * nmemb + <span class="number">8</span> );</span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="string">&#x27;\0&#x27;</span>,size * nmemb + <span class="number">8</span>);</span><br><span class="line"><span class="built_in">strncpy</span>(buf, ptr, size * nmemb);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *identify_result = (<span class="type">char</span> *)stream;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strncpy</span>(identify_result,buf,<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//printf(&quot;stream:%f\n&quot;,*identify_result);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> size * nmemb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 人脸对比</span></span><br><span class="line"><span class="comment"> * @return 调用成功返回0，发生错误返回其他错误码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">post_identify</span><span class="params">(<span class="type">char</span> *identify, <span class="type">char</span> *access_token, <span class="type">char</span> *image_name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//std::string url = request_url + &quot;?access_token=&quot; + access_token;</span></span><br><span class="line"><span class="type">char</span> url[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">char</span> request_url[] = <span class="string">&quot;https://aip.baidubce.com/rest/2.0/image-classify/v1/classify/ingredient&quot;</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(url,<span class="string">&quot;%s?access_token=%s&quot;</span>,request_url,access_token);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> image[] = <span class="string">&quot;image&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *image_base64 = getbase64(image_name);</span><br><span class="line">    <span class="keyword">if</span> (!image_base64) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to encode image.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *params = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(image) + <span class="built_in">strlen</span>(image_base64) + <span class="number">128</span> );</span><br><span class="line">    <span class="keyword">if</span> (!params) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Memory allocation failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(image_base64);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">sprintf</span>(params,<span class="string">&quot;%s=%s&quot;</span>,image,image_base64);</span><br><span class="line"><span class="comment">// printf(&quot;param : %s\n&quot;,params);</span></span><br><span class="line"></span><br><span class="line">    CURL *curl = <span class="literal">NULL</span>;</span><br><span class="line">    CURLcode result_code;</span><br><span class="line">    <span class="type">int</span> is_success;</span><br><span class="line">    curl = curl_easy_init();</span><br><span class="line">    <span class="type">char</span> identify_result[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (curl) &#123;</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_URL, url);</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_POST, <span class="number">1</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">curl_slist</span> *<span class="title">headers</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        headers = curl_slist_append(headers, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, params);</span><br><span class="line">        curl_easy_setopt(curl, CURLOPT_WRITEDATA, identify_result);</span><br><span class="line">curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, identify_callback);</span><br><span class="line">result_code = curl_easy_perform(curl);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(image_base64);</span><br><span class="line"><span class="built_in">free</span>(params);</span><br><span class="line">        <span class="keyword">if</span> (result_code != CURLE_OK) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;curl_easy_perform() failed: %s\n&quot;</span>,</span><br><span class="line">                    curl_easy_strerror(result_code));</span><br><span class="line">            is_success = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> is_success;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(identify,identify_result);</span><br><span class="line">        curl_easy_cleanup(curl);</span><br><span class="line">        is_success = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;curl_easy_init() failed.&quot;</span>);</span><br><span class="line">        is_success = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is_success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">parse_json</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* json_data)</span> &#123;</span><br><span class="line">    <span class="comment">// 解析 JSON 数据</span></span><br><span class="line">    cJSON *root = cJSON_Parse(json_data);</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error parsing JSON data\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取 &quot;result_num&quot;</span></span><br><span class="line">    cJSON *result_num = cJSON_GetObjectItem(root, <span class="string">&quot;result_num&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (result_num) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;result_num: %d\n&quot;</span>, result_num-&gt;valueint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取 &quot;log_id&quot;</span></span><br><span class="line">    cJSON *log_id = cJSON_GetObjectItem(root, <span class="string">&quot;log_id&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (log_id) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;log_id: %.0f\n&quot;</span>, log_id-&gt;valuedouble);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取 &quot;result&quot; 数组</span></span><br><span class="line">    cJSON *result = cJSON_GetObjectItem(root, <span class="string">&quot;result&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="type">int</span> result_count = cJSON_GetArraySize(result);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; result_count; i++) &#123;</span><br><span class="line">            cJSON *item = cJSON_GetArrayItem(result, i);</span><br><span class="line">            <span class="keyword">if</span> (item) &#123;</span><br><span class="line">                cJSON *score = cJSON_GetObjectItem(item, <span class="string">&quot;score&quot;</span>);</span><br><span class="line">                cJSON *name = cJSON_GetObjectItem(item, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (score &amp;&amp; name) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Item %d:\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;  Name: %s\n&quot;</span>, name-&gt;valuestring);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;  Score: %f\n&quot;</span>, score-&gt;valuedouble);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理 JSON 对象</span></span><br><span class="line">    cJSON_Delete(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_first_item</span><span class="params">(<span class="type">char</span> *item_name, <span class="type">double</span> *item_score, <span class="type">char</span> *json_data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 解析 JSON 数据</span></span><br><span class="line">    cJSON *root = cJSON_Parse(json_data);</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error parsing JSON data\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取 &quot;result&quot; 数组</span></span><br><span class="line">    cJSON *result = cJSON_GetObjectItem(root, <span class="string">&quot;result&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span> (result)&#123;</span><br><span class="line">cJSON *item = cJSON_GetArrayItem(result, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (item) &#123;</span><br><span class="line">cJSON *score = cJSON_GetObjectItem(item, <span class="string">&quot;score&quot;</span>);</span><br><span class="line">cJSON *name = cJSON_GetObjectItem(item, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (score &amp;&amp; name) &#123;</span><br><span class="line"><span class="comment">// printf(&quot;  Name: %s\n&quot;, name-&gt;valuestring);</span></span><br><span class="line"><span class="comment">// printf(&quot;  Score: %f\n&quot;, score-&gt;valuedouble);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(item_name,name-&gt;valuestring);</span><br><span class="line">*item_score = score-&gt;valuedouble;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重量称量"><a href="#重量称量" class="headerlink" title="重量称量"></a>重量称量</h2><p>通过ADC驱动，读取称量传感器的测量值，计算得到相应的重量。</p><h3 id="ADC驱动"><a href="#ADC驱动" class="headerlink" title="ADC驱动"></a>ADC驱动</h3><h3 id="重量测量"><a href="#重量测量" class="headerlink" title="重量测量"></a>重量测量</h3><h2 id="界面显示"><a href="#界面显示" class="headerlink" title="界面显示"></a>界面显示</h2><p>屏幕界面包含两部分内容，一个是摄像头拍摄的图片显示，另一个是提示信息。这里使用LVGL库进行UI界面设计和显示。</p><p>已大致实现，未记录。</p><h1 id="测试与调试"><a href="#测试与调试" class="headerlink" title="测试与调试"></a>测试与调试</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><h2 id="系统移植相关"><a href="#系统移植相关" class="headerlink" title="系统移植相关"></a>系统移植相关</h2><h3 id="1、configure-error-you-should-not-run-configure-as-root"><a href="#1、configure-error-you-should-not-run-configure-as-root" class="headerlink" title="1、configure: error: you should not run configure as root"></a>1、configure: error: you should not run configure as root</h3><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240324172525763.png" class="" title="image-20240324172525763"><p>按提示设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 解决：修改顶层Makefile ，添加环境变量</span><br><span class="line">vi Makefile</span><br><span class="line"><span class="built_in">export</span> FORCE_UNSAFE_CONFIGURE=1</span><br></pre></td></tr></table></figure><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240324175143896.png" class="" title="image-20240324175143896"><h3 id="2、内核启动后在“Starting-network-OK”和”random-nonblocking-pool-is-initialized”之间卡很久才进入系统"><a href="#2、内核启动后在“Starting-network-OK”和”random-nonblocking-pool-is-initialized”之间卡很久才进入系统" class="headerlink" title="2、内核启动后在“Starting network:OK”和”random:nonblocking pool is initialized”之间卡很久才进入系统"></a>2、内核启动后在“Starting network:OK”和”random:nonblocking pool is initialized”之间卡很久才进入系统</h3><p>i.MX6ULL平台，buildroot 创建的 sshd ，在调试过程中出现sshd在开机自启动的过程中卡顿现象（等待时间较久），观察打印信息发现，sshd一定等待直到以下代码出现才能正常启动。</p><blockquote><p>random:nonblocking pool is initialized</p></blockquote><p>在此过程中，nonblocking pool 的初始化要 2 分钟，而启动sshd并不需要等待nonblockingpool 初始化。</p><style>.wcffxrcxecfu{zoom:50%;}</style><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240324185710244.png" class="wcffxrcxecfu" alt="image-20240324185710244"><p>解决参考：<a href="https://zhuanlan.zhihu.com/p/665567369%EF%BC%8C%E4%BF%AE%E6%94%B9%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6%E2%80%9C/drivers/char/random.c%E2%80%9D">https://zhuanlan.zhihu.com/p/665567369，修改内核文件“/drivers/char/random.c”</a> 约 900 行处的代码：</p><style>.kzjsdipwcwfq{zoom:50%;}</style><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240324192036938.png" class="kzjsdipwcwfq" alt="image-20240324192036938"><p>其他方法，可以尝试换个高版本的buildroot。</p><p>3、Could not load host key: &#x2F;etc&#x2F;ssh&#x2F;ssh_host_rsa_key</p><style>.totueadexwme{zoom:67%;}</style><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240901194514230.png" class="totueadexwme" alt="image-20240901194514230"><h2 id="驱动相关"><a href="#驱动相关" class="headerlink" title="驱动相关"></a>驱动相关</h2><h2 id="应用开发相关"><a href="#应用开发相关" class="headerlink" title="应用开发相关"></a>应用开发相关</h2><p>1、编译报错：has incomplete type 不完全的类型</p><p>在包含 linux&#x2F;videodev2.h 时 timestamp 报错，出现不完全类型field ‘xxx’ has incomplete type。可能是由于出现与系统重复的头文件导致，也有可能是编译标准的选择。</p><p>在确定不是头文件重复后，可在Makefile的编译参数中，修改<code>-std=c99</code>为<code>-std=gnu99</code>：</p><img src="LVGL学习记录/image-20240328200147084.png" alt="image-20240328200147084" style="zoom:67%;" /><p>2、编译报错：undefined reference to &#96;pthread_create’问题</p><p>pthread不是Linux下的默认的库，也就是在链接的时候，无法找到phread库中哥函数的入口地址，于是链接会失败。</p><p>解决：在gcc编译的时候，附加要加 -pthread参数即可解决。这里在Makefile中的LDFLAGS目标添加编译参数<code>-pthread</code>：</p><style>.qnckqnqbxjqk{zoom:50%;}</style><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240328201958201.png" class="qnckqnqbxjqk" alt="image-20240328201958201"><p>3、Segmentation Fault问题</p><p>4、arm-linux-gnueabihf-gcc: error: unrecognized command line option ‘-m64’</p><style>.ovhykmwhywui{zoom:67%;}</style><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240901154727515.png" class="ovhykmwhywui" alt="image-20240901154727515"><p>解决：打开Makefile，去掉-m64：</p><style>.aqdjqutflxwi{zoom:67%;}</style><img src="/2024/03/23/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%A1%B9%E7%9B%AE-%E5%9F%BA%E4%BA%8Eimx6ull%E5%92%8COpenCV%E7%9A%84%E6%B0%B4%E6%9E%9C%E8%AF%86%E5%88%AB%E4%B8%8E%E7%A7%B0%E9%87%8D%E7%B3%BB%E7%BB%9F/image-20240901154829029.png" class="aqdjqutflxwi" alt="image-20240901154829029">]]></content>
      
      
      
        <tags>
            
            <tag> 嵌入式项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储器区别(ROM、RAM、FLASH、DDR等)</title>
      <link href="/2024/03/18/%E5%AD%98%E5%82%A8%E5%99%A8%E5%8C%BA%E5%88%AB-ROM%E3%80%81RAM%E3%80%81FLASH%E3%80%81DDR%E7%AD%89/"/>
      <url>/2024/03/18/%E5%AD%98%E5%82%A8%E5%99%A8%E5%8C%BA%E5%88%AB-ROM%E3%80%81RAM%E3%80%81FLASH%E3%80%81DDR%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<h2 id="各种存储器分类"><a href="#各种存储器分类" class="headerlink" title="各种存储器分类"></a>各种存储器分类</h2><img src="/2024/03/18/%E5%AD%98%E5%82%A8%E5%99%A8%E5%8C%BA%E5%88%AB-ROM%E3%80%81RAM%E3%80%81FLASH%E3%80%81DDR%E7%AD%89/image-20240318200639931.png" class="" title="image-20240318200639931">]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/03/17/linux-%E5%BC%80%E5%8F%91%E6%9D%BF%E5%85%B6%E4%BB%96%E7%A7%BB%E6%A4%8D/"/>
      <url>/2024/03/17/linux-%E5%BC%80%E5%8F%91%E6%9D%BF%E5%85%B6%E4%BB%96%E7%A7%BB%E6%A4%8D/</url>
      
        <content type="html"><![CDATA[<p>title: linux-开发板其他移植<br>date: 2024-03-17 13:52:14<br>tags: linux驱动</p><h2 id="buildroot其他移植"><a href="#buildroot其他移植" class="headerlink" title="buildroot其他移植"></a>buildroot其他移植</h2><h3 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h3><h4 id="添加过程"><a href="#添加过程" class="headerlink" title="添加过程"></a>添加过程</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置</span></span><br><span class="line"><span class="built_in">cd</span> buildroot-2017.08</span><br><span class="line">make menuconfig</span><br><span class="line"><span class="comment">#编译</span></span><br><span class="line">time make</span><br></pre></td></tr></table></figure><p>添加QT配置：</p><h4 id="触摸配置"><a href="#触摸配置" class="headerlink" title="触摸配置"></a>触摸配置</h4><p>先输入 ts_test 指令测试能否正常画线，能正常画线就代表能触摸，也就不用再配置了。如果不能触摸可能是它默认指向的事件不对，需要调整，在&#x2F;etc&#x2F;profile 文件里加入以下内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// eventX X 可能取值 0 1 … </span><br><span class="line"><span class="built_in">export</span> TSLIB_TSDEVICE=/dev/input/event1</span><br><span class="line">// 若不能触摸，加入这个环境变量</span><br><span class="line"><span class="built_in">export</span> QT_QPA_FB_TSLIB=1 </span><br></pre></td></tr></table></figure><h4 id="Qt环境变量配置"><a href="#Qt环境变量配置" class="headerlink" title="Qt环境变量配置"></a>Qt环境变量配置</h4><p>在&#x2F;etc&#x2F;profile 文件里加入以下内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打开配置文件</span></span><br><span class="line">vi /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加环境变量内容： </span></span><br><span class="line"><span class="built_in">export</span> QT_QPA_PLATFORM=linuxfb</span><br></pre></td></tr></table></figure><h4 id="字库配置"><a href="#字库配置" class="headerlink" title="字库配置"></a>字库配置</h4><p>将 windows 下的（路径 C:\Windows\Fonts）下的中文字库放到新建一 个&#x2F;usr&#x2F;share&#x2F;fonts&#x2F;目录下,在&#x2F;etc&#x2F;profile 文件里加入以下内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> QT_QPA_FONTDIR= /usr/share/fonts</span><br></pre></td></tr></table></figure><p>使能 Qt 运行环境变量</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h5 id="测试-Qt-能否正常运行"><a href="#测试-Qt-能否正常运行" class="headerlink" title="测试 Qt 能否正常运行"></a>测试 Qt 能否正常运行</h5><p>查看buildroot生成根文件output&#x2F;build&#x2F;qt5base-5.9.1&#x2F;examples&#x2F;widgets&#x2F;widgets目录下的示例文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> output/build/qt5base-5.9.1/examples/widgets/widgets</span><br><span class="line"><span class="built_in">cd</span> output/build/qt5base-5.9.1/examples/widgets/widgets</span><br></pre></td></tr></table></figure><p>随便选择一个示例进行编译，这里选择analogclock示例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入analogclock目录</span></span><br><span class="line"><span class="built_in">cd</span> analogclock</span><br><span class="line"><span class="comment">#执行qmake，生成Makefile文件，绝对路径</span></span><br><span class="line">~/buildroot-2017.08/output/build/qt5base-5.9.1/bin/qmake</span><br><span class="line"><span class="comment">#make编译</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>将生成后的analogclock文件传输至开发板运行。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先传输到宿主机，docker环境下直接传到开发板会失败</span></span><br><span class="line">scp analogclock thousand@192.168.248.130:/home/thousand</span><br><span class="line"><span class="comment">#传输到开发板</span></span><br><span class="line">scp analogclock root@192.168.123.66:/</span><br></pre></td></tr></table></figure><p>开发板运行analogclock程序，运行正常。</p><blockquote><p>若不配置qt环境变量，也可以执行“.&#x2F;analogclock -platform linuxfb”运行程序</p></blockquote><p>其他：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果添加了qt的触摸包，输入以下命令测试</span></span><br><span class="line">ts_test</span><br><span class="line"><span class="comment">#如果添加了qt的例程包，测试：</span></span><br><span class="line">/usr/lib/qt/examples/widgets/animation/animatedtiles/animatedtiles</span><br></pre></td></tr></table></figure><h3 id="alsa音频工具"><a href="#alsa音频工具" class="headerlink" title="alsa音频工具"></a>alsa音频工具</h3><p>参考：<a href="https://blog.csdn.net/Jun626/article/details/100036595">https://blog.csdn.net/Jun626/article/details/100036595</a></p><p>buildroot添加alsa：</p><img src="/2024/03/17/linux-%E5%BC%80%E5%8F%91%E6%9D%BF%E5%85%B6%E4%BB%96%E7%A7%BB%E6%A4%8D/image-20240317181202436.png" class="" title="image-20240317181202436"><p>编译，测试：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看设备</span></span><br><span class="line">arecord -l</span><br><span class="line"><span class="comment">#调节设备，音量</span></span><br><span class="line">alsamixer</span><br><span class="line"><span class="comment">#录音</span></span><br><span class="line"><span class="comment">#使能设备</span></span><br><span class="line">amixer -c 0 cset numid=12 2</span><br><span class="line"><span class="comment">#开始录音</span></span><br><span class="line">arecord -D hw:0,0 -d 3 -f S16_LE -r 16000 tmp.wav</span><br><span class="line"><span class="comment">#播放测试</span></span><br><span class="line">amixer -c 0 sset <span class="string">&#x27;Headphone&#x27;</span>,0 50% unmute</span><br><span class="line">speaker-test -twav -c2</span><br><span class="line"></span><br><span class="line"><span class="comment">#播放</span></span><br><span class="line">aplay  tmp.wav</span><br></pre></td></tr></table></figure><h3 id="tinyalsa音频工具"><a href="#tinyalsa音频工具" class="headerlink" title="tinyalsa音频工具"></a>tinyalsa音频工具</h3><p><a href="https://liefyuan.blog.csdn.net/article/details/117395026">https://liefyuan.blog.csdn.net/article/details/117395026</a></p><p>测试：</p><h3 id="mplayer视频工具"><a href="#mplayer视频工具" class="headerlink" title="mplayer视频工具"></a>mplayer视频工具</h3><p>参考过程：</p><p><a href="https://liefyuan.blog.csdn.net/article/details/117395159">https://liefyuan.blog.csdn.net/article/details/117395159</a></p><p><strong>配置buildroot的mplayer和alsa：</strong></p><img src="/2024/03/17/linux-%E5%BC%80%E5%8F%91%E6%9D%BF%E5%85%B6%E4%BB%96%E7%A7%BB%E6%A4%8D/image-20240317165231306.png" class="" title="image-20240317165231306"><img src="/2024/03/17/linux-%E5%BC%80%E5%8F%91%E6%9D%BF%E5%85%B6%E4%BB%96%E7%A7%BB%E6%A4%8D/image-20240317165915992.png" class="" title="image-20240317165915992"><p><strong>编译：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编译</span></span><br><span class="line">time make</span><br><span class="line"></span><br><span class="line"><span class="comment">#重新写入根文件系统</span></span><br></pre></td></tr></table></figure><p>测试，准备一段mp4或avi格式的视频，复制到根文件系统：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#检查是否正常运行</span></span><br><span class="line">mplayer -h</span><br><span class="line"></span><br><span class="line"><span class="comment">#调节声音大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#播放歌曲</span></span><br><span class="line">mplayer xxx.mp3</span><br><span class="line"><span class="comment">#9 ：减小音量。</span></span><br><span class="line"><span class="comment">#0：增大音量。</span></span><br><span class="line"><span class="comment">#左键：倒退 10 秒</span></span><br><span class="line"><span class="comment">#右键：快进 10 秒</span></span><br><span class="line"><span class="comment">#上键：快进 1 分钟</span></span><br><span class="line"><span class="comment">#下键：倒退 1 分钟</span></span><br><span class="line"><span class="comment">#空格：暂停和播放</span></span><br><span class="line"><span class="comment">#若 mplayer 音量已经调到最大了，但是耳机音量依旧很小的话请使用 amixer 调大声卡最大音量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#播放视频，可以加入“-fs”参数让视频居中播放。</span></span><br><span class="line">mplayer -x 800 -y 480 -zoom -framedrop xxx.mp4 -fs</span><br><span class="line"><span class="comment">#基本播放 </span></span><br><span class="line"><span class="comment">#→　　　　　前进10秒</span></span><br><span class="line"><span class="comment">#←　　　　　后退10秒</span></span><br><span class="line"><span class="comment">#↑　　　　　前进60秒</span></span><br><span class="line"><span class="comment">#↓　　　　　后退60秒</span></span><br><span class="line"><span class="comment">#PageUP　　前进10分钟</span></span><br><span class="line"><span class="comment">#PageDown　后退10分钟</span></span><br><span class="line"><span class="comment">#Enter　　　全屏开关</span></span><br><span class="line"><span class="comment">#Space　　　暂停开关</span></span><br><span class="line"><span class="comment">#Esc　　　　退出</span></span><br><span class="line"><span class="comment">#q　　　　　退出</span></span><br></pre></td></tr></table></figure><img src="/2024/03/17/linux-%E5%BC%80%E5%8F%91%E6%9D%BF%E5%85%B6%E4%BB%96%E7%A7%BB%E6%A4%8D/image-20240317175808810.png" class="" title="image-20240317175808810"><h3 id="ntp网络时间同步"><a href="#ntp网络时间同步" class="headerlink" title="ntp网络时间同步"></a>ntp网络时间同步</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>buildroot中时区设置：</p><style>.wwmnfdmpniyy{zoom:67%;}</style><p>添加ntp组件包：</p><style>.xvdhixeyrsge{zoom:67%;}</style><p><strong>编译：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time make</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根文件系统中执行配置命令</span></span><br><span class="line"><span class="built_in">cp</span> /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime</span><br><span class="line"><span class="built_in">cat</span> timezone</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试</span></span><br><span class="line">ntpdate us.pool.ntp.org</span><br><span class="line"><span class="comment">#查看当前时间</span></span><br><span class="line"><span class="built_in">date</span></span><br></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>1、编译遇到” Please port gnulib freadahead.c to your platform” 的问题：</p><p>参考： <a href="https://blog.csdn.net/m0_38018715/article/details/121866822">https://blog.csdn.net/m0_38018715/article/details/121866822</a></p><p>进入文件夹 buildroot&#x2F;output&#x2F;build&#x2F;host-m4-xxxxxx，执行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/IO_ftrylockfile/IO_EOF_SEEN/&#x27;</span> lib/*.c</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;#define _IO_IN_BACKUP 0x100&quot;</span> &gt;&gt; lib/stdio-impl.h</span><br></pre></td></tr></table></figure><p>2、应用程序获取的时间比真实时间少8小时由于时区问题，修改时区后有另外一个需要注意的地方：程序中通过 timer(NULL)获取的系统秒数会比正常时间 少 8*3600秒，编写查询时间函数时要注意自行添加。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">time_t</span> timep;</span><br><span class="line">    time (&amp;timep);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,asctime(gmtime(&amp;timep)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，程序中设置时区：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置时区为北京</span></span><br><span class="line">    setenv(<span class="string">&quot;TZ&quot;</span>, <span class="string">&quot;Asia/Shanghai&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    tzset();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前系统时间</span></span><br><span class="line">    <span class="type">time_t</span> current_time = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将时间转换为字符串格式</span></span><br><span class="line">    <span class="type">char</span>* time_string = ctime(&amp;current_time);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印当前时间</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Current system time in Beijing: %s&quot;</span>, time_string);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="curl网络工具"><a href="#curl网络工具" class="headerlink" title="curl网络工具"></a>curl网络工具</h3><p>在buildroot中包含了libcurl和openssl的库，可以使用里面的库，勾选以下选择：</p><p>编译后，移植根文件系统到开发板或者nfs挂载，可在根文件系统”&#x2F;usr&#x2F;lib”中查看其中的动态库：</p><p>不过，这时候的根文件系统中没有curl应用程序，只有动态库文件，需要分别对buildroot的“out&#x2F;build&#x2F;”目录下的openssl和libcurl源码进行编译，最后把得到的curl程序移植到根文件系统中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先将openssl和libcurl编译好的文件安装到各自源码目录下的output目录：</span></span><br><span class="line"><span class="comment">#1、安装openssl</span></span><br><span class="line"><span class="built_in">cd</span> /home/thousand/licheepi/buildroot-2017.08/output/build/openssl-1.0.2l</span><br><span class="line"><span class="built_in">mkdir</span> output</span><br><span class="line">./config no-asm shared --prefix=/home/thousand/licheepi/buildroot-2017.08/output/build/openssl-1.0.2l/output --cross-compile-prefix=arm-linux-gnueabihf-</span><br><span class="line">vi Makefile</span><br><span class="line"><span class="comment"># 删除所有的-m64</span></span><br><span class="line">make -j16</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、安装libcurl</span></span><br><span class="line"><span class="built_in">cd</span> /home/thousand/licheepi/buildroot-2017.08/output/build/libcurl-7.55.0</span><br><span class="line"><span class="built_in">mkdir</span> output</span><br><span class="line">./configure --prefix=/home/thousand/licheepi/buildroot-2017.08/output/build/libcurl-7.55.0/output --host=arm-linux-gnueabihf CC=arm-linux-gnueabihf-gcc --with-ssl=/home/thousand/licheepi/buildroot-2017.08/output/build/openssl-1.0.2l/output </span><br><span class="line">make -j16</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="comment">#若需在命令行直接使用curl，还要把得到的curl程序移植到根文件系统&quot;/usr/bin&quot;目录中,这里在开发板的linux shell界面使用scp传输：</span></span><br><span class="line">scp xxx@192.168.x.x:/home/thousand/licheepi/buildroot-2017.08/output/build/libcurl-7.55.0/output/bin/* /usr/bin</span><br><span class="line"><span class="comment">#若是nfs挂载根文件系统，则直接拷贝：cp -r output/bin/* ~/licheepi/nfs/rootfs/usr/bin</span></span><br><span class="line"><span class="comment">#测试</span></span><br><span class="line">curl -V</span><br><span class="line">curl http://www.linux.com</span><br><span class="line"></span><br><span class="line"><span class="comment">#此时curl动态库只支持http，不支持https协议，尽管前面已经配置好了openssl再编译，但得到的curl依旧不支持，还需要将output/lib中的动态库移植到根文件系统（尽管根文件系统中已有curl的动态库，但缺少了和openssl相关的部分）</span></span><br><span class="line"><span class="comment">#若是nfs挂载根文件系统，则直接拷贝：</span></span><br><span class="line"><span class="built_in">cp</span> -r xxx/libcurl-7.55.0/output/lib/* /usr/lib</span><br><span class="line"><span class="comment">#测试，此时除了缺少https的ca证书，其他一切正常</span></span><br><span class="line">curl -V</span><br><span class="line">curl -k https://www.baidu.com</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="lvgl移植"><a href="#lvgl移植" class="headerlink" title="lvgl移植"></a>lvgl移植</h2><p>参考：<br><a href="https://gitee.com/socbis/linux-lvgl">https://gitee.com/socbis/linux-lvgl</a><br><a href="https://blog.csdn.net/h451884098/article/details/120119545">https://blog.csdn.net/h451884098/article/details/120119545</a></p><h4 id="1）获取源码"><a href="#1）获取源码" class="headerlink" title="1）获取源码"></a>1）获取源码</h4><p>lvgl核心控件库: 从此处获取源码 lvgl，选择版本 Release v8.0.1.<br><a href="https://github.com/lvgl/lvgl/releases/tag/v8.0.1">https://github.com/lvgl/lvgl/releases/tag/v8.0.1</a><br>显示和触摸接口层 : 关联图形库与硬件，源码 lv_drivers，选择版本 v8.0.<br><a href="https://github.com/lvgl/lv_drivers/tree/v8.0.0">https://github.com/lvgl/lv_drivers/tree/v8.0.0</a><br>lv_demo 源码 : 源码 lv_demos, 同样选择版本 v8.0.1（非必要，这里用来验证移植效果）<br><a href="https://github.com/lvgl/lv_demos/tree/v8.0.1">https://github.com/lvgl/lv_demos/tree/v8.0.1</a></p><h4 id="2）创建文件夹并解压源码"><a href="#2）创建文件夹并解压源码" class="headerlink" title="2）创建文件夹并解压源码"></a>2）创建文件夹并解压源码</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> lvgl_linux</span><br><span class="line"><span class="built_in">cd</span> lvgl_linux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar xvf lvgl-8.0.1.tar.gz</span><br><span class="line">unzip lv_drivers-release-v8.0.zip</span><br><span class="line">unzip lv_demos-release-v8.0.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名解压后的文件夹</span></span><br><span class="line"><span class="built_in">mv</span> lvgl-8.0.1 lvgl</span><br><span class="line"><span class="built_in">mv</span> lv_drivers-release-v8.0 lv_drivers</span><br><span class="line"><span class="built_in">mv</span> lv_demos-release-v8.0 lv_demos</span><br><span class="line"></span><br><span class="line"><span class="comment"># delete zip tar</span></span><br><span class="line"><span class="built_in">rm</span> lv_drivers-release-v8.0.zip lv_demos-release-v8.0.zip lvgl-8.0.1.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line">lv_demos  lv_drivers  lvgl</span><br></pre></td></tr></table></figure><h4 id="3）修改配置文件"><a href="#3）修改配置文件" class="headerlink" title="3）修改配置文件"></a>3）修改配置文件</h4><ul><li><p>核心库配置文件 : lv_conf.h</p></li><li><p>驱动配置文件 : lv_drv_conf.h</p></li><li><p>demo配置文件 : lv_demo_conf.h</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于配置模板创建</span></span><br><span class="line"><span class="built_in">cp</span> lvgl/lv_conf_template.h lv_conf.h</span><br><span class="line"><span class="built_in">cp</span> lv_drivers/lv_drv_conf_template.h lv_drv_conf.h</span><br><span class="line"><span class="built_in">cp</span> lv_demos/lv_demo_conf_template.h lv_demo_conf.h</span><br><span class="line"></span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line">lv_conf.h  lv_demo_conf.h  lv_demos  lv_drivers  lv_drv_conf.h  lvgl</span><br></pre></td></tr></table></figure><p><strong>修改：</strong>使能，将3个文件开头的 “if 0” 改为 “if 1” &#x2F;<em>Set it to “1” to enable content</em>&#x2F;：</p></li><li><p>修改 lv_drv_conf.h：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  define USE_FBDEV           1</span></span><br><span class="line"><span class="comment">#  define USE_EVDEV           1</span></span><br></pre></td></tr></table></figure></li><li><p>修改 lv_demo_conf.h :</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define LV_USE_DEMO_WIDGETS        1</span></span><br></pre></td></tr></table></figure></li><li><p>修改 lv_conf.h :</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern uint32_t custom_tick_get(void);</span><br></pre></td></tr></table></figure><p><strong>配置 Tick interface ：</strong></p></li></ul><p><strong>使能 12，16 号字体:</strong></p><p><strong>设置堆大小:</strong></p><p>使用 lvgl 内建内存分配方案: 配置堆大小，实测 2KB 无法启动demo，给 2MB</p><p>使用 linux 系统内存分配：使能宏 define LV_MEM_CUSTOM 1 即可</p><h4 id="4）编写main程序和Makefile"><a href="#4）编写main程序和Makefile" class="headerlink" title="4）编写main程序和Makefile"></a>4）编写main程序和Makefile</h4><p>main.c 参考自: <a href="https://github.com/lvgl/lv_port_linux_frame_buffer/blob/release/v8.2/main.c">https://github.com/lvgl/lv_port_linux_frame_buffer/blob/release/v8.2/main.c</a></p><p>修改：</p><p>Makefile 参考自:<a href="https://github.com/lvgl/lv_port_linux_frame_buffer/blob/release/v8.2/Makefile">https://github.com/lvgl/lv_port_linux_frame_buffer/blob/release/v8.2/Makefile</a></p><p>Makefile 做如下修改:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CC = arm-linux-gnueabihf-gcc</span><br><span class="line"></span><br><span class="line">include $(LVGL_DIR)/lv_demos/lv_demo.mk</span><br><span class="line"></span><br><span class="line"><span class="comment"># CSRCS +=$(LVGL_DIR)/mouse_cursor_icon.c</span></span><br></pre></td></tr></table></figure><h4 id="5）编译"><a href="#5）编译" class="headerlink" title="5）编译"></a>5）编译</h4><p>make 生成 .&#x2F;demo：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p><img src="/picture/Pasted%20image%2020230713114201.png"></p><h4 id="6-问题"><a href="#6-问题" class="headerlink" title="6) 问题"></a>6) 问题</h4><p>使用lv_port_linux_frame_buffer下对应的lvgl和lvgl_driver版本（v8.2版）编译后的demo，加载到开发板运行出现以下错误，暂不知原因：</p><p>解决参考： <a href="https://gitee.com/already_use/lvgl_linux_arm">https://gitee.com/already_use/lvgl_linux_arm</a></p><p>修改“lvgl_linux_arm&#x2F;lv_port_linux_frame_buffer&#x2F;lv_drivers&#x2F;display&#x2F;<strong>fbdev.c</strong>”文件，屏蔽代码：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux-全志V3s移植uboot kernel rootfile记录</title>
      <link href="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="环境及材料准备"><a href="#环境及材料准备" class="headerlink" title="环境及材料准备"></a>环境及材料准备</h2><h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><p>安装好相应的ubuntu系统环境，这里为ubuntu 20.04系统：</p><style>.klxqbhryoklr{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240314154622986.png" class="klxqbhryoklr" alt="image-20240314154622986"><h3 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h3><p>开发板为licheepi的V3s开发板，资料如下：</p><p>链接：<a href="https://pan.baidu.com/s/1iXh4KYYlQPyKgEGASLdnNA">https://pan.baidu.com/s/1iXh4KYYlQPyKgEGASLdnNA</a> </p><p>提取码：byga</p><h2 id="交叉编译器安装"><a href="#交叉编译器安装" class="headerlink" title="交叉编译器安装"></a>交叉编译器安装</h2><p>下载材料中的交叉编译器”gcc-linaro-6.3.1-2017.02-x86_64_arm-linux-gnueabihf.tar.xz“到ubuntu系统中，解压并添加环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建文件夹V3s</span></span><br><span class="line">cd ~</span><br><span class="line">sudo mkdir V3s</span><br><span class="line">mv gcc-linaro-6.3.1-2017.02-x86_64_arm-linux-gnueabihf.tar.xz V3s</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解压</span></span><br><span class="line">cd V3s</span><br><span class="line">sudo tar -vxf gcc-linaro-6.3.1-2017.02-x86_64_arm-linux-gnueabihf.tar.xz</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入环境变量配置文件</span></span><br><span class="line">sudo vim ~/.bashrc#或者sudo vim /etc/profile </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加环境变量，在文件最后添加</span> </span><br><span class="line">export PATH=$PATH:~/V3s/gcc-linaro-6.3.1-2017.02-x86_64_arm-linux-gnueabihf/bin</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">更新系统环境变量：</span></span><br><span class="line">sudo source /etc/profile#或者sudo source ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="uboot编译"><a href="#uboot编译" class="headerlink" title="uboot编译"></a>uboot编译</h2><p>下载材料中的uboot源码”u-boot-v3s-current.zip”到系统中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解压</span></span><br><span class="line"><span class="built_in">mv</span> u-boot-v3s-current.zip ~/V3s</span><br><span class="line"><span class="built_in">cd</span> ~/V3s</span><br><span class="line">unzip u-boot-v3s-current.zip</span><br><span class="line"><span class="built_in">mv</span> u-boot-v3s-current uboot</span><br><span class="line"><span class="comment">#选择配置文件，配置uboot</span></span><br><span class="line"><span class="built_in">cd</span> uboot</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- LicheePi_Zero_defconfig</span><br><span class="line"><span class="comment">#或者选择带显示功能的配置文件</span></span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- LicheePi_Zero_800x480LCD_defconfig </span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- LicheePi_Zero_480x272LCD_defconfig</span><br><span class="line"><span class="comment">#添加其他uboot配置，先安装ncurses</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install build-essential</span><br><span class="line">sudo apt install libncurses5-dev</span><br><span class="line">make ARCH=arm menuconfig </span><br><span class="line"><span class="comment">#进入配置界面后，添加网络功能，如下图：</span></span><br><span class="line"><span class="comment">#添加开发板网口网络支持</span></span><br></pre></td></tr></table></figure><style>.xtrvhwhdblvb{zoom:67%;}</style><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译</span></span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或者计算编译时间，并输入编译信息到build.log日志文件中</span></span><br><span class="line">time make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- 2&gt;&amp;1 | tee build.log</span><br></pre></td></tr></table></figure><p>成功得到”u-boot-sunxi-with-spl.bin”编译文件：</p><style>.nouorkklfkit{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240314185402052.png" class="nouorkklfkit" alt="image-20240314185402052"><h2 id="kernel编译"><a href="#kernel编译" class="headerlink" title="kernel编译"></a>kernel编译</h2><p>下载“linux-zero-5.2.y.zip”文件到系统中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解压</span></span><br><span class="line"><span class="built_in">mv</span> linux-zero-5.2.y.zip V3s</span><br><span class="line"><span class="built_in">cd</span> ~/V3s</span><br><span class="line">unzip linux-zero-5.2.y.zip</span><br><span class="line"><span class="comment">#选择配置文件，配置kernel,lichee的linux配置文件放在linux/arch/arm/configs文件命令下</span></span><br><span class="line"><span class="built_in">cd</span> linux-zero-5.2.y</span><br><span class="line">make ARCH=arm licheepi_zero_defconfig</span><br><span class="line"><span class="comment">#添加其他配置</span></span><br><span class="line">make ARCH=arm menuconfig </span><br><span class="line"><span class="comment">#使能linux logo显示，如图</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><style>.rmxlsaftricw{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240314190755906.png" class="rmxlsaftricw" alt="image-20240314190755906"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j8 </span><br><span class="line"><span class="comment">#“-jx”的x为CPU的核心个数，可以查看当前CPU情况进行选择，也可以删掉-jx，但编译速度慢</span></span><br><span class="line"><span class="comment">#或者使用time统计编译时间</span></span><br><span class="line">time make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j8</span><br></pre></td></tr></table></figure><p>编译得到“zImage”镜像文件和”sun8i-v3s-licheepi-zero.dtb”设备树文件：</p><style>.khlnyqtyrerq{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240314191134076.png" class="khlnyqtyrerq" alt="image-20240314191134076"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&quot;sun8i-v3s-licheepi-zero.dtb&quot;设备树文件目录：</span></span><br><span class="line"><span class="built_in">cd</span> ~/V3s/linux-zero-5.2.y</span><br><span class="line"><span class="built_in">ls</span> <span class="built_in">arch</span>/arm/boot/dts/</span><br><span class="line"><span class="comment">#如图：</span></span><br></pre></td></tr></table></figure><style>.ablmgtrxvsbo{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240314194701830.png" class="ablmgtrxvsbo" alt="image-20240314194701830"><h2 id="rootfs制作"><a href="#rootfs制作" class="headerlink" title="rootfs制作"></a>rootfs制作</h2><p>下载”buildroot-2017.08.tar.gz“文件到系统中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解压</span></span><br><span class="line"><span class="built_in">mv</span> buildroot-2017.08.tar.gz ~/V3s</span><br><span class="line"><span class="built_in">cd</span> ~/V3s</span><br><span class="line">tar xvf buildroot-2017.08.tar.gz</span><br><span class="line"><span class="comment">#配置</span></span><br><span class="line"><span class="built_in">cd</span> buildroot-2017.08</span><br><span class="line">make menuconfig</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>依次配置“Target options”：</p><style>.xvnsqpkiothj{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240314191929631.png" class="xvnsqpkiothj" alt="image-20240314191929631"><p>配置“Toolchain”编译工具链，注意交叉编译器的位置为“~&#x2F;V3s&#x2F;gcc-linaro-6.3.1-2017.02-x86_64_arm-linux-gnueabihf”，和图片里面不太一样：</p><style>.wqwikvxlixxa{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240314192213909.png" class="wqwikvxlixxa" alt="image-20240314192213909"><style>.nxfjrzwyumoh{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240314192357815.png" class="nxfjrzwyumoh" alt="image-20240314192357815"><style>.mpkfkjysixcx{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240314192423631.png" class="mpkfkjysixcx" alt="image-20240314192423631"><p>系统信息设置，设置系统主机名字、系统横幅信息、root管理员用户密码、时区选择等：</p><style>.yxpbghpscklg{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240314192632071.png" class="yxpbghpscklg" alt="image-20240314192632071"><style>.vtjwuhfqkfjm{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240314192822270.png" class="vtjwuhfqkfjm" alt="image-20240314192822270"><style>.jwbpdfssegfi{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240314193128271.png" class="jwbpdfssegfi" alt="image-20240314193128271"><p>添加ssh功能方便后续进行“网络根文件系统启动”，如图：</p><style>.urvvdgmtygtl{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240314193244752.png" class="urvvdgmtygtl" alt="image-20240314193244752"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编译</span></span><br><span class="line">time make</span><br></pre></td></tr></table></figure><p>编译后的rootfs位于“~&#x2F;V3s&#x2F;buildroot-2017.08&#x2F;output”，target目录中为解压后的根文件系统，images目录中为压缩好的“rootfs.tar”根文件系统压缩包：</p><style>.weharyshmvfk{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240314193643168.png" class="weharyshmvfk" alt="image-20240314193643168"><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240314193905580.png" class="" title="image-20240314193905580"><h2 id="SD卡烧录"><a href="#SD卡烧录" class="headerlink" title="SD卡烧录"></a>SD卡烧录</h2><p>准备一个tf卡，利用tf卡读卡器，插入到ubuntu中进行烧录。</p><h3 id="tf卡分区"><a href="#tf卡分区" class="headerlink" title="tf卡分区"></a>tf卡分区</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看tf卡的设备</span></span><br><span class="line">sudo fdisk -l</span><br><span class="line"><span class="comment">#若ubuntu只有一个盘且无分区(sdb1…表示sd卡中的分区)，则设备为/dev/sdb</span></span><br></pre></td></tr></table></figure><style>.kzvcggwvwhwm{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240315083836035.png" class="kzvcggwvwhwm" alt="image-20240315083836035"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入tf卡设备</span></span><br><span class="line">sudo fdisk /dev/sdb</span><br><span class="line"><span class="comment">#删除分区：d</span></span><br><span class="line"><span class="comment">#添加分区：n</span></span><br><span class="line"><span class="comment">#查看分区：p</span></span><br><span class="line"><span class="comment">#保存操作：w</span></span><br><span class="line"><span class="comment">#注：修改后，需要用w保存修改。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#按p检查是否存在原分区，有的话按d删除</span></span><br><span class="line"><span class="comment">#删除原分区后，按n新建两个分区，第一个分区大小根据zImage和设备树文件等大小，这里设置32M，起始地址为2048；第二个分区用尽剩余容量。</span></span><br><span class="line"><span class="comment">#按w写入修改后的信息，再按p检查结果是否有误，最后按q退出</span></span><br></pre></td></tr></table></figure><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240318190050342.png" class="" title="image-20240318190050342"><p><strong>原始格式：</strong></p><p>第一部分：扇区起始地址2，大小为2047个扇区，格式为原始格式，不用分区进行格式化。</p><p>uboot镜像：由于上电后，全志V3s芯片默认会从8KB偏移处拷贝uboot到内存中运行，所以从8KB处开始存放uboot；(1扇区&#x3D;512Bytes，2048扇区&#x3D;1MB，uboot镜像约为400KB，该空间足够写入该镜像。)</p><p>uboot环境变量：uboot环境变量保存在uboot环境变量分区，uboot启动时，会加载环境变量到内存中。uboot环境变量分区一般紧贴着uboot来存放，大小为32KB或者更多一点。该分区部分是独立的，可见重新烧录uboot镜像后，环境变量也不会消失。</p><p><strong>分区1：</strong></p><p>第二部分：起始扇区地址为默认2048，大小设置为32MB，分区格式为FAT，用于存放内核和设备树，内核大小一般为几MB大小；</p><p><strong>分区2：</strong></p><p>第三部分：大小为SD卡剩余的空间，分区格式为Ext3或Et4，用于存放rootfs也就是文件系统，rootfs大小根据自定义的情况而定。</p><style>.yxeqpwxqrjjs{zoom:50%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240315085023618.png" class="yxeqpwxqrjjs" alt="image-20240315085023618"><style>.jiclwgueejwx{zoom:50%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240315085113256.png" class="jiclwgueejwx" alt="image-20240315085113256"><style>.juchdooiyxof{zoom:50%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240315085248577.png" class="juchdooiyxof" alt="image-20240315085248577"><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#若分区有挂载则取消挂载</span></span><br><span class="line">sudo umount /dev/sdb1</span><br><span class="line">sudo umount /dev/sdb2</span><br><span class="line"><span class="comment">#第一个分区格式化为fat</span></span><br><span class="line">sudo mkfs.vfat /dev/sdb1</span><br><span class="line"><span class="comment">#第二个分区格式化为ext4</span></span><br><span class="line">sudo mkfs.ext4 /dev/sdb2</span><br></pre></td></tr></table></figure><style>.euuphihlgzlj{zoom: 67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240315085507681.png" class="euuphihlgzlj" alt="image-20240315085507681"><h3 id="写入uboot文件"><a href="#写入uboot文件" class="headerlink" title="写入uboot文件"></a>写入uboot文件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#写入uboot，将uboot写入到sd卡8k偏移处(必须8K偏移)。</span></span><br><span class="line"><span class="built_in">cd</span> ~/V3s/uboot</span><br><span class="line">sudo <span class="built_in">dd</span> <span class="keyword">if</span>=u-boot-sunxi-with-spl.bin of=/dev/sdb bs=1024 seek=8</span><br><span class="line">sudo <span class="built_in">sync</span></span><br></pre></td></tr></table></figure><p>注意观察写入的速率大小，若非常大有可能写入不正确：</p><style>.sviylnpzuqpy{}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240315104718853.png" class="sviylnpzuqpy" alt="image-20240315104718853"><h3 id="写入kernel文件"><a href="#写入kernel文件" class="headerlink" title="写入kernel文件"></a>写入kernel文件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#挂载第一个分区</span></span><br><span class="line"><span class="built_in">mkdir</span> /mnt/v3s</span><br><span class="line">sudo mount /dev/sdb1 /mnt/v3s</span><br><span class="line">sudo <span class="built_in">cp</span> ~/V3s/linux-zero-5.2.y/arch/arm/boot/zImage /mnt/v3s</span><br><span class="line">sudo <span class="built_in">cp</span> ~/V3s/linux-zero-5.2.y/arch/arm/boot/dts/sun8i-v3s-licheepi-zero.dtb /mnt/v3s</span><br><span class="line"><span class="comment">#或者选择这个设备树 cp sun8i-v3s-licheepi-zero-dock.dtb /mnt/v3s</span></span><br><span class="line"><span class="comment">#卸载分区并同步写入数据</span></span><br><span class="line">sudo umount /mnt/v3s</span><br><span class="line">sudo <span class="built_in">sync</span></span><br></pre></td></tr></table></figure><style>.nvskexkenpki{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240315090400690.png" class="nvskexkenpki" alt="image-20240315090400690"><h3 id="写入根文件系统"><a href="#写入根文件系统" class="headerlink" title="写入根文件系统"></a>写入根文件系统</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#挂载第二个分区</span></span><br><span class="line"><span class="built_in">cd</span> /mnt</span><br><span class="line">sudo mount /dev/sdb2 /mnt/v3s</span><br><span class="line">sudo <span class="built_in">cp</span> ~/V3s/buildroot-2017.08/output/images/rootfs.tar /mnt/v3s</span><br><span class="line">sudo tar -xf /mnt/v3s/rootfs.tar -C /mnt/v3s</span><br><span class="line">sudo umount /mnt/v3s</span><br><span class="line">sudo <span class="built_in">sync</span></span><br></pre></td></tr></table></figure><style>.tcpdvgxdydzq{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240315091724803.png" class="tcpdvgxdydzq" alt="image-20240315091724803"><h2 id="系统一般启动"><a href="#系统一般启动" class="headerlink" title="系统一般启动"></a>系统一般启动</h2><p>插入内存卡到开发板上，上电启动，利用USB转串口工具，进入uboot界面进行设置：</p><h3 id="uboot启动参数设置"><a href="#uboot启动参数设置" class="headerlink" title="uboot启动参数设置"></a>uboot启动参数设置</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一、boot启动方式</span></span><br><span class="line"><span class="comment">#1、设置boot启动方式的bootcmd加载命令</span></span><br><span class="line">setenv bootcmd <span class="string">&quot;setenv bootm_boot_mode sec;load mmc 0:1 0x41000000 zImage;load mmc 0:1 0x41800000 sun8i-v3s-licheepi-zero-dock.dtb;bootz 0x41000000 - 0x41800000;&quot;</span></span><br><span class="line"><span class="comment">#除了linux5.2版本外，其他内核不要使用以下屏幕参数，否则设备树会卡死，暂不使用，linux中已有fb0设备（有simplefb和drm两种显示模式），不用额外配置</span></span><br><span class="line">setenv bootcmd <span class="string">&quot;setenv bootm_boot_mode sec;load mmc 0:1 0x41000000 zImage;load mmc 0:1 0x41800000 sun8i-v3s-licheepi-zero-with-480x272-lcd.dtb;bootz 0x41000000 - 0x41800000;&quot;</span></span><br><span class="line">setenv bootcmd <span class="string">&quot;setenv bootm_boot_mode sec;load mmc 0:1 0x41000000 zImage;load mmc 0:1 0x41800000 sun8i-v3s-licheepi-zero-with-800x480-lcd.dtb;bootz 0x41000000 - 0x41800000;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2、设置传递给linux内核的参数</span></span><br><span class="line">setenv bootargs <span class="string">&quot;console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 earlyprintk rw  vt.global_cursor_default=0&quot;</span></span><br><span class="line"><span class="comment">#setenv bootargs &quot;console=tty0 console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 earlyprintk rw &quot;</span></span><br><span class="line"><span class="comment">#setenv bootargs &quot;console=tty0 console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 earlyprintk rw  vt.global_cursor_default=0&quot;</span></span><br><span class="line"><span class="comment">#保存</span></span><br><span class="line">saveenv</span><br><span class="line"></span><br><span class="line"><span class="comment">#3、启动</span></span><br><span class="line">boot</span><br></pre></td></tr></table></figure><style>.ikuyjcuydjof{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240315170335729.png" class="ikuyjcuydjof" alt="image-20240315170335729"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#二、bootz启动方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置传递给linux内核的参数</span></span><br><span class="line">setenv bootargs <span class="string">&quot;console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 earlyprintk rw  vt.global_cursor_default=0&quot;</span></span><br><span class="line">setenv bootargs <span class="string">&quot;console=tty0 console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 earlyprintk rw &quot;</span></span><br><span class="line"><span class="comment">#保存</span></span><br><span class="line">saveenv</span><br><span class="line"></span><br><span class="line"><span class="comment">#uboot网络配置</span></span><br><span class="line">setenv ipaddr 192.168.123.66<span class="comment">#设置开发板IP地址</span></span><br><span class="line">setenv netmask 255.255.255.0<span class="comment">#子网掩码配置</span></span><br><span class="line">setenv serverip 192.168.123.166<span class="comment">#设置tftp服务IP地址</span></span><br><span class="line">setenv gatewayip 192.168.123.1<span class="comment">#设置网关</span></span><br><span class="line">setenv ethaddr  b8:ae:1d:01:00:00<span class="comment">#设置网卡mac地址，48bit 的地址不和其他重复即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#tftp加载至内存再启动（需设置好tftp服务器，提前复制编译好的文件到tftp服务器目录）</span></span><br><span class="line"><span class="comment">#tftp DRAM地址 [[tftp服务IP地址]:文件名]</span></span><br><span class="line">tftp 0x41000000 zImage</span><br><span class="line">tftp 0x41800000 sun8i-v3s-licheepi-zero-dock.dtb</span><br><span class="line">bootz 0x41000000 - 0x41800000</span><br></pre></td></tr></table></figure><p>以上参数设置后，即可进入kernel，运行rootfs根文件系统：</p><style>.fffymvwgvvtc{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240315161711130.png" class="fffymvwgvvtc" alt="image-20240315161711130"><h3 id="linux系统配置"><a href="#linux系统配置" class="headerlink" title="linux系统配置"></a>linux系统配置</h3><h4 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h4><p>uboot启动kernel进入linux系统后，系统网络无法正常通信。</p><p>修改&#x2F;etc&#x2F;init.d&#x2F;rcS的启动文件，添加内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#vi修改文件</span></span><br><span class="line">vi /etc/init.d/rcS</span><br><span class="line"><span class="comment">#vi退出</span></span><br><span class="line"><span class="string">&quot;:wq&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 up</span><br><span class="line">ifconfig eth0 192.168.123.66 netmask 255.255.255.0</span><br><span class="line">route add default gw 192.168.123.1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;nameserver 192.168.123.1&quot;</span> &gt; /etc/resolv.conf</span><br></pre></td></tr></table></figure><style>.nmmmhlbezwxh{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240315170754689.png" class="nmmmhlbezwxh" alt="image-20240315170754689"><p>reboot命令重启后，ping <a href="http://www.baidu.com/">www.baidu.com</a> ，网络正常。</p><style>.bvaqiofdyjtd{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240315171133820.png" class="bvaqiofdyjtd" alt="image-20240315171133820"><p>若提示“ifconfig: SIOCGIFFLAGS: No such device”，则参考末尾相关问题的“无eth0设备”。</p><style>.ahpktedkfwsi{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240315162052123.png" class="ahpktedkfwsi" alt="image-20240315162052123"><h4 id="ssh配置"><a href="#ssh配置" class="headerlink" title="ssh配置"></a>ssh配置</h4><p>uboot启动kernel进入linux系统后，ssh无法正常工作。</p><p>修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件，修改对应的内容为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PermitRootLogin yes</span><br><span class="line">PermitEmptyPasswords yes</span><br></pre></td></tr></table></figure><style>.axwilsewqeph{}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240315171459580.png" class="axwilsewqeph" alt="image-20240315171459580"><style>.giriiexofeul{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240315171459580.png" class="giriiexofeul" alt="image-20240315171459580"><p>重启后，ssh连接正常。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ubuntu新建ssh_tets.txt文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ssh test.&quot;</span> &gt;&gt; ssh_test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#开发板系统重启后，利用ssh的scp进行传输文件</span></span><br><span class="line">reboot</span><br><span class="line">scp thousand@192.168.123.166:/home/thousand/ssh_test.txt ./</span><br></pre></td></tr></table></figure><style>.gnixqymcuecb{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240315172113655.png" class="gnixqymcuecb" alt="image-20240315172113655"><h2 id="系统远程启动——网络根文件系统"><a href="#系统远程启动——网络根文件系统" class="headerlink" title="系统远程启动——网络根文件系统"></a>系统远程启动——网络根文件系统</h2><p>​前面系统启动后，运行的是内存卡中第2分区中的rootfs，在平常测试中，需要添加或者修改rootfs，为了方便相关操作，可以使kernel从网络远程运行根文件系统（即本地ubuntu系统的某个文件夹目录）。</p><h3 id="TFTP和NFS工具准备"><a href="#TFTP和NFS工具准备" class="headerlink" title="TFTP和NFS工具准备"></a>TFTP和NFS工具准备</h3><h4 id="TFTP工具"><a href="#TFTP工具" class="headerlink" title="TFTP工具"></a>TFTP工具</h4><p>TFTP是一个基于UDP协议实现的用于在客户机和服务器之间进行简单文件传输的协议，适用于开销不大、不复杂的应用场合。TFTP协议专门为小文件传输而设计，只能从服务器上获取文件，或者向服务器写入文件，不能列出目录，也不能进行认证。</p><p>这里使用TFTP，主机Ubuntu为TFTP服务器，开发板为客户端，让主机和开发板进行文件传输，如kernel镜像文件传输。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装服务器、客户端和守护进程</span></span><br><span class="line">sudo apt install tftp-hpa tftpd-hpa xinetd</span><br></pre></td></tr></table></figure><p>修改&#x2F;etc&#x2F;default&#x2F;tftpd-hpa：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">vi修改</span></span><br><span class="line">mkdir /home/thousand/tftpboot</span><br><span class="line">chmod 777 /home/thousand/tftpboot</span><br><span class="line">sudo vi /etc/default/tftpd-hpa</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">vi退出</span></span><br><span class="line">&quot;:wq&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TFTP_USERNAME=&quot;tftp&quot;</span><br><span class="line">TFTP_DIRECTORY=&quot;/home/thousand/tftpboot&quot;</span><br><span class="line">TFTP_ADDRESS=&quot;:69&quot;</span><br><span class="line">TFTP_OPTIONS=&quot;-l -c -s&quot;</span><br></pre></td></tr></table></figure><style>.hjtlflrryqtm{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240315143737778.png" class="hjtlflrryqtm" alt="image-20240315143737778"><p>TFTP配置文件，使用命令建立文件，向文件中写入如下代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/xinetd.d/tftp</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">service tftp</span><br><span class="line">&#123;</span><br><span class="line">        socket_type     = dgram</span><br><span class="line">        protocol                = udp</span><br><span class="line">        wait                    = yes</span><br><span class="line">        user                    = root</span><br><span class="line">        server          = /usr/sbin/in.tftpd</span><br><span class="line">        server_args     = -s ~/tftpboot/ -c</span><br><span class="line">        disable         = no</span><br><span class="line">        per_source      = 11</span><br><span class="line">        cps                     = 100 2</span><br><span class="line">        flags                   = IPv4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><style>.dcprekptxbbb{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240315143659524.png" class="dcprekptxbbb" alt="image-20240315143659524"><p>其中，server_args设置的&#x2F;tftpboot目录是tftp服务器的目录，TFTP客户端就是从这个目录里获取文件的。使用命令”mkdir &#x2F;tftpboot”建立TFTP服务器的目录。然后设置&#x2F;tftpboot的访问权限为777。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/tftpboot</span><br><span class="line">sudo chmod 777 ~/tftpboot</span><br></pre></td></tr></table></figure><p>最后重启tftpd-hpa、xinetd服务。输入命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/xinetd reload</span><br><span class="line">sudo /etc/init.d/xinetd restart</span><br><span class="line">sudo service tftpd-hpa restart</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">先在tftpboot目录建新文件，随便输入内容</span></span><br><span class="line">echo &quot;hello,world!&quot; &gt;&gt; ~/tftpboot/tftp_test.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打开另外一个目录，输入：</span></span><br><span class="line">tftp 127.0.0.1</span><br><span class="line">get tftp_test.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入q退出tftp</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看获取的文件</span></span><br><span class="line">cat tftp_test.txt</span><br></pre></td></tr></table></figure><style>.cibvncvgelok{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240315144244971.png" class="cibvncvgelok" alt="image-20240315144244971"><h4 id="NFS工具"><a href="#NFS工具" class="headerlink" title="NFS工具"></a>NFS工具</h4><p>注意：Ubuntu版本太高，NFS版本也高，uboot的版本一般是V2，需要修改Ubuntu进行兼容，参考：<a href="https://blog.csdn.net/beetleinv/article/details/114916323">https://blog.csdn.net/beetleinv/article/details/114916323</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装nfs服务器</span></span><br><span class="line">sudo apt install nfs-kernel-server rpcbind</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看是否启动</span></span><br><span class="line">sudo systemctl status nfs-server</span><br></pre></td></tr></table></figure><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240315150115121.png" class="" title="image-20240315150115121"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建nfs分享目录</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">mkdir</span> nfs</span><br><span class="line">sudo <span class="built_in">chmod</span> 777 nfs</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置，打开配置文件</span></span><br><span class="line">sudo vi /etc/exports</span><br><span class="line"><span class="comment">#最后一行添加下面的内容</span></span><br><span class="line"><span class="comment">#这个登录root账户会出错失败：</span></span><br><span class="line"><span class="comment">#/home/thousand/nfs *(rw,sync,no_subtree_check)</span></span><br><span class="line"><span class="comment">#使用这个：</span></span><br><span class="line">/home/thousand/nfs *(rw,<span class="built_in">sync</span>,no_root_squash,no_subtree_check)</span><br><span class="line">    <span class="comment">#/home/nfs_share： 是nfs服务端的共享路径。</span></span><br><span class="line">    <span class="comment">#*：              表示所有网段都可以访问（可以指定具体的ip）。</span></span><br><span class="line">    <span class="comment">#rw：            挂接指定共享目录的客户端具有读写权限。</span></span><br><span class="line">    <span class="comment">#sync：           资料同步写入内存和硬盘.</span></span><br><span class="line">    <span class="comment">#no_root_squash：  客户机用root访问该共享文件夹时，不映射root用户。</span></span><br><span class="line">    <span class="comment">#no_subtree_check：不检查父目录的权限。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><style>.zpvoprrsidgh{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240315150238067.png" class="zpvoprrsidgh" alt="image-20240315150238067"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看共享的目录</span></span><br><span class="line">showmount -e</span><br><span class="line"><span class="comment">#重启nfs服务</span></span><br><span class="line">sudo /etc/init.d/nfs-kernel-server restart </span><br><span class="line"><span class="comment">#可以使用其他工具测试nfs是否正常</span></span><br></pre></td></tr></table></figure><style>.mplcujtakuyv{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240315150313417.png" class="mplcujtakuyv" alt="image-20240315150313417"><h3 id="kernel编译配置"><a href="#kernel编译配置" class="headerlink" title="kernel编译配置"></a>kernel编译配置</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">在内核编译配置阶段，添加以下功能配置：</span><br><span class="line">make ARCH=arm menuconfig</span><br><span class="line">1、配置网络部分，主要是使能CONFIG_IP_PNP以在2中能够看到Root file system on NFS选项</span><br><span class="line">Networking support </span><br><span class="line">Networking options </span><br><span class="line">TCP/IP networking</span><br><span class="line">IP: kernel level autoconfiguration</span><br><span class="line">[*] IP: DHCP support</span><br><span class="line">[*]IP: BOOTP support</span><br><span class="line">2、配置开启nfs服务</span><br><span class="line">File systems  ---&gt;</span><br><span class="line">Network File Systems  ---&gt;</span><br><span class="line">&lt;*&gt; NFS client support </span><br><span class="line">[*] NFS client support for NFS version 3                                  </span><br><span class="line">[*] NFS client support for the NFSv3 ACL protocol extension </span><br><span class="line">[*] NFS client support for NFS version 4 (EXPERIMENTAL) </span><br><span class="line">[*] NFS client support for NFSv4.1 (DEVELOPER ONLY) </span><br><span class="line">[*] Root file system on NFS  </span><br><span class="line"></span><br></pre></td></tr></table></figure><style>.djbskgcnhkhe{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240314214704545.png" class="djbskgcnhkhe" alt="image-20240314214704545"><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240314214908467.png" class="" title="image-20240314214908467"><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240314214908467.png" class="" title="image-20240314214908467"><h3 id="远程启动"><a href="#远程启动" class="headerlink" title="远程启动"></a>远程启动</h3><p>如果使用网络根文件系统，需要创建网络根文件系统放到nfs目录中，再修改bootargs变量。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#uboot网络配置</span></span><br><span class="line">setenv ipaddr 192.168.123.66<span class="comment">#设置开发板IP地址</span></span><br><span class="line">setenv netmask 255.255.255.0<span class="comment">#子网掩码配置</span></span><br><span class="line">setenv serverip 192.168.123.166<span class="comment">#设置tftp服务IP地址</span></span><br><span class="line">setenv gatewayip 192.168.123.1<span class="comment">#设置网关</span></span><br><span class="line">setenv ethaddr  b8:ae:1d:01:00:00<span class="comment">#设置网卡mac地址，48bit 的地址不和其他重复即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#uboot设置网络根文件系统启动参数</span></span><br><span class="line">setenv bootargs <span class="string">&#x27;console=ttyS0,115200 root=/dev/nfs nfsroot=192.168.123.166:/home/thousand/licheepi/nfs/rootfs,proto=tcp rw ip=192.168.123.66:192.168.123.166:192.168.123.1:255.255.255.0::eth0:off&#x27;</span></span><br><span class="line"><span class="comment">#setenv bootargs &#x27;console=tty0 console=ttyS0,115200 root=/dev/nfs nfsroot=192.168.123.166:/home/thousand/licheepi/nfs/rootfs,proto=tcp rw ip=192.168.123.66:192.168.123.166:192.168.123.1:255.255.255.0::eth0:off&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1、内存卡linux启动</span></span><br><span class="line">setenv bootcmd <span class="string">&quot;setenv bootm_boot_mode sec;load mmc 0:1 0x41000000 zImage;load mmc 0:1 0x41800000 sun8i-v3s-licheepi-zero-dock.dtb;bootz 0x41000000 - 0x41800000;&quot;</span></span><br><span class="line">saveenv</span><br><span class="line">boot</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、tftp网络启动</span></span><br><span class="line"><span class="comment">#ubuntu：复制内核和设备树到ubuntu的tftp目录</span></span><br><span class="line">sudo <span class="built_in">cp</span> ~/licheepi/linux-zero-5.2.y/arch/arm/boot/zImage ~/tftpboot/</span><br><span class="line">sudo <span class="built_in">cp</span> ~/licheepi/linux-zero-5.2.y/arch/arm/boot/dts/sun8i-v3s-licheepi-zero.dtb ~/tftpboot/</span><br><span class="line"><span class="comment">#uboot加载设备树到内存中</span></span><br><span class="line">tftp 41800000 sun8i-v3s-licheepi-zero.dtb</span><br><span class="line"><span class="comment">#tftp 41800000 sun8i-v3s-licheepi-zero-with-480x272-1cd.dtb</span></span><br><span class="line"><span class="comment">#tftp 41800000 sun8i-v3s-licheepi-zero-with-800x480-1cd.dtb</span></span><br><span class="line"><span class="comment">#uboot加载内核到内存中</span></span><br><span class="line">tftp 41000000 zImage</span><br><span class="line"><span class="comment">#启动</span></span><br><span class="line">bootz 0x41000000 - 0x41800000</span><br></pre></td></tr></table></figure><style>.vevcmqekwcye{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240315144915801.png" class="vevcmqekwcye" alt="image-20240315144915801"><style>.wpxrptwwnlbj{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240315145007842.png" class="wpxrptwwnlbj" alt="image-20240315145007842"><style>.cdbibmbmebyo{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240315145236314.png" class="cdbibmbmebyo" alt="image-20240315145236314"><h2 id="相关问题解决"><a href="#相关问题解决" class="headerlink" title="相关问题解决"></a>相关问题解决</h2><h3 id="uboot相关"><a href="#uboot相关" class="headerlink" title="uboot相关"></a>uboot相关</h3><h4 id="DTC设备树编译工具版本太旧"><a href="#DTC设备树编译工具版本太旧" class="headerlink" title="DTC设备树编译工具版本太旧"></a>DTC设备树编译工具版本太旧</h4><p>报错”Your dtc is too old,please upgrade to dtc 1.4 or newer“，设备树编译器版本过旧，需更新。</p><style>.xhgonvelxbqw{zoom:67%;}</style><p>更新命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install device-tree-compiler</span><br></pre></td></tr></table></figure><style>.gqjbmnvqtjie{zoom:67%;}</style><h4 id="缺少python解析器"><a href="#缺少python解析器" class="headerlink" title="缺少python解析器"></a>缺少python解析器</h4><p>报错”.&#x2F;tools&#x2F;binman&#x2F;binman:not found“，没有python解析器</p><style>.sfkrjfqlfnil{zoom:67%;}</style><p>安装python：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python</span><br></pre></td></tr></table></figure><h4 id="缺少bc工具"><a href="#缺少bc工具" class="headerlink" title="缺少bc工具"></a>缺少bc工具</h4><p>报错”bc: not found“，缺少bc工具</p><style>.yhnoyrvpzmnw{zoom:67%;}</style><p>安装bc：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install bc</span><br></pre></td></tr></table></figure><p>正常输出：</p><style>.zszbtqbtmbef{zoom:67%;}</style><h3 id="linux内核相关"><a href="#linux内核相关" class="headerlink" title="linux内核相关"></a>linux内核相关</h3><h4 id="缺少相关库文件"><a href="#缺少相关库文件" class="headerlink" title="缺少相关库文件"></a>缺少相关库文件</h4><p>报错”flex: not found“，缺少相关库文件</p><style>.ioeqvgmbecwr{zoom:67%;}</style><p>安装相关库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install flex</span><br><span class="line">sudo apt-get install bison</span><br></pre></td></tr></table></figure><p>报错” fatal error: openssl&#x2F;bio.h: No such file or directory“,缺少文件</p><style>.acwukmsqbofh{zoom:67%;}</style><p>添加文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libssl-dev</span><br></pre></td></tr></table></figure><h3 id="根文件系统相关"><a href="#根文件系统相关" class="headerlink" title="根文件系统相关"></a>根文件系统相关</h3><h4 id="编译ssh出错"><a href="#编译ssh出错" class="headerlink" title="编译ssh出错"></a>编译ssh出错</h4><style>.snhfudpohafw{zoom:67%;}</style><p>解决：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> buildroot-2017.08</span><br><span class="line"><span class="built_in">cd</span> output/build/host-m4-1.4.18/</span><br><span class="line">sed -i <span class="string">&#x27;s/IO_ftrylockfile/IO_EOF_SEEN/&#x27;</span> lib/*.c</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;#define _IO_IN_BACKUP 0x100&quot;</span> &gt;&gt; lib/stdio-impl.h</span><br><span class="line"></span><br><span class="line">make</span><br></pre></td></tr></table></figure><h4 id="登录nfs挂载的根文件系统出错"><a href="#登录nfs挂载的根文件系统出错" class="headerlink" title="登录nfs挂载的根文件系统出错"></a>登录nfs挂载的根文件系统出错</h4><p>问题：“nfs挂载rootfs login: root Login incorrect”</p><style>.tjvqgyoseksg{zoom:67%;}</style><p>主机配置nfs服务器需添加“no_root_squash”参数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置，打开配置文件</span></span><br><span class="line">sudo vi /etc/exports</span><br><span class="line"><span class="comment">#最后一行添加下面的内容</span></span><br><span class="line"><span class="comment">##/home/thousand/nfs *(rw,sync,no_subtree_check)</span></span><br><span class="line">/home/thousand/nfs *(rw,<span class="built_in">sync</span>,no_root_squash,no_subtree_check)</span><br><span class="line"><span class="comment">#重启nfs服务</span></span><br><span class="line">sudo /etc/init.d/nfs-kernel-server restart </span><br></pre></td></tr></table></figure><h3 id="系统启动阶段相关"><a href="#系统启动阶段相关" class="headerlink" title="系统启动阶段相关"></a>系统启动阶段相关</h3><h4 id="uboot无法tftp下载"><a href="#uboot无法tftp下载" class="headerlink" title="uboot无法tftp下载"></a>uboot无法tftp下载</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">情况如下：</span><br><span class="line">=&gt; tftp 80800000 zImage</span><br><span class="line">Using FEC1 device</span><br><span class="line">TFTP from server 192.168.3.166; our IP address is 192.168.3.188</span><br><span class="line">Filename &#x27;zImage&#x27;.</span><br><span class="line">Load address: 0x80800000</span><br><span class="line">Loading: T T T T T T T T T T</span><br><span class="line">Retry count exceeded; starting again</span><br></pre></td></tr></table></figure><p><strong>解决：</strong>关闭Ubuntu的防火墙，命令如下：sudo ufw disable。</p><h4 id="屏幕无输出显示"><a href="#屏幕无输出显示" class="headerlink" title="屏幕无输出显示"></a>屏幕无输出显示</h4><p><strong>uboot启动阶段无显示</strong></p><p>这个是因为编译时，没有选着对应屏幕驱动的配置，比如</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编译Uboot时选择了LicheePi_Zero_defconfig，该配置没有适配屏幕</span></span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- LicheePi_Zero_defconfig</span><br></pre></td></tr></table></figure><p>lichee的uboot配置文件放在u-boot&#x2F;confgs文件目录下面，名称为</p><ul><li>LicheePi_Zero_480x272LCD_defconfig</li><li>LicheePi_Zero_800x480LCD_defconfig</li><li>LicheePi_Zero_defconfig<br>改用LicheePi_Zero_800x480LCD_defconfig配置后，uboot启动屏幕正常输出。</li></ul><p><strong>内核启动阶段无显示</strong></p><p>传递给Linux的<strong>bootargs参数</strong>若如下设置，会导致没有选择输出到屏幕中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs <span class="string">&quot;console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 earlyprintk rw  vt.global_cursor_default=0&quot;</span></span><br></pre></td></tr></table></figure><p>修改成如下参数，屏幕正常输出信息（vt.global_cursor_default&#x3D;0表示取消光标闪烁）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs <span class="string">&quot;console=ttyS0,115200 panic=5 console=tty0 rootwait root=/dev/mmcblk0p2 earlyprintk rw  vt.global_cursor_default=0&quot;</span></span><br></pre></td></tr></table></figure><p>不过，此时<strong>串口终端无法看到登录项，也不能输入</strong>，无法登录系统；但连接开发板的lcd屏幕上可以看到登录项，或许可以插入键盘到开发板上输入登录信息。</p><style>.xibaguiguhrj{zoom:67%;}</style><p><strong>解决：</strong>按照下面把”console&#x3D;tty0”移到前面就可以了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs <span class="string">&quot;console=tty0 console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 earlyprintk rw  vt.global_cursor_default=0&quot;</span></span><br></pre></td></tr></table></figure><p>不过这时变成lcd屏幕看不到登录选项了，确实奇怪。</p><p>以下解决方法是网上看到的，由于usb口需供电，故暂时没法插键盘测试：</p><ul><li>此时编译的uboot是可以LCD和串口同时输出log的，但是<strong>LCD端还不是控制台无法使用USB键盘</strong>进行控制，需要做以下改动来实现多个console控制台：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/inittab</span><br></pre></td></tr></table></figure><ul><li>将原有的console注释掉，改为ttyS0和tty0，ttyS0是USB键盘输入，tty0就是正常输出输入</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#console::respawn:-/bin/sh </span><br><span class="line">ttyS0::respawn:-/bin/sh </span><br><span class="line">tty0::respawn:-/bin/sh</span><br></pre></td></tr></table></figure><h4 id="调节LCD背光"><a href="#调节LCD背光" class="headerlink" title="调节LCD背光"></a>调节LCD背光</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#lcd背光控制</span></span><br><span class="line"><span class="built_in">ls</span> sys/class/backlight/backlight/</span><br><span class="line"><span class="comment">#查看最大亮度等级</span></span><br><span class="line"><span class="built_in">cat</span> /sys/class/backlight/backlight/max_brightness</span><br><span class="line"><span class="comment">#调节亮度</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /sys/class/backlight/backlight/brightness</span><br><span class="line"><span class="comment">#关闭背光</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /sys/class/backlight/backlight/bl_power</span><br><span class="line"><span class="comment">#打开背光电源</span></span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /sys/class/backlight/backlight/bl_power</span><br></pre></td></tr></table></figure><style>.musztekqtnjt{zoom:67%;}</style><h4 id="LCD启动卡住"><a href="#LCD启动卡住" class="headerlink" title="LCD启动卡住"></a>LCD启动卡住</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用以下屏幕参数的设备树会卡死</span></span><br><span class="line">setenv bootcmd <span class="string">&quot;setenv bootm_boot_mode sec;load mmc 0:1 0x41000000 zImage;load mmc 0:1 0x41800000 sun8i-v3s-licheepi-zero-with-480x272-lcd.dtb;bootz 0x41000000 - 0x41800000;&quot;</span></span><br><span class="line">setenv bootcmd <span class="string">&quot;setenv bootm_boot_mode sec;load mmc 0:1 0x41000000 zImage;load mmc 0:1 0x41800000 sun8i-v3s-licheepi-zero-with-800x480-lcd.dtb;bootz 0x41000000 - 0x41800000;&quot;</span></span><br></pre></td></tr></table></figure><style>.gxwgfozuxyzj{zoom:67%;}</style><p><del>由于linux中sun8i-v3s.dtsi已默认有lcd的设备结点，生成的内核已有fb0设备，故这里不用额外配置lcd，不使用带有“-with-480x272-lcd.dtb”的设备树文件：</del></p><style>.rzbalkhfwjmv{zoom:67%;}</style><style>.svqdgbulxbkj{zoom:67%;}</style><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#fb0测试</span></span><br><span class="line"><span class="comment">#现象为黑屏</span></span><br><span class="line"><span class="built_in">cat</span> /dev/zero&gt; /dev/fb0  </span><br><span class="line"> <span class="comment">#屏幕会随机花屏</span></span><br><span class="line"><span class="built_in">cat</span> /dev/urandom &gt; /dev/fb0 </span><br></pre></td></tr></table></figure><h4 id="无eth0网口设备"><a href="#无eth0网口设备" class="headerlink" title="无eth0网口设备"></a>无eth0网口设备</h4><h5 id="设备树修改"><a href="#设备树修改" class="headerlink" title="设备树修改"></a>设备树修改</h5><p>修改“修改文件xxx&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;sun8i-v3s-licheepi-zero.dts”设备树文件：</p><ul><li>aliases节点内添加如下内容：<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ethernet0 = <span class="variable">&amp;emac</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure></li><li>在末尾添加如下内容，启用emac外设<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;emac</span> <span class="punctuation">&#123;</span></span><br><span class="line">       <span class="attr">phy-handle</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;int_mii_phy</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">phy-mode</span> <span class="operator">=</span> <span class="string">&quot;mii&quot;</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">allwinner,leds-active-low</span><span class="punctuation">;</span></span><br><span class="line">       <span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="menuconfig-修改配置"><a href="#menuconfig-修改配置" class="headerlink" title="menuconfig 修改配置"></a>menuconfig 修改配置</h5><p>这里主要是针对linux5.2版本的linux，之前的版本（linux4.10，4.13，4.14）都默认勾选了这个配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm menuconfig </span><br><span class="line">time make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j8</span><br></pre></td></tr></table></figure><style>.hneeifactkic{zoom:67%;}</style><h5 id="网卡信息修改"><a href="#网卡信息修改" class="headerlink" title="网卡信息修改"></a>网卡信息修改</h5><p>制作好的文件系统，需要修改Net相关描述，在&#x2F;etc&#x2F;network&#x2F;interfaces 下添加：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#静态IP</span></span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">address 192.168.123.88</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.123.1</span><br><span class="line"></span><br><span class="line"><span class="comment">#动态IP</span></span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet dhcp</span><br></pre></td></tr></table></figure><p>也可以修改&#x2F;etc&#x2F;init.d&#x2F;rcS的启动文件，添加：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 up</span><br><span class="line">ifconfig eth0 192.168.123.66 netmask 255.255.255.0</span><br><span class="line">route add default gw 192.168.123.1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;nameserver 192.168.123.1&quot;</span> &gt; /etc/resolv.conf</span><br></pre></td></tr></table></figure><p>重启开发板，使用reboot指令重启。直接按开发板的复位键，可能会导致刚刚的修改丢失不被保存。</p><style>.iaozcobkkbcx{zoom:67%;}</style><blockquote><p>对应的PC主机 ,Windows 可能需要关闭防火墙或者改出入站规则 ，不然ping 不上</p></blockquote><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="虚拟机ubuntu无法ping通uboot"><a href="#虚拟机ubuntu无法ping通uboot" class="headerlink" title="虚拟机ubuntu无法ping通uboot"></a>虚拟机ubuntu无法ping通uboot</h4><p>只能在 uboot 中 ping 其他的机器，其他机器不能 ping uboot，因为 uboot 没有对 ping<br>命令做处理，如果用其他的机器 ping uboot 的话会失败！</p><h4 id="将nfs挂载的rootfs烧写到emmc启动后出现问题"><a href="#将nfs挂载的rootfs烧写到emmc启动后出现问题" class="headerlink" title="将nfs挂载的rootfs烧写到emmc启动后出现问题"></a>将nfs挂载的rootfs烧写到emmc启动后出现问题</h4><p>问题为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Freeing unused kernel memory: 400K (8090e000 - 80972000)</span><br><span class="line">Kernel panic - not syncing: No working init found.  Try passing init= option to kernel. See Linux Documentation/init.txt for guidance.</span><br><span class="line">---[ end Kernel panic - not syncing: No working init found.  Try passing init= option to kernel. See Linux Documentation/init.txt for guidance.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解决：不要在rootfs文件夹外面打包压缩，例如“tar -jcf rootfs.tar.bz2”；直接进去rootfs文件夹内压缩，例如“tar -jcf rootfs.tar.bz2 * ”</p><h4 id="ssh传输出错"><a href="#ssh传输出错" class="headerlink" title="ssh传输出错"></a>ssh传输出错</h4><p>运行重新编译的文件系统后，如果网络ip和之前设置的一样，容易出现其“指纹”和保存的不一样的问题，发出警告不予传输：</p><style>.gipqqgwnhsad{zoom:67%;}</style><p>解决办法，打开用户目录下面的.ssh&#x2F;known_hosts文件，然后删除连过这个ip地址的记录，那么下次连接的时候会认为是第一次连接，所以会重新保存指纹。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; ./.ssh/known_hosts</span><br></pre></td></tr></table></figure><style>.dzyyxbopsjsj{zoom:67%;}</style><h4 id="LC-v3s、Cherrpi-v3s开发板无显示"><a href="#LC-v3s、Cherrpi-v3s开发板无显示" class="headerlink" title="LC v3s、Cherrpi v3s开发板无显示"></a>LC v3s、Cherrpi v3s开发板无显示</h4><p>参考：<a href="https://liefyuan.blog.csdn.net/article/details/124656809">https://liefyuan.blog.csdn.net/article/details/124656809</a></p><p>这里使用LC-cherry开发板，该开发板的屏幕电路原理图和licheepi的类似，只是屏幕的背光引脚不同。</p><style>.bxuyxemypngb{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/%E5%9B%BE%E7%89%871.png" class="bxuyxemypngb" alt="图片1"><style>.htvnjeucflnz{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240316233627783.png" class="htvnjeucflnz" alt="image-20240316233627783"><p>修改“u-boot-3s-current&#x2F;configs&#x2F;LicheePi_Zero_800x480LCD_defconfig”，添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_VIDEO_LED_BL_EN=&quot;PB4&quot;</span><br><span class="line">CONFIG_VIDEO_LCD_BL_PWM=&quot;PB2&quot;</span><br></pre></td></tr></table></figure><style>.xodlrtxpsjpt{zoom:67%;}</style><img src="/2024/03/14/linux-%E5%85%A8%E5%BF%97V3s%E7%A7%BB%E6%A4%8Duboot-kernel-rootfile%E8%AE%B0%E5%BD%95/image-20240317134113771.png" class="xodlrtxpsjpt" alt="image-20240317134113771"><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#fb0测试</span></span><br><span class="line"><span class="comment">#现象为黑屏</span></span><br><span class="line"><span class="built_in">cat</span> /dev/zero&gt; /dev/fb0  </span><br><span class="line"> <span class="comment">#屏幕会随机花屏</span></span><br><span class="line"><span class="built_in">cat</span> /dev/urandom &gt; /dev/fb0 </span><br></pre></td></tr></table></figure><p>其他疑问：</p><ul><li>PB2没有PWM，PB4有PWM，但这里设置是反的？</li><li>在LC板的原理图上，PB4不是背光电路，但测试中发现少了这个也无法点亮屏幕，是不是uboot传参到linux中，需要该参数才会加载屏幕的驱动？</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> linux驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM体系结构</title>
      <link href="/2024/03/12/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/2024/03/12/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>内容主要参考“arm体系结构与编程”第2版，这里的体系架构主要以ARM9为例进行说明。</p><h3 id="ARM含义"><a href="#ARM含义" class="headerlink" title="ARM含义"></a>ARM含义</h3><p>ARM有三种含义：ARM公司、ARM处理器、ARM技术</p><p><strong>ARM公司</strong>是专门从事基于RISC技术的芯片设计开发的公司。作为知识产权供应商，ARM本身并不直接从事芯片生产，而是转让设计许可，由合作公司生产各具特色的芯片。世界各大半导体生产商从ARM公司购买其设计的ARM微处理器核，根据各自的不同应用领域，加入适当的外围电路，从而形成自己的ARM微处理器芯片进入市场。目前，全世界有几十家大的半导体公司都使用ARM公司的授权，因此既使得ARM技术获得更多的第三方工具、制造、软件的支持特，又使整个系统成本降低，使产品更容易进入市场并被消费者接受，更具有竞争力。 ARM知识产权授权用户非常众多，其中包括世界顶级的半导体和系统公司。</p><p><strong>ARM处理器</strong>：ARM处理器是由ARM公司设计和授权的处理器架构。</p><ol><li><strong>架构特点</strong>：ARM处理器采用精简指令集计算机（RISC）架构，设计目标是提供高性能和低功耗的处理解决方案。ARM处理器的指令集简洁高效，优化了指令执行和内存访问，提供高效的数据处理和控制能力。</li><li><strong>处理器系列</strong>：ARM公司设计了多个系列的处理器架构，以满足不同应用需求。其中包括：<ul><li><strong>ARM Cortex-A系列</strong>：面向高性能计算和多任务处理，适用于智能手机、平板电脑、云服务器等需要较强处理能力的应用。</li><li><strong>ARM Cortex-R系列</strong>：专为实时应用设计，提供可靠的实时性能和可预测性，适用于汽车电子、工业控制和嵌入式系统等领域。</li><li><strong>ARM Cortex-M系列</strong>：针对低功耗和资源受限的嵌入式应用，提供紧凑的处理能力和实时性能，适用于物联网设备、传感器节点等。</li></ul></li></ol><p><strong>ARM技术</strong>是由ARM公司开发和推广的一系列技术和解决方案，涵盖了处理器架构、系统设计、软件开发和生态系统支持等方面。</p><h3 id="ARM体系架构版本"><a href="#ARM体系架构版本" class="headerlink" title="ARM体系架构版本"></a>ARM体系架构版本</h3><p>迄今为止，ARM体系结构已经定义了多个版本，从低版本到高版本，ARM体系的指令集功能不断扩大。同时，各版本中还有一些变种，这些变种定义了该版本指令集中不同的功能。ARM处理器系列中的各种处理器，所采用的实现技术各不相同，性能差别很大，应用场合也有所不同，但是只要它们支持相同的ARM体系版本，基于它们的应用软件将是兼容的。</p><p>ARM的版本分为两类，一个是内核版本，一个处理器版本。内核版本也就是ARM架构，如ARMv1、ARMv2、ARMv3、ARMv4、ARMv5、ARMv6、ARMv7、ARMv8等。处理器版本也就是ARM处理器，如ARM1、ARM9、ARM11、ARM Cortex-A（A7、A9、A15），ARM Cortex-M（M1、M3、M4）、ARM Cortex-R，这个也是通常意义上所指的ARM版本。</p><p>ARM体系结构的版本</p><table><thead><tr><th>内核（架构）版本</th><th>时间</th><th>处理器版本</th></tr></thead><tbody><tr><td>ARMv1</td><td>1985</td><td>ARM1</td></tr><tr><td>ARMv2</td><td>1986</td><td>ARM2、ARM3</td></tr><tr><td>ARMv3</td><td>1990</td><td>ARM6、ARM7（<strong>没有MMU</strong>）<br />（引入了<u>Thumb指令集</u>，该指令集使用16位指令，用于提高代码密度。）</td></tr><tr><td>ARMv4</td><td>1993</td><td>StrongARM、ARM7TDMI、ARM9TDMI<br />（支持<u>分页内存管理</u>等）</td></tr><tr><td>ARMv5</td><td>1998</td><td>ARM7EJ、<strong>ARM9</strong>、ARM9E、ARM10E、XScale<br />（<u>协处理器支持</u>、增强的分页内存管理和增强的Thumb指令集）</td></tr><tr><td>ARMv6</td><td>2001</td><td>ARM11、ARM Cortex-M<br />（引入了<u>Thumb-2指令集</u>，该指令集能够同时支持16位和32位指令。）</td></tr><tr><td>ARMv7</td><td>2004</td><td>ARM <strong>Cortex-A</strong>（应用程序处理器）、ARM Cortex-R（实时处理器）、ARM Cortex-M（微控制器）<br />（32位ARM处理器体系结构的最高版本，<u>从这时开始ARM公司以Cortex来重新命名处理器</u>）</td></tr><tr><td>ARMv8</td><td>2011</td><td>ARM Cortex-A30、ARM Cortex-A50、ARM Cortex-A70等<br />（<u>引入了AArch64，开始支持64位指令集</u>）</td></tr><tr><td>ARMv9</td><td>2021</td><td>ARM Cortex-A510 &#x2F; A710 &#x2F; A715&#x2F;X2&#x2F;X3…等</td></tr></tbody></table><p>常见SoC型号的架构及处理器版本示例：</p><table><thead><tr><th>SoC型号</th><th>处理器版本</th><th>架构版本</th></tr></thead><tbody><tr><td>三星s3c2440&#x2F;S3C2410</td><td>ARM9系列</td><td>ARMv4</td></tr><tr><td>全志F1C100s&#x2F;F1C200s</td><td>ARM9系列</td><td>ARMv5</td></tr><tr><td>三星S3C6440</td><td>ARM11系列</td><td>ARMv6</td></tr><tr><td>i.MX6ULL<br />全志A20&#x2F;A31&#x2F;V3s</td><td>Cortex-A7</td><td>ARMv7</td></tr><tr><td>全志A10<br />苹果A4</td><td>Cortex-A8</td><td>ARMv7</td></tr><tr><td>高通骁龙815<br />全志H616<br />瑞芯微RK3528</td><td>Cortex-A53&#x2F;A57</td><td>ARMv8</td></tr><tr><td>瑞芯微RK3399</td><td>Cortex-A53+A72</td><td>ARMv8</td></tr><tr><td>麒麟9000<br />骁龙888、天玑8100</td><td>Cortex-A77&#x2F;A78</td><td>ARMv8</td></tr><tr><td>骁龙8Gen1</td><td>Cortex-X2+A710+A510</td><td>ARMv9</td></tr></tbody></table><h3 id="ARM体系结构特点"><a href="#ARM体系结构特点" class="headerlink" title="ARM体系结构特点"></a>ARM体系结构特点</h3><p>主要参考”ARM体系结构与编程_唐振明“。</p><p>ARM 内核采用精简指令集结构（Reduced Instruction Set Computer，RISC）体系结构。RISC技术产生于 20 世纪 70 年代，其设计目标是创建一种能以每个时钟周期执行一条指令的速度很快的计算机。RISC 的设计重点在于降低由硬件执行的指令复杂度，这是因为软件比硬件容易提供更大的灵活性和更高的智能。与其相对的传统复杂指令级计算机（CISC）则更侧重于硬件执行指令的功能性，这使 CISC 指令变得更复杂。</p><style>.oodvoqfyekdw{zoom:67%;}</style><img src="/2024/03/12/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20240312215004407.png" class="oodvoqfyekdw" alt="image-20240312215004407"><p>（1）Load&#x2F;Store 体系结构</p><p>Load&#x2F;Store 体系结构也称为寄存器&#x2F;寄存器体系结构或者 RR 系统结构。在这类结构中，操作数和运算结果不是通过主存储器直接取回而是借用大量标量和矢量寄存器来取回的。与 RR体系结构相反，还有一种存储器&#x2F;存储器体系结构，在这种体系结构中，源操作数的中间值和最后的运算结果是直接从主存储器中取回的，这类结构的缩写符号是 SS 体系结构。</p><p>（2）固定长度指令</p><p>固定长度指令使得机器译码变得比较容易。由于指令简单，需要更多的指令来完成相同的工作，但是开发快速的价格低廉的存储器装置使得可以更快地执行较大代码段（大量指令成为可能）。</p><p>（3）硬联控制</p><p>RISC 机以硬联控制指令为特点，而 CISC 的微代码指令则相反。与用 CISC（常常是可变长度的）指令集来使处理器的语义效率最大相反，简单指令往往容易被机器翻译。像 CISC 那样通过执行较少指令来完成工作未必省时，因为还要包括微代码译码所需要的时间。因此，由硬件实现指令在执行时间方面提供了更好的平衡。除此之外，还节省了芯片上用于存储微代码的空间并且消除了翻译微代码所需的时间。</p><p>（4）流水线</p><p>指令处理过程被拆分为几个更小的、能够被流水线并行执行的单元。在理想情况下，流水线每周期前进一步，可获得更高的吞吐率。</p><p>（5）寄存器</p><p>RICS 处理器拥有更多的通用寄存器，每个寄存器都可存放数据或地址。寄存器可为所有的数据操作提供快速的局部存储访问。</p><h2 id="ARM处理器的运行模式"><a href="#ARM处理器的运行模式" class="headerlink" title="ARM处理器的运行模式"></a>ARM处理器的运行模式</h2><table><thead><tr><th>运行模式</th><th>描述</th></tr></thead><tbody><tr><td>用户模式(User,usr)</td><td>正常程序执行的模式</td></tr><tr><td>快速中断模式(FIQ,fq)</td><td>用于高速数据传输和通道处理</td></tr><tr><td>外部中断模式(IRQ,irq)</td><td>用于通常的中断处理</td></tr><tr><td>特权模式(Supervisor,sve)</td><td>供操作系统使用的一种保护模式</td></tr><tr><td>数据访问中止模式(Abort,abt)</td><td>用于虚拟存储及存储保护</td></tr><tr><td>未定义指令中止模式(Undefined,und)</td><td>用于支持通过软件仿真硬件的协处理器</td></tr><tr><td>系统模式(System,sys)</td><td>用于运行特权级的操作系统任务</td></tr></tbody></table><p>除了用户模式之外的其他6种处理器模式称为<strong>特权模式</strong>（Privileged Modes）。在这些模式下，程序可以访问所有的系统资源，也可以任意地进行处理器模式的切换。其中，除系统模式外，其他5种特权模式又称为<strong>异常模式</strong>。</p><p>处理器模式可以通过软件控制进行切换，也可以通过外部中断或异常处理过程进行切换。大多数的用户程序运行在用户模式下。这时，应用程序不能够访问一些受操作系统保护的系统资源。应用程序也不能直接进行处理器模式的切换。当需要进行处理器模式切换时，应用程序可以产生异常处理，在异常处理过程中进行处理器模式的切换。这种体系结构可以使操作系统控制整个系统的资源。</p><p>当应用程序发生异常中断时，处理器进入相应的异常模式。在每一种异常模式中都有一组寄存器，供相应的异常处理程序使用，这样就可以保证在进入异常模式时，用户模式下的寄存器（保存了程序运行状态）不被破坏。</p><p>系统模式并不是通过异常过程进入的，它和用户模式具有完全一样的寄存器。但是系统模式属于特权模式，可以访问所用的系统资源，也可以直接进行处理器模式切换。它主要供操作系统任务使用。通常操作系统的任务需要访问所有的系统资源，同时该任务仍然使用用户模式的寄存器组，而不是使用异常模式下相应的寄存器组，这样可以保证当异常中断发生时任务状态不被破坏。</p><h2 id="ARM寄存器"><a href="#ARM寄存器" class="headerlink" title="ARM寄存器"></a>ARM寄存器</h2><p>ARM处理器共有37个寄存器。其中包括：</p><p>●　31个通用寄存器，包括程序计数器（PC）在内。这些寄存器都是32位寄存器。</p><p>●　6个状态寄存器。这些寄存器都是32位寄存器，但目前只使用了其中12位。</p><p>ARM处理器共有7种不同的处理器模式，在每一种处理器模式中有一组相应的寄存器组。任意时刻（也就是任意的处理器模式下），可见的寄存器包括15个通用寄存器（R0～R14）、一个或两个状态寄存器及程序计数器（PC）。在所有的寄存器中，有些是各模式共用的同一个物理寄存器；有一些寄存器是各模式自己拥有的独立的物理寄存器。</p><style>.eoteltpqzcbp{zoom:67%;}</style><img src="/2024/03/12/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20240312211626917.png" class="eoteltpqzcbp" alt="image-20240312211626917"><p><strong>通用寄存器</strong></p><p>通用寄存器可以分为下面3类：</p><p>●　未备份寄存器（Unbanked Registers），包括R0～R7。</p><p>●　备份寄存器（Banked Registers），包括R8～R14。</p><p>●　程序计数器PC，即R15。</p><p>1．未备份寄存器</p><p>未备份寄存器包括R0～R7。对于每一个未备份寄存器来说，在所有的处理器模式下指的都是同一个物理寄存器。在异常中断造成处理器模式切换时，由于不同的处理器模式使用相同的物理寄存器，可能造成寄存器中数据被破坏。未备份寄存器没有被系统用于特别的用途，任何可采用通用寄存器的应用场合都可以使用未备份寄存器。</p><p>2．备份寄存器</p><p>对于备份寄存器R8～R12来说，每个寄存器对应两个不同的物理寄存器。例如，当使用快速中断模式下的寄存器时，寄存器R8和寄存器R9分别记作R8_fiq、R9_fiq；当使用用户模式下的寄存器时，寄存器R8和寄存器R9分别记作R8_usr、R9_usr等。在这两种情况下，使用的是不同的物理寄存器。系统没有将这几个寄存器用于任何特殊用途，但是当中断处理非常简单，仅仅使用R8～R14寄存器时，FIQ处理程序可以不必执行保存和恢复中断现场的指令，从而可以使中断处理过程非常迅速。</p><p>对于备份寄存器R13和R14来说，每个寄存器对应6个不同的物理寄存器，其中的一个是用户模式和系统模式共用的；另外的5个对应于其他5种处理器模式。</p><p>3．程序计数器R15</p><p>程序计数器R15又被记作PC。它虽然可以作为一般的通用寄存器使用，但是有一些指令在使用R15时有一些特殊限制。当违反了这些限制时，该指令执行的结果将是不可预料的。</p><p><strong>程序状态寄存器</strong></p><p>CPSR（当前程序状态寄存器）可以在任何处理器模式下被访问。它包含了条件标志位、中断禁止位、当前处理器模式标志以及其他的一些控制和状态位。</p><p>每一种处理器模式下都有一个专用的物理状态寄存器，称为SPSR（备份程序状态寄存器）。当特定的异常中断发生时，这个寄存器用于存放当前程序状态寄存器的内容。在异常中断程序退出时，可以用SPSR中保存的值来恢复CPSR。</p><p>由于用户模式和系统模式不是异常中断模式，所以它们没有SPSR。当在用户模式或系统模式中访问SPSR时，将会产生不可预知的结果。</p><p>CPSR的格式如下所示，SPSR格式与CPSR格式相同</p><img src="/2024/03/12/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20240312212917131.png" class="" title="image-20240312212917131"><h2 id="ARM指令集"><a href="#ARM指令集" class="headerlink" title="ARM指令集"></a>ARM指令集</h2><p>ARM处理器使用ARM指令集和Thumb指令集。</p><ul><li>ARM指令集包含32位的指令，提供了丰富的功能和灵活性。</li><li>Thumb指令集支持16位的指令，用于提高代码密度和节省存储空间。</li><li>最新的ARM处理器还支持AArch64执行状态，提供了64位的指令集，称为AArch64指令集。</li></ul><p><strong>Thumb指令集</strong></p><p>Thumb指令集是ARM架构中的一种16位指令集，旨在提高代码密度和降低存储器需求。</p><p>Thumb指令集与ARM指令集的区别：</p><ol><li><code>指令长度</code>：ARM指令集的指令长度为32位，而Thumb指令集的指令长度为16位。由于指令长度减少了一半，Thumb指令集可以在同样的存储空间下存储更多的指令，从而提高了代码密度。</li><li><code>寄存器数量</code>：ARM指令集有16个通用寄存器，每个寄存器都是32位的。而Thumb指令集有8个通用寄存器，每个寄存器都是16位的。这意味着在Thumb指令集中，可以同时使用的寄存器数量更少，因此需要更频繁地进行数据的加载和存储。</li><li><code>指令集功能</code>：ARM指令集提供了更多的功能和灵活性，支持更多的数据处理操作和复杂的指令流控制。相比之下，Thumb指令集在设计上更加简化，提供了基本的数据操作和简单的控制流指令，牺牲了一些高级功能和复杂的指令。</li><li><code>性能</code>：由于Thumb指令集的指令长度较短，指令的执行时间通常也较短。因此，在某些情况下，Thumb指令集可以提供更高的执行速度和更低的功耗。</li></ol><p><strong>ARM指令集</strong></p><p>ARM指令集可以分为6类，即跳转指令、数据处理指令、程序状态寄存器（PSR）传输指令、Load&#x2F;Store指令、协处理器指令和异常中断产生指令。</p><h2 id="ARM体系的异常中断"><a href="#ARM体系的异常中断" class="headerlink" title="ARM体系的异常中断"></a>ARM体系的异常中断</h2><p>在ARM体系中，通常有以下3种方式控制程序的执行流程：</p><p>●　在正常程序执行过程中，每执行一条ARM指令，程序计数寄存器（PC）的值加4个字节；每执行一条Thumb指令，程序计数寄存器（PC）的值加两个字节。整个过程是按顺序执行的。</p><p>●　通过跳转指令，程序可以跳转到特定的地址标号处执行，或者跳转到特定的子程序处执行。其中，B指令用于执行跳转操作；BL指令在执行跳转操作的同时，保存子程序的返回地址；BX指令在执行跳转操作的同时，根据目标地址的最低位可以将程序状态切换到Thumb状态；BLX指令执行3个操作，跳转到目标地址处执行，保存子程序的返回地址，根据目标地址的最低位可以将程序状态切换到Thumb状态。</p><p>●　当异常中断发生时，系统执行完当前指令后，将跳转到相应的异常中断处理程序处执行。在异常中断处理程序执行完成后，程序返回到发生中断的指令的下一条指令处执行。在进入异常中断处理程序时，要保存被中断的程序的执行现场，在从异常中断处理程序退出时，要恢复被中断的程序的执行现场。</p><p><strong>ARM中异常中断的种类</strong></p><style>.ngkfrthhykyl{zoom:67%;}</style><img src="/2024/03/12/ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/image-20240312213451807.png" class="ngkfrthhykyl" alt="image-20240312213451807"><p><strong>ARM处理器对异常中断的响应过程</strong></p><p>（1）保存处理器当前状态、中断屏蔽位以及各条件标志位。这是通过将当前程序状态寄存器CPSR的内容保存到将要执行的异常中断对应的SPSR寄存器中实现的。各异常中断有自己的物理SPSR寄存器。</p><p>（2）设置当前程序状态寄存器CPSR中相应的位。包括设置CPSR中的位，使处理器进入相应的执行模式；设置CPSR中的位，禁止IRQ中断，当进入FIQ模式时，禁止FIQ中断。</p><p>（3）将寄存器lr_mode设置成返回地址。</p><p>（4）将程序计数器（PC）设置成该异常中断的中断向量地址，从而跳转到相应的异常中断处理程序处执行。</p><p><strong>从异常中断处理程序中返回过程</strong></p><p>（1）恢复被中断的程序的处理器状态，即将SPSR_mode寄存器内容复制到CPSR中。</p><p>（2）返回到发生异常中断的指令的下一条指令处执行，即把lr_mode寄存器的内容复制到程序计数器PC中。</p><p><strong>中断和异常的区别</strong></p><ul><li><code>中断（Interrupt）</code>是由外部设备或事件引发的中断请求，用于打断正在执行的指令流，让处理器转移到中断服务程序（Interrupt Service Routine，ISR）来处理该事件。中断通常由外部设备的信号触发，例如定时器溢出、外部设备的输入等。</li><li><code>异常（Exception）</code>是由程序运行过程中的异常情况引发的事件，如无效的指令、访问越界、除以零等。异常会导致处理器从当前模式切换到异常模式，并执行异常处理程序（Exception Handler）来处理异常情况。</li></ul><p><strong>异常处理过程</strong></p><ol><li>当发生异常时，处理器会保存当前的上下文信息（如寄存器状态、程序计数器等），以便稍后恢复执行。</li><li>处理器会根据异常类型和优先级判断是否响应该异常，如果需要响应，则会切换到异常模式，并跳转到相应的异常处理程序。</li><li>异常处理程序会执行相关的异常处理逻辑，如错误处理、状态恢复、错误日志记录等。</li><li>在处理完异常后，处理器会从保存的上下文信息中恢复状态，并回到原来的模式和指令流中，继续执行。</li></ol><h2 id="ARM-流水线"><a href="#ARM-流水线" class="headerlink" title="ARM 流水线"></a>ARM 流水线</h2><p>处理器按照一系列步骤来执行每一条指令。典型计算机系统的步骤如下: </p><p>（1）从存储器读取指令（fetch）；</p><p>（2）译码以鉴别它是属于哪一条指令（dec）；</p><p>（3）从指令中提取指令的操作数（这些操作数往往存在于寄存器中）（reg）；</p><p>（4）将操作数进行组合以得到结果或存储器地址（ALU）；</p><p>（5）如果需要，则访问存储器以存储数据（mem）；</p><p>（6）将结果写回到寄存器堆（res）。</p><p>并不是所有的指令都需要其中的每一个步骤，但是，多数指令需要其中的多个步骤。这些步骤往往使用不同的硬件功能，如果一条指令不是在前一条指令结束之前就开始，那么在每一步骤内处理器只有少部分的硬件在使用。</p><p>有一个明显的方法可以改善硬件资源的使用率和处理器的吞吐量，这就是当前一条指令结束之前就开始执行下一条指令，也就是通常所说的<strong>流水线（Pipeline）技术</strong>。</p><p>流水线是RISC 处理器执行指令时采用的机制。使用流水线，可在取下一条指令的同时译码和执行其他指令，从而加快执行的速度。</p><p><strong>管道流水线</strong></p><p>ARM处理器的管道流水线是一种用于提高指令执行效率的技术。它将指令执行过程划分为多个阶段，并在每个阶段引入寄存器，使得多条指令可以同时在不同的阶段执行。这样可以提高处理器的吞吐量，使得指令能够更快地完成执行。</p><p>流水线中的不同阶段包括：</p><ol><li>取指令（Instruction Fetch）</li><li>译码（Instruction Decode）</li><li>执行（Execute）</li><li>访存（Memory Access）</li><li>写回（Write Back）</li></ol><p>通过流水线技术，当一条指令执行进入流水线后，后续的指令可以继续进入流水线的不同阶段，从而实现指令级并行（Instruction-Level Parallelism）。这可以提高处理器的效率，使得多条指令可以在同一时间段内重叠执行。</p><h2 id="ARM存储器"><a href="#ARM存储器" class="headerlink" title="ARM存储器"></a>ARM存储器</h2><p>ARM 处理器内核广泛应用于嵌入式系统和其他行业应用中。为了适应不同系统的需要，ARM 采用了灵活多样的存储管理体系。从平板式内存映射到灵活方便的 MMU 内存管理单元，用户可以根据自己的需要使用不同的存储管理策略。在 ARM 体系结构中可使用的存储管理策略包括以下几种：</p><p>（1）多类型的存储单元（可以使用 SDRAM、FLASH 等）；</p><p>（2）Caches；</p><p>（3）写缓存；</p><p>（4）虚拟内存地址</p><p>另外，内存映射 I&#x2F;O 机制可以使开发者灵活、方便地增加大量外设。可以通过下面的几种方法实现对存储系统的管理：</p><p>（1）使能 Cache，加快存储器的访问速度；</p><p>（2）启动虚拟地址到物理地址的映射；</p><p>（3）使用“域管理”策略，对存储单元的访问进行保护；</p><p>（4）对 I&#x2F;O 映射地址空间的访问加以限制。</p><p><strong>ARM的Cache和MMU</strong></p><ol><li><code>Cache</code>：Cache是一种位于处理器和主存之间的高速存储器，用于存储最近使用的数据和指令。它的作用是通过预先将数据和指令复制到快速的缓存中，加快对数据的访问速度，减少对主存的访问次数。Cache的工作原理是基于局部性原理，即程序和数据的访问往往呈现出一定的空间局部性和时间局部性。Cache通过存储最近使用的数据块，以便在后续的访问中快速提供数据，减少了对主存的延迟。</li><li><code>MMU</code>:MMU是负责管理虚拟内存和物理内存之间映射关系的组件。它允许操作系统和应用程序使用虚拟内存地址，而不必关心物理内存的实际分配情况。MMU的主要功能包括地址转换和内存保护。它通过将虚拟地址转换为物理地址，实现了对虚拟内存的透明访问。MMU还负责内存保护，通过访问控制和权限设置，确保不同应用程序之间的内存隔离和安全性。MMU还支持内存映射技术，例如页面映射（Page Mapping）和段映射（Segment Mapping），以及虚拟内存的分页和分段机制，实现了灵活的内存管理和资源分配。</li></ol><p><strong>ARM的大端和小端字节序</strong></p><p>字节序（Byte Order）指的是多字节数据在内存中存储的顺序。在ARM体系结构中，字节序对于处理器和操作系统的开发者来说是重要的。不同的字节序可能会影响数据的读取和存储，特别是在跨平台和数据交换的情况下。</p><ol><li><code>大端字节序</code>：在大端字节序中，多字节数据的高位字节存储在低地址处，而低位字节存储在高地址处。这意味着多字节数据的字节顺序与其在内存中的存储顺序相同。</li><li><code>小端字节序</code>：在小端字节序中，多字节数据的低位字节存储在低地址处，而高位字节存储在高地址处。这意味着多字节数据的字节顺序与其在内存中的存储顺序相反。</li></ol><h2 id="I-O-管理"><a href="#I-O-管理" class="headerlink" title="I&#x2F;O 管理"></a>I&#x2F;O 管理</h2><p>ARM 系统完成 I&#x2F;O 功能的标准方法是使用存储器映射 I&#x2F;O。这种方法使用特定的存储器地址。当从这些地址加载或向这些地址存储时，它们提供 I&#x2F;O 功能。某些 ARM 系统中也可能存在直接存储器访问（Direct Memory Access，DMA）硬件。</p><p>外围设备（如串行线控制器）中包含一些寄存器。在存储器映射系统中，这些寄存器就像特定地址的存储器一样（在其他的系统组织中，I&#x2F;O 功能可能与存储器件有不同的寻址空间）。如串行线控制器可能有以下 5 种寄存器：</p><p>（1）发送数据寄存器（只写）：写入这个位置的数据被送往串行线。</p><p>（2）接收数据寄存器（只读）：保存从串行线送来的数据。</p><p>（3）控制寄存器（读&#x2F;写）：设置数据速率，管理 RTS（请求发送）和其他类似信号。</p><p>（4）中断使能寄存器（读&#x2F;写）：控制中断的硬件事件。</p><p>（5）状态寄存器（读&#x2F;写）：指示读数据是否有效，写缓存是否满等。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>来源：<a href="https://eight-legged-essay.yangpaopao.space/arm/basic.html">https://eight-legged-essay.yangpaopao.space/arm/basic.html</a></p><p><strong>ARM的协处理器（Coprocessor）和向量处理器（NEON）</strong></p><ol><li><code>协处理器（Coprocessor）</code>：协处理器是ARM处理器的一个可选扩展，用于执行特定的处理任务。它是与主处理器并行工作的一个辅助处理器。协处理器可以执行一些特定的指令和操作，例如浮点运算、加密算法、信号处理等。通过将特定任务分配给协处理器，ARM处理器可以提高处理性能和效率。</li><li><code>向量处理器（NEON）</code>：NEON是ARM处理器中的一个向量处理器扩展，用于高效执行并行的多媒体和信号处理操作。NEON提供了一组特定的指令和寄存器，用于同时处理多个数据元素，例如矢量、矩阵和像素数据。这使得ARM处理器能够高效地执行诸如图像处理、音频处理、视频编解码等计算密集型任务。</li></ol><p><strong>ARM体系结构中的Thumb-2技术</strong></p><p>Thumb-2是ARM体系结构中的一种指令集技术，旨在提高代码密度和性能。它结合了Thumb指令集（16位指令）和ARM指令集（32位指令），使得处理器能够同时执行16位和32位指令，以适应不同的应用场景。Thumb-2技术提供了以下优势：</p><ol><li><code>代码密度改善</code>：Thumb-2指令集中的16位指令相比于32位指令更加紧凑，占用更少的存储空间。通过使用Thumb-2指令集，可以显著减少程序的代码大小。这对于存储有限的设备（如嵌入式系统）和带宽受限的环境非常有益。</li><li><code>性能提升</code>：Thumb-2技术不仅仅是为了减少代码大小，还针对性能进行了优化。Thumb-2指令集中的某些16位指令具有与对应的32位指令相似的执行效率。这意味着通过使用Thumb-2指令集，可以在减少代码大小的同时保持较高的执行效率。</li><li><code>兼容性和灵活性</code>：Thumb-2技术兼容先前的Thumb指令集，因此可以无缝地与使用Thumb指令集编写的现有代码进行交互。此外，处理器可以在Thumb状态和ARM状态之间进行快速切换，使得开发人员可以根据需要选择最适合的指令集。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> arm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp常用STL记录</title>
      <link href="/2024/03/11/cpp-%E5%B8%B8%E7%94%A8STL%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/03/11/cpp-%E5%B8%B8%E7%94%A8STL%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>参考：<a href="https://zhuanlan.zhihu.com/p/582795495">https://zhuanlan.zhihu.com/p/582795495</a></p><p><u>C++ STL是C++标准库的一部分，不等于C++标准库。</u></p><h3 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++ 标准库"></a>C++ 标准库</h3><p>C++ 标准库可以分为两部分：</p><ul><li><strong>标准函数库：</strong> 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库<u>继承自 C 语言</u>。</li><li><strong>面向对象类库：</strong> 这个库是类及其相关函数的集合。</li></ul><h4 id="标准函数库"><a href="#标准函数库" class="headerlink" title="标准函数库"></a>标准函数库</h4><p>标准函数库分为以下几类：</p><ul><li>输入&#x2F;输出 I&#x2F;O</li><li>字符串和字符处理</li><li>数学</li><li>时间、日期和本地化</li><li>动态分配</li><li>其他</li><li>宽字符函数</li></ul><h4 id="面向对象类库"><a href="#面向对象类库" class="headerlink" title="面向对象类库"></a>面向对象类库</h4><p>标准的 C++ 面向对象类库定义了大量支持一些常见操作的类，比如输入&#x2F;输出 I&#x2F;O、字符串处理、数值处理。面向对象类库包含以下内容：</p><ul><li>标准的 C++ I&#x2F;O 类</li><li>String 类</li><li>数值类</li><li><strong>STL 容器类</strong></li><li><strong>STL 算法</strong></li><li><strong>STL 函数对象</strong></li><li><strong>STL 迭代器</strong></li><li><strong>STL 分配器</strong></li><li>本地化库</li><li>异常处理类</li><li>杂项支持库</li></ul><h3 id="STL-标准模板库"><a href="#STL-标准模板库" class="headerlink" title="STL 标准模板库"></a>STL 标准模板库</h3><p>STL (Standard Template Library)，即标准模板库，是一个具有工业强度的，高效的C++程序库。</p><p>C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。</p><p>C++ 标准模板库的核心包括以下三个组件：</p><table><thead><tr><th align="left">组件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">容器（Containers）</td><td align="left">一种<strong>数据结构</strong>，容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。</td></tr><tr><td align="left">算法（Algorithms）</td><td align="left">它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。</td></tr><tr><td align="left">迭代器（iterators）</td><td align="left">迭代器用于遍历对象集合的元素，提供了访问容器中对象的方法。</td></tr></tbody></table><p>除此之外，还有仿函数（Functor）、适配器（Adaptor）、分配器（allocator）。</p><h2 id="STL容器"><a href="#STL容器" class="headerlink" title="STL容器"></a>STL容器</h2><p>参考：<a href="https://zhuanlan.zhihu.com/p/564057584">https://zhuanlan.zhihu.com/p/564057584</a></p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>STL中的容器有顺序性容器、关联容器、容器适配器。容器类<u>自动申请和释放内存</u>，无需new和delete操作。</p><p><strong>（1）顺序性容器（Sequence containers）</strong></p><p>每个元素都有固定位置，取决于插入时机和地点，和元素值无关，vector、deque、list；</p><p>Vector：将元素置于一个<u>动态数组</u>中加以管理，可以随机存取元素（用索引直接存取），数组尾部添加或移除元素非常快速，但是在中部或头部安插元素比较费时；</p><p>Deque：是“double-ended queue”的缩写，可以随机存取元素（用索引直接存取），数组头部和尾部添加或移除元素都非常快速，但是在中部或头部安插元素比较费时；</p><p>List：双向链表，不提供随机存取（按顺序走到需存取的元素，O(n)），在任何位置上执行插入或删除动作都非常迅速，内部只需调整一下指针；</p><table><thead><tr><th>容器</th><th>简介说明</th></tr></thead><tbody><tr><td>vector</td><td>可变大小数组。相当于数组，可动态构建，支持随机访问，无头插和尾插，仅支持inset插入，除尾部外的元素删除比较麻烦。但使用最为广泛</td></tr><tr><td>deque</td><td>双端队列。支持头插、删，尾插、删，随机访问较vector容器来说慢,但对于首尾的数据操作比较方便</td></tr><tr><td>list</td><td>双向循环链表。使用起来很高效，对于任意位置的插入和删除都很快，在操作过后，以后指针、迭代器、引用都不会失效</td></tr><tr><td>forward_list</td><td>单向链表。只支持单向访问，在链表的任何位置进行插入&#x2F;删除操作都非常快</td></tr><tr><td>array</td><td>固定数组。vector的底层即为array数组，它保存了一个以严格顺序排列的特定数量的元素</td></tr></tbody></table><p><strong>（2）关联式容器（Associated containers）</strong></p><p>元素位置取决于特定的排序准则，和插入顺序无关，set、multiset、map、multimap等。</p><p>Set&#x2F;Multiset：内部的元素依据其值自动排序，Set内的相同数值的元素只能出现一次，Multisets内可包含多个数值相同的元素，内部由二叉树实现，便于查找；</p><p>Map&#x2F;Multimap：Map的元素是成对的键值&#x2F;实值，内部的元素依据其值自动排序，Map内的相同数值的元素只能出现一次，Multimaps内可包含多个数值相同的元素，内部由二叉树实现，便于查找；</p><table><thead><tr><th>容器</th><th>简介说明</th></tr></thead><tbody><tr><td>set&#x2F;mutliset</td><td>集合&#x2F;多重集合。对于set，在使用insert插入元素时，已插入过的元素不可重复插入，这正好符合了集合的互异性，在插入完成显示后，会默认按照升序进行排序，对于multiset，可插入多个重复的元素</td></tr><tr><td>map&#x2F;mutlimap</td><td>映射&#x2F;多重映射。二者均为二元关联容器（在构造时需要写两个参数类型，前者对key值，后者对应value值），因为有两个参数，因此在插入元素的时候需要配合对组pair进行插入，具体见深入详解</td></tr></tbody></table><p><strong>（3）容器适配器（Congtainer adapters）</strong></p><table><thead><tr><th>容器</th><th>简介说明</th></tr></thead><tbody><tr><td>stack</td><td>堆栈。其原理是先进后出（FILO），其底层容器可以是任何标准的容器适配器，默认为deque双端队列</td></tr><tr><td>queue</td><td>队列。其原理是先进先出（FIFO），只有队头和队尾可以被访问，故不可有遍历行为，默认也为deque双端队列</td></tr><tr><td>pirority_queue</td><td>优先队列。它的第一个元素总是它所包含的元素中优先级最高的，就像数据结构里的<strong>堆</strong>，会默认形成大堆，还可以使用仿函数来控制生成大根堆还是生成小根堆，若没定义，默认使用vector容器</td></tr></tbody></table><ul><li>对于 stack 堆栈，在我们日常生活中类似于坐地铁、电梯；</li><li>对于 deque 队列，在我们日常生活中类似于排队打饭；</li><li>对于 pirority_queue，因为其本质是<strong>堆</strong>，可以考虑解决一些贪心问题；</li></ul><h3 id="顺序性容器"><a href="#顺序性容器" class="headerlink" title="顺序性容器"></a>顺序性容器</h3><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt; vector&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">1.构造函数</span><br><span class="line"></span><br><span class="line">vector():创建一个空vector</span><br><span class="line">vector(int nSize):创建一个vector,元素个数为nSize</span><br><span class="line">vector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为t</span><br><span class="line">vector(const vector&amp;):复制构造函数</span><br><span class="line">vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中</span><br><span class="line">2.增加函数</span><br><span class="line"></span><br><span class="line">void push_back(const T&amp; x):向量尾部增加一个元素X</span><br><span class="line">iterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素x</span><br><span class="line">iterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素x</span><br><span class="line">iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</span><br><span class="line">3.删除函数</span><br><span class="line"></span><br><span class="line">iterator erase(iterator it):删除向量中迭代器指向元素</span><br><span class="line">iterator erase(iterator first,iterator last):删除向量中[first,last)中元素</span><br><span class="line">void pop_back():删除向量中最后一个元素</span><br><span class="line">void clear():清空向量中所有元素</span><br><span class="line">4.遍历函数</span><br><span class="line"></span><br><span class="line">reference at(int pos):返回pos位置元素的引用</span><br><span class="line">reference front():返回首元素的引用</span><br><span class="line">reference back():返回尾元素的引用</span><br><span class="line">iterator begin():返回向量头指针，指向第一个元素</span><br><span class="line">iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置</span><br><span class="line">reverse_iterator rbegin():反向迭代器，指向最后一个元素</span><br><span class="line">reverse_iterator rend():反向迭代器，指向第一个元素之前的位置</span><br><span class="line">5.判断函数</span><br><span class="line"></span><br><span class="line">bool empty() const:判断向量是否为空，若为空，则向量中无元素</span><br><span class="line">6.大小函数</span><br><span class="line"></span><br><span class="line">int size() const:返回向量中元素的个数</span><br><span class="line">int capacity() const:返回当前向量张红所能容纳的最大元素值</span><br><span class="line">int max_size() const:返回最大可允许的vector元素数量值</span><br><span class="line">7.其他函数</span><br><span class="line"></span><br><span class="line">void swap(vector&amp;):交换两个同类型向量的数据</span><br><span class="line">void assign(int n,const T&amp; x):设置向量中第n个元素的值为x</span><br><span class="line">void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素</span><br></pre></td></tr></table></figure><p><strong>二维数组两种定义方法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N=<span class="number">5</span>, M=<span class="number">6</span>; </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">obj</span>(N); <span class="comment">//定义二维动态数组大小5行 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt; obj.<span class="built_in">size</span>(); i++)<span class="comment">//动态二维数组为5行6列，值全为0 </span></span><br><span class="line">    &#123; </span><br><span class="line">        obj[i].<span class="built_in">resize</span>(M); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; obj.<span class="built_in">size</span>(); i++)<span class="comment">//输出二维动态数组 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;obj[i].<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;obj[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N=<span class="number">5</span>, M=<span class="number">6</span>; </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">obj</span>(N, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(M)); <span class="comment">//定义二维动态数组5行6列 </span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; obj.<span class="built_in">size</span>(); i++)<span class="comment">//输出二维动态数组 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;obj[i].<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;obj[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span>  <span class="comment">// 头文件</span></span></span><br><span class="line"></span><br><span class="line">deque&lt;type&gt; deq;  <span class="comment">// 声明一个元素类型为type的双端队列que</span></span><br><span class="line"><span class="function">deque&lt;type&gt; <span class="title">deq</span><span class="params">(size)</span></span>;  <span class="comment">// 声明一个类型为type、含有size个默认值初始化元素的的双端队列que</span></span><br><span class="line"><span class="function">deque&lt;type&gt; <span class="title">deq</span><span class="params">(size, value)</span></span>;  <span class="comment">// 声明一个元素类型为type、含有size个value元素的双端队列que</span></span><br><span class="line"><span class="function">deque&lt;type&gt; <span class="title">deq</span><span class="params">(mydeque)</span></span>;  <span class="comment">// deq是mydeque的一个副本</span></span><br><span class="line"><span class="function">deque&lt;type&gt; <span class="title">deq</span><span class="params">(first, last)</span></span>;  <span class="comment">// 使用迭代器first、last范围内的元素初始化deq</span></span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; deq;</span><br><span class="line"></span><br><span class="line">deq[ ]：用来访问双向队列中单个的元素。</span><br><span class="line">deq.<span class="built_in">front</span>()：返回第一个元素的引用。</span><br><span class="line">deq.<span class="built_in">back</span>()：返回最后一个元素的引用。</span><br><span class="line">deq.<span class="built_in">push_front</span>(x)：把元素x插入到双向队列的头部。</span><br><span class="line">deq.<span class="built_in">pop_front</span>()：弹出双向队列的第一个元素。</span><br><span class="line">deq.<span class="built_in">push_back</span>(x)：把元素x插入到双向队列的尾部。</span><br><span class="line">deq.<span class="built_in">pop_back</span>()：弹出双向队列的最后一个元素。</span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>支持随机访问，即支持[ ]以及at()，但是性能没有vector好。</li><li>可以在内部进行插入和删除操作，但性能不及list。</li><li>deque两端都能够快速插入和删除元素，而vector只能在尾端进行。</li><li>deque的元素存取和迭代器操作会稍微慢一些，因为deque的内部结构会多一个间接过程。</li><li>deque迭代器是特殊的智能指针，而不是一般指针，它需要在不同的区块之间跳转。</li><li>deque可以包含更多的元素，其max_size可能更大，因为不止使用一块内存。</li><li>deque不支持对容量和内存分配时机的控制。</li><li>在除了首尾两端的其他地方插入和删除元素，都将会导致指向deque元素的任何pointers、references、iterators失效。不过，deque的内存重分配优于vector，因为其内部结构显示不需要复制所有元素。</li><li>deque的内存区块不再被使用时，会被释放，deque的内存大小是可缩减的。不过，是不是这么做以及怎么做由实际操作版本定义。</li><li><u>deque不提供容量操作：capacity()和reverse()，但是vector可以</u>。</li></ol><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//list定义和初始化</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;lst1; <span class="comment">//创建空list</span></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">lst2</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">//创建含有5个元素的list</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;<span class="built_in">lst3</span>(<span class="number">3</span>,<span class="number">2</span>); <span class="comment">//创建含有3个元素的list</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;<span class="built_in">lst4</span>(lst2); <span class="comment">//使用lst2初始化lst4</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;<span class="built_in">lst5</span>(lst2.<span class="built_in">begin</span>(),lst2.<span class="built_in">end</span>()); <span class="comment">//同lst4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//list常用操作函数</span></span><br><span class="line">Lst1.<span class="built_in">assign</span>() 给list赋值</span><br><span class="line">Lst1.<span class="built_in">back</span>() 返回最后一个元素</span><br><span class="line">Lst1.<span class="built_in">begin</span>() 返回指向第一个元素的迭代器</span><br><span class="line">Lst1.<span class="built_in">clear</span>() 删除所有元素</span><br><span class="line">Lst1.<span class="built_in">empty</span>() 如果list是空的则返回<span class="literal">true</span></span><br><span class="line">Lst1.<span class="built_in">end</span>() 返回末尾的迭代器</span><br><span class="line">Lst1.<span class="built_in">erase</span>() 删除一个元素</span><br><span class="line">Lst1.<span class="built_in">front</span>() 返回第一个元素</span><br><span class="line">Lst1.<span class="built_in">get_allocator</span>() 返回list的配置器</span><br><span class="line">Lst1.<span class="built_in">insert</span>() 插入一个元素到list中</span><br><span class="line">Lst1.<span class="built_in">max_size</span>() 返回list能容纳的最大元素数量</span><br><span class="line">Lst1.<span class="built_in">merge</span>() 合并两个list</span><br><span class="line">Lst1.<span class="built_in">pop_back</span>() 删除最后一个元素</span><br><span class="line">Lst1.<span class="built_in">pop_front</span>() 删除第一个元素</span><br><span class="line">Lst1.<span class="built_in">push_back</span>() 在list的末尾添加一个元素</span><br><span class="line">Lst1.<span class="built_in">push_front</span>() 在list的头部添加一个元素</span><br><span class="line">Lst1.<span class="built_in">rbegin</span>() 返回指向第一个元素的逆向迭代器</span><br><span class="line">Lst1.<span class="built_in">remove</span>() 从list删除元素</span><br><span class="line">Lst1.<span class="built_in">remove_if</span>() 按指定条件删除元素</span><br><span class="line">Lst1.<span class="built_in">rend</span>() 指向list末尾的逆向迭代器</span><br><span class="line">Lst1.<span class="built_in">resize</span>() 改变list的大小</span><br><span class="line">Lst1.<span class="built_in">reverse</span>() 把list的元素倒转</span><br><span class="line">Lst1.<span class="built_in">size</span>() 返回list中的元素个数</span><br><span class="line">Lst1.<span class="built_in">sort</span>() 给list排序</span><br><span class="line">Lst1.<span class="built_in">splice</span>() 合并两个list</span><br><span class="line">Lst1.<span class="built_in">swap</span>() 交换两个list</span><br><span class="line">Lst1.<span class="built_in">unique</span>() 删除list中相邻重复的元素</span><br></pre></td></tr></table></figure><h3 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h3><h4 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set&#x2F;multiset"></a>set&#x2F;multiset</h4><p>set中的元素即是键值又是实值，set不允许两个元素有相同的键值。不能通过set的迭代器去修改set元素，原因是修改元素会破坏set组织。当对容器中的元素进行插入或者删除时，操作之前的所有迭代器在操作之后依然有效。</p><p>set元素是排好序的，且默认为升序.</p><p><strong>set常用成员函数</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1. begin()--返回指向第一个元素的迭代器</span><br><span class="line">2. clear()--清除所有元素</span><br><span class="line">3. count()--返回某个值元素的个数</span><br><span class="line">4. empty()--如果集合为空，返回true</span><br><span class="line">5. end()--返回指向最后一个元素的迭代器</span><br><span class="line">6. equal_range()--返回集合中与给定值相等的上下限的两个迭代器</span><br><span class="line">7. erase()--删除集合中的元素</span><br><span class="line">8. find()--返回一个指向被查找到元素的迭代器</span><br><span class="line">9. get_allocator()--返回集合的分配器</span><br><span class="line">10. insert()--在集合中插入元素</span><br><span class="line">11. lower_bound()--返回指向大于（或等于）某值的第一个元素的迭代器</span><br><span class="line">12. key_comp()--返回一个用于元素间值比较的函数</span><br><span class="line">13. max_size()--返回集合能容纳的元素的最大限值</span><br><span class="line">14. rbegin()--返回指向集合中最后一个元素的反向迭代器</span><br><span class="line">15. rend()--返回指向集合中第一个元素的反向迭代器</span><br><span class="line">16. size()--集合中元素的数目</span><br><span class="line">17. swap()--交换两个集合变量</span><br><span class="line">18. upper_bound()--返回大于某个值元素的迭代器</span><br><span class="line">19. value_comp()--返回一个用于比较元素间的值的函数</span><br></pre></td></tr></table></figure><h4 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map&#x2F;multimap"></a>map&#x2F;multimap</h4><p>map和multimap都需要#include<map>，唯一的不同是，map的键值key不可重复，而multimap可以，也正是由于这种区别，map支持[ ]运算符，multimap不支持[ ]运算符，在用法上没什么区别。</p><p>map中的元素是自动按Key升序排序，所以不能对map用sort函数；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"> </span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; ID_Name;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用&#123;&#125;赋值是从c++11开始的，因此编译器版本过低时会报错，如visual studio 2012</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; ID_Name = &#123;</span><br><span class="line">                &#123; <span class="number">2015</span>, <span class="string">&quot;Jim&quot;</span> &#125;,</span><br><span class="line">                &#123; <span class="number">2016</span>, <span class="string">&quot;Tom&quot;</span> &#125;,</span><br><span class="line">                &#123; <span class="number">2017</span>, <span class="string">&quot;Bob&quot;</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基本操作函数</span></span><br><span class="line"><span class="built_in">begin</span>() 返回指向map头部的迭代器</span><br><span class="line"><span class="built_in">clear</span>(） 删除所有元素</span><br><span class="line"><span class="built_in">count</span>() 返回指定元素出现的次数</span><br><span class="line"><span class="built_in">empty</span>() 如果map为空则返回<span class="literal">true</span></span><br><span class="line"><span class="built_in">end</span>() 返回指向map末尾的迭代器</span><br><span class="line"><span class="built_in">equal_range</span>() 返回特殊条目的迭代器对</span><br><span class="line"><span class="built_in">erase</span>() 删除一个元素</span><br><span class="line"><span class="built_in">find</span>() 查找一个元素</span><br><span class="line"><span class="built_in">get_allocator</span>() 返回map的配置器</span><br><span class="line"><span class="built_in">insert</span>() 插入元素</span><br><span class="line"><span class="built_in">key_comp</span>() 返回比较元素key的函数</span><br><span class="line"><span class="built_in">lower_bound</span>() 返回键值&gt;=给定元素的第一个位置</span><br><span class="line"><span class="built_in">max_size</span>() 返回可以容纳的最大元素个数</span><br><span class="line"><span class="built_in">rbegin</span>() 返回一个指向map尾部的逆向迭代器</span><br><span class="line"><span class="built_in">rend</span>() 返回一个指向map头部的逆向迭代器</span><br><span class="line"><span class="built_in">size</span>() 返回map中元素的个数</span><br><span class="line"><span class="built_in">swap</span>() 交换两个map</span><br><span class="line"><span class="built_in">upper_bound</span>() 返回键值&gt;给定元素的第一个位置</span><br><span class="line"><span class="built_in">value_comp</span>() 返回比较元素value的函数</span><br></pre></td></tr></table></figure><p><strong>用insert插入pair数据</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//数据的插入--第一种：用insert函数插入pair数据  </span><br><span class="line">#include &lt;map&gt;    </span><br><span class="line">#include &lt;string&gt;  </span><br><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">  </span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    map&lt;int, string&gt; mapStudent;  </span><br><span class="line">    mapStudent.insert(pair&lt;int, string&gt;(1, &quot;student_one&quot;));  </span><br><span class="line">    mapStudent.insert(pair&lt;int, string&gt;(2, &quot;student_two&quot;));  </span><br><span class="line">    mapStudent.insert(pair&lt;int, string&gt;(3, &quot;student_three&quot;));  </span><br><span class="line">    map&lt;int, string&gt;::iterator iter;  </span><br><span class="line">    for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)  </span><br><span class="line">       cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>用insert函数插入value_type数据</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//第二种：用insert函数插入value_type数据，下面举例说明  </span><br><span class="line">  </span><br><span class="line">#include &lt;map&gt;    </span><br><span class="line">#include &lt;string&gt;    </span><br><span class="line">#include &lt;iostream&gt;    </span><br><span class="line">using namespace std;  </span><br><span class="line">  </span><br><span class="line">int main()    </span><br><span class="line">&#123;    </span><br><span class="line">    map&lt;int, string&gt; mapStudent;    </span><br><span class="line">    mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;));    </span><br><span class="line">    mapStudent.insert(map&lt;int, string&gt;::value_type (2, &quot;student_two&quot;));    </span><br><span class="line">    mapStudent.insert(map&lt;int, string&gt;::value_type (3, &quot;student_three&quot;));    </span><br><span class="line">    map&lt;int, string&gt;::iterator iter;    </span><br><span class="line">    for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)  </span><br><span class="line">         cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl;    </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>用数组方式插入数据</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//第三种：用数组方式插入数据，下面举例说明  </span><br><span class="line">  </span><br><span class="line">#include &lt;map&gt;    </span><br><span class="line">#include &lt;string&gt;    </span><br><span class="line">#include &lt;iostream&gt;    </span><br><span class="line">using namespace std;  </span><br><span class="line">  </span><br><span class="line">int main()    </span><br><span class="line">&#123;    </span><br><span class="line">    map&lt;int, string&gt; mapStudent;    </span><br><span class="line">    mapStudent[1] = &quot;student_one&quot;;   </span><br><span class="line">    mapStudent[2] = &quot;student_two&quot;;    </span><br><span class="line">    mapStudent[3] = &quot;student_three&quot;;    </span><br><span class="line">    map&lt;int, string&gt;::iterator iter;    </span><br><span class="line">    for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++)    </span><br><span class="line">        cout&lt;&lt;iter-&gt;first&lt;&lt;&#x27; &#x27;&lt;&lt;iter-&gt;second&lt;&lt;endl;    </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是插入数据不了的，但是用数组方式就不同了，它可以覆盖以前该关键字对应的值.</p><h3 id="STL容器适配器"><a href="#STL容器适配器" class="headerlink" title="STL容器适配器"></a>STL容器适配器</h3><p>适配器：是使一种事物的行为类似于另外一种事物行为的一种机制”，适配器对容器进行包装，使其表现出另外一种行为。例 如，stack&lt;int, vector<int> &gt;实现了栈的功能，但其内部使用顺序容器vector<int>来存储数据。（相当于是vector<int>表现出 了栈的行为）。</p><p>标准库提供了三种顺序容器适配器：queue(FIFO队列)、priority_queue(优先级队列)、stack(栈)</p><style>.dxuyjxqqkecy{zoom:67%;}</style><img src="/2024/03/11/cpp-%E5%B8%B8%E7%94%A8STL%E8%AE%B0%E5%BD%95/v2-42e902c425fdcdb4d0490edb8a35fa45_720w.webp" class="dxuyjxqqkecy" alt="img"><p>要使用适配器，需要加入一下头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span> <span class="comment">//stack</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span> <span class="comment">//queue、priority_queue</span></span></span><br></pre></td></tr></table></figure><h4 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h4><blockquote><p>小技巧：使用typedef定义 <code>typedef pair&lt;int, int&gt; PII</code></p></blockquote><p><strong>头文件</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>初始化</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//俩种方法初始化</span></span><br><span class="line"><span class="function">pair&lt;string,<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;hello&quot;</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">p = <span class="built_in">make_pair</span>(<span class="string">&quot;hello&quot;</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><strong>取值</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">p</span>(<span class="string">&quot;hello&quot;</span>,<span class="number">1</span>);</span><br><span class="line">p.first; <span class="comment">//第一个元素 =hello</span></span><br><span class="line">p.second; <span class="comment">//第二个元素 = 1</span></span><br></pre></td></tr></table></figure><p><strong>嵌套（套娃）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt; vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; &gt;<span class="comment">//与vector结合【再写个vector结合即可】</span></span><br><span class="line"><span class="comment">//套娃操作 用pair存储3个数据</span></span><br><span class="line"> pair&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">p</span>(<span class="number">1</span>,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">stack&lt; <span class="type">int</span>, vector&lt;<span class="type">int</span>&gt; &gt; stk;  <span class="comment">//覆盖基础容器类型，使用vector实现stk</span></span><br><span class="line">s.<span class="built_in">empty</span>();  <span class="comment">//判断stack是否为空，为空返回true，否则返回false</span></span><br><span class="line">s.<span class="built_in">size</span>();   <span class="comment">//返回stack中元素的个数</span></span><br><span class="line">s.<span class="built_in">pop</span>();    <span class="comment">//删除栈顶元素，但不返回其值</span></span><br><span class="line">s.<span class="built_in">top</span>();    <span class="comment">//返回栈顶元素的值，但不删除此元素</span></span><br><span class="line">s.<span class="built_in">push</span>(item);   <span class="comment">//在栈顶压入新元素item</span></span><br></pre></td></tr></table></figure><h4 id="queue-priority-queue"><a href="#queue-priority-queue" class="headerlink" title="queue &amp; priority_queue"></a>queue &amp; priority_queue</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q; <span class="comment">//priority_queue&lt;int&gt; q;</span></span><br><span class="line">q.<span class="built_in">empty</span>();  <span class="comment">//判断队列是否为空</span></span><br><span class="line">q.<span class="built_in">size</span>();   <span class="comment">//返回队列长度</span></span><br><span class="line">q.<span class="built_in">push</span>(item);   <span class="comment">//对于queue，在队尾压入一个新元素</span></span><br><span class="line">               <span class="comment">//对于priority_queue，在基于优先级的适当位置插入新元素</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//queue only:</span></span><br><span class="line">q.<span class="built_in">front</span>();  <span class="comment">//返回队首元素的值，但不删除该元素</span></span><br><span class="line">q.<span class="built_in">back</span>();   <span class="comment">//返回队尾元素的值，但不删除该元素</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//priority_queue only:</span></span><br><span class="line">q.<span class="built_in">top</span>();    <span class="comment">//返回具有最高优先级的元素值，但不删除该元素</span></span><br></pre></td></tr></table></figure><h3 id="string串"><a href="#string串" class="headerlink" title="string串"></a>string串</h3><p>参考：<a href="https://zhuanlan.zhihu.com/p/353910845">https://zhuanlan.zhihu.com/p/353910845</a></p><p>1、string构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>();<span class="comment">//创建一个空的字符串 例如: string str; </span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> string&amp; str);<span class="comment">//使用一个string对象初始化另一个string对象 </span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span>* s);<span class="comment">//使用字符串s初始化 </span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">int</span> n, <span class="type">char</span> c);<span class="comment">//使用n个字符c初始化 </span></span><br></pre></td></tr></table></figure><p>2、string基本赋值操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string&amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span>* s);<span class="comment">//char*类型字符串 赋值给当前的字符串 </span></span><br><span class="line">string&amp; <span class="keyword">operator</span>=(<span class="type">const</span> string &amp;s);<span class="comment">//把字符串s赋给当前的字符串 </span></span><br><span class="line">string&amp; <span class="keyword">operator</span>=(<span class="type">char</span> c);<span class="comment">//字符赋值给当前的字符串 </span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;<span class="comment">//把字符串s赋给当前的字符串 </span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> n)</span></span>;<span class="comment">//把字符串s的前n个字符赋给当前的字符串 </span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>;<span class="comment">//把字符串s赋给当前字符串 </span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> c)</span></span>;<span class="comment">//用n个字符c赋给当前字符串 </span></span><br><span class="line"><span class="function">string&amp; <span class="title">assign</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">int</span> start, <span class="type">int</span> n)</span></span>;<span class="comment">//将s从start开始n个字符赋值给字符串</span></span><br></pre></td></tr></table></figure><p>3、string存取字符操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> n);<span class="comment">//通过[]方式取字符 </span></span><br><span class="line"><span class="function"><span class="type">char</span>&amp; <span class="title">at</span><span class="params">(<span class="type">int</span> n)</span></span>;<span class="comment">//通过at方法获取字符</span></span><br></pre></td></tr></table></figure><p>4、string拼接操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> string&amp; str);<span class="comment">//重载+=操作符 </span></span><br><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span>* str);<span class="comment">//重载+=操作符 </span></span><br><span class="line">string&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span> c);<span class="comment">//重载+=操作符 </span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;<span class="comment">//把字符串s连接到当前字符串结尾 </span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> n)</span></span>;<span class="comment">//把字符串s的前n个字符连接到当前字符串结尾 </span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>;<span class="comment">//同operator+=() </span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">int</span> pos, <span class="type">int</span> n)</span></span>;<span class="comment">//把字符串s中从pos开始的n个字符连接到 当前字符串结尾 </span></span><br><span class="line"><span class="function">string&amp; <span class="title">append</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> c)</span></span>;<span class="comment">//在当前字符串结尾添加n个字符c</span></span><br></pre></td></tr></table></figure><p>5、string查找和替换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>; <span class="comment">//查找str第一次出现位置,从pos开始查找 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>; <span class="comment">//查找s第一次出现位置,从pos开始查找 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos, <span class="type">int</span> n)</span> <span class="type">const</span></span>; <span class="comment">//从pos位置查找s的前n个字符第一次位置 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>; <span class="comment">//查找字符c第一次出现位置 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//查找str最后一次位置,从pos开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos = npos)</span> <span class="type">const</span></span>;<span class="comment">//查找s最后一次出现位置,从pos开始查找 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">int</span> pos, <span class="type">int</span> n)</span> <span class="type">const</span></span>;<span class="comment">//从pos查找s的前n个字符最后一次位置 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c, <span class="type">int</span> pos = <span class="number">0</span>)</span> <span class="type">const</span></span>; <span class="comment">//查找字符c最后一次出现位置 </span></span><br><span class="line"><span class="function">string&amp; <span class="title">replace</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">const</span> string&amp; str)</span></span>; <span class="comment">//替换从pos开始n个字符为字符串 </span></span><br><span class="line"><span class="function">str string&amp; <span class="title">replace</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">const</span> <span class="type">char</span>* s)</span></span>; <span class="comment">//替换从pos开始的n个字符为字符串s</span></span><br></pre></td></tr></table></figure><p>6、string比较操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">compare函数在&gt;时返回 1，&lt;时返回 -1，==时返回 0。 </span></span><br><span class="line"><span class="comment">比较区分大小写，比较时参考字典顺序，排越前面的越小。 </span></span><br><span class="line"><span class="comment">大写的A比小写的a小。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> string &amp;s)</span> <span class="type">const</span></span>;<span class="comment">//与字符串s比较 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> <span class="type">const</span></span>;<span class="comment">//与字符串s比较</span></span><br></pre></td></tr></table></figure><p>7、string子串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">substr</span><span class="params">(<span class="type">int</span> pos = <span class="number">0</span>, <span class="type">int</span> n = npos)</span> <span class="type">const</span></span>;<span class="comment">//返回由pos开始的n个字符组成的字符串 </span></span><br></pre></td></tr></table></figure><p>8、string插入和删除操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">const</span> <span class="type">char</span>* s)</span></span>; <span class="comment">//插入字符串 </span></span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">const</span> string&amp; str)</span></span>; <span class="comment">//插入字符串 </span></span><br><span class="line"><span class="function">string&amp; <span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">char</span> c)</span></span>;<span class="comment">//在指定位置插入n个字符c </span></span><br><span class="line"><span class="function">string&amp; <span class="title">erase</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n = npos)</span></span>;<span class="comment">//删除从Pos开始的n个字符</span></span><br></pre></td></tr></table></figure><p>9、string和c-style字符串转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string 转 char* </span></span><br><span class="line">string str = <span class="string">&quot;itcast&quot;</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cstr = str.<span class="built_in">c_str</span>(); </span><br><span class="line"><span class="comment">//char* 转 string char* s = &quot;itcast&quot;; </span></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(s)</span></span>;</span><br></pre></td></tr></table></figure><p>在c++中存在一个从const char到<em>string</em>的隐式类型转换，却不存在从一个<em>string</em>对象到<em>C_string</em>的自动类 型转换。对于<em>string</em>类型的字符串，可以通过<em>c_str()<em>函数返回</em>string</em>对象对应的<em>C_string.</em> 通常，程序员在整个程序中应坚持使用<em>string</em>类对象，直到必须将内容转化为<em>char</em>时才将其转换为C_string.</p><h3 id="unordered哈希表"><a href="#unordered哈希表" class="headerlink" title="unordered哈希表"></a>unordered哈希表</h3><p>unordered_set，unordered_map，unordered_muliset,unordered_multimap</p><h3 id="ListNode线性链表"><a href="#ListNode线性链表" class="headerlink" title="ListNode线性链表"></a>ListNode线性链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ListNode* temp1 = <span class="keyword">new</span> Solution::<span class="built_in">ListNode</span>(<span class="number">0</span>); <span class="comment">//创建新元素，</span></span><br><span class="line">ListNode* l1 = temp1; <span class="comment">//最后的结果l1指向temp1，这样可以获取temp所接收的全部元素，而temp的指针由于每次都往下移，所以每次都更新</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((c = <span class="built_in">getchar</span>()) != <span class="string">&#x27;\n&#x27;</span>)   <span class="comment">//以空格区分各个结点的值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ungetc</span>(c, stdin);  <span class="comment">//把不是空格的字符丢回去</span></span><br><span class="line">                cin &gt;&gt; num;</span><br><span class="line">                Solution::ListNode* newnode = <span class="keyword">new</span> Solution::<span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">                newnode-&gt;val = num;<span class="comment">//创建新的结点存放键盘中读入的值</span></span><br><span class="line">                newnode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                temp2-&gt;next = newnode;<span class="comment">//并将其赋值给temp2</span></span><br><span class="line">                temp2 = newnode; <span class="comment">//此处也可以写成  temp2=temp2-&gt;next,使指针指向下一个，以待接收新元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="bitset位序列"><a href="#bitset位序列" class="headerlink" title="bitset位序列"></a>bitset位序列</h3><p>参考：<a href="https://zhuanlan.zhihu.com/p/607895839">https://zhuanlan.zhihu.com/p/607895839</a></p><p><code>std::bitset</code> 是 C++ 标准库中的一个类，用于表示二进制位序列。它提供了一种方便的方式来处理二进制数据，尤其适用于位运算操作。</p><p><code>std::bitset</code> 类型表示一个固定长度的位序列，每个位都只能是 0 或 1。这个固定长度在创建对象时指定，并且不能在运行时更改。类似于整数类型，<code>std::bitset</code> 支持多种操作，包括位运算、位查询和位设置。</p><p>创建方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::bitset&lt;N&gt; bitset1; <span class="comment">// 创建一个长度为 N 的 bitset，所有位都被初始化为 0</span></span><br><span class="line"><span class="function">std::bitset&lt;N&gt; <span class="title">bitset2</span><span class="params">(value)</span></span>; <span class="comment">// 使用二进制整数 value 初始化一个长度为 N 的 bitset</span></span><br><span class="line"><span class="function">std::bitset&lt;N&gt; <span class="title">bitset3</span><span class="params">(string)</span></span>; <span class="comment">// 使用二进制字符串 string 初始化一个长度为 N 的 bitset</span></span><br><span class="line"><span class="function">std::bitset&lt;N&gt; <span class="title">bitset4</span><span class="params">(bitset)</span></span>; <span class="comment">// 使用另一个 bitset 初始化一个长度为 N 的 bitset</span></span><br></pre></td></tr></table></figure><p>常用操作：</p><ul><li><code>size()</code> 返回 <code>std::bitset</code> 的长度</li><li><code>count()</code> 返回 <code>std::bitset</code> 中值为 1 的位的数量</li><li><code>any()</code> 返回 <code>std::bitset</code> 中是否存在值为 1 的位</li><li><code>none()</code> 返回 <code>std::bitset</code> 中是否所有位都是 0</li><li><code>all()</code> 返回 <code>std::bitset</code> 中是否所有位都是 1</li><li><code>test(pos)</code> 返回 <code>std::bitset</code> 中位于 <code>pos</code> 位置的值</li><li><code>set(pos)</code> 将 <code>std::bitset</code> 中位于 <code>pos</code> 位置的值设为 1</li><li><code>reset(pos)</code> 将 <code>std::bitset</code> 中位于 <code>pos</code> 位置的值设为 0</li><li><code>flip(pos)</code> 将 <code>std::bitset</code> 中位于 <code>pos</code> 位置的值取反</li><li><code>to_ulong()</code> 返回 <code>std::bitset</code> 转换成的无符号整数值</li><li><code>to_ullong()</code> 返回 <code>std::bitset</code> 转换成的无符号长整数值</li></ul><h2 id="STL迭代器"><a href="#STL迭代器" class="headerlink" title="STL迭代器"></a>STL迭代器</h2><p>Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。</p><p>迭代器的作用：能够让迭代器与算法不干扰的相互发展，最后又能无间隙的粘合起来，重载了*，＋＋，＝＝，！＝，＝运算符，用以操作复杂的数据结构。</p><p>容器提供迭代器，算法使用迭代器；常见的一些迭代器类型：iterator、const_iterator、reverse_iterator和const_reverse_iterator.</p><h2 id="STL算法"><a href="#STL算法" class="headerlink" title="STL算法"></a>STL算法</h2><p>STL中算法大致分为四类：</p><ul><li>非可变序列算法：指不直接修改其所操作的容器内容的算法。</li><li>可变序列算法：指可以修改它们所操作的容器内容的算法。</li><li>排序算法：对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。</li><li>数值算法：对容器内容进行数值计算。</li></ul><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><p>参考：<a href="https://blog.csdn.net/weixin_49486457/article/details/123439229?spm=1001.2014.3001.5502">https://blog.csdn.net/weixin_49486457/article/details/123439229?spm=1001.2014.3001.5502</a></p><p>①、sort();【具有和快排一样的速度】</p><p><code>时间复杂度O (n*logn)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a,a+<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="built_in">sort</span>(a,a+<span class="number">5</span>);<span class="comment">//搭配数组  从小到大排序</span></span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>②__gcd() 最大公约数<br><a href="https://www.acwing.com/problem/content/3645/">最大公约数小题</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="type">int</span> k=__gcd(n,m);<span class="comment">//最大公约数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n * m / k); <span class="comment">//最小公倍数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③max()、min()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(a,b);<span class="comment">//返回最大值</span></span><br><span class="line"><span class="built_in">min</span>(a,b);<span class="comment">//返回最小值</span></span><br></pre></td></tr></table></figure><p>④swap()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(a,b);<span class="comment">//交换a和b</span></span><br></pre></td></tr></table></figure><p>⑤lower_bound()与upper_bound()【二分查找】</p><ul><li><p>ower bound()返回数组中第一个大于等于x的数的地址：</p></li><li><p>upper bound()返回数组中第一个大于x的数的地址</p></li><li><p>将得到的地址减去数组的起始地址可得在数组中的下标</p></li></ul><p>⑥reverse() 【倒置】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ector&lt;<span class="type">int</span>&gt; v=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());<span class="comment">//v的值为5，4，3，2，1  倒置</span></span><br></pre></td></tr></table></figure><p>⑦find()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，</span></span><br><span class="line"><span class="comment">//若存在返回其在向量中的位置</span></span><br><span class="line"><span class="built_in">find</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>⑧、erase()【删除】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从c中删除迭代器p指定的元素，p必须指向c中的一个真实元素，不能等于c.end()</span></span><br><span class="line">c.<span class="built_in">erase</span>(p)</span><br><span class="line"><span class="comment">//从c中删除迭代器对b和e所表示的范围中的元素，返回e</span></span><br><span class="line">c.<span class="built_in">erase</span>(b,e)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><ol><li>《大话数据结构》</li><li><a href="https://zhuanlan.zhihu.com/p/367994409">https://zhuanlan.zhihu.com/p/367994409</a></li></ol><style>.scnjkkursbqg{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/v2-e622b14996ed587ac2f4c55fecb29a01_r.jpg" class="scnjkkursbqg" alt="img"><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><style>.sbpejdjvugox{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310161519521.png" class="sbpejdjvugox" alt="image-20240310161519521"><p>数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。</p><p>数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</p><p>数据项：一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。</p><p>数据对象：是性质相同的数据元素的集合，是数据的子集。</p><p>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。</p><style>.vfsjwehpvyib{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310155737190.png" class="vfsjwehpvyib" alt="image-20240310155737190"><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><style>.jiystqnnshct{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310161607775.png" class="jiystqnnshct" alt="image-20240310161607775"><p>数据结构分为逻辑结构和物理结构。逻辑结构是面向问题的，而物理结构就是面向计算机的。</p><p>逻辑结构：是指数据对象中数据元素之间的相互关系。</p><p>集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。各个数据元素是“<strong>平等</strong>”的，它们的共同属性是“同属于一个集合”。</p><style>.oqxvnxcucuhn{zoom:50%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310160310087.png" class="oqxvnxcucuhn" alt="image-20240310160310087"><p>线性结构：线性结构中的数据元素之间是<strong>一对一</strong>的关系。</p><style>.vgehqrqrfqla{zoom: 50%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310160339904.png" class="vgehqrqrfqla" alt="image-20240310160339904"><p>树形结构：树形结构中的数据元素之间存在一种<strong>一对多</strong>的层次关系。</p><style>.lmwpdxhibtav{zoom: 50%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310160412687.png" class="lmwpdxhibtav" alt="image-20240310160412687"><p>图形结构：图形结构的数据元素是<strong>多对多</strong>的关系。</p><style>.orbmmwdgrfzh{zoom:50%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310160455376.png" class="orbmmwdgrfzh" alt="image-20240310160455376"><h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><p>物理结构：也叫做存储结构，是指数据的逻辑结构在计算机中的存储形式。数据元素的存储结构形式有两种：顺序存储和链式存储。</p><p>顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。</p><style>.ugvffpsdxxwh{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310160940182.png" class="ugvffpsdxxwh" alt="image-20240310160940182"><p>链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置。</p><style>.gxtgvbkvndbx{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310161027975.png" class="gxtgvbkvndbx" alt="image-20240310161027975"><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><style>.dfuulpyuhnwf{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310193019556.png" class="dfuulpyuhnwf" alt="image-20240310193019556"><p>线性表(List)：零个或多个数据元素的有限序列。</p><p>特点：元素之间是有<strong>顺序</strong>的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其他每个元素都有且只有一个前驱和后继；线性表强调是<strong>有限</strong>的。</p><style>.hqdcuiaqgqjz{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310164927949.png" class="hqdcuiaqgqjz" alt="image-20240310164927949"><h4 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><p>线性表的抽象数据类型定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT线性表(List)</span><br><span class="line">Data</span><br><span class="line">线性表的数据对象集合为&#123;a1,a2,,an&#125;,每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。</span><br><span class="line">Operation</span><br><span class="line">    <span class="title function_">InitList</span><span class="params">(*L)</span>:初始化操作，建立一个空的线性表工。</span><br><span class="line">    <span class="title function_">ListEmpty</span><span class="params">(L)</span>:若线性表为空，返回<span class="literal">true</span>,否则返回<span class="literal">false</span>。</span><br><span class="line"><span class="title function_">ClearList</span><span class="params">(*L)</span>:将线性表清空。</span><br><span class="line">    <span class="title function_">GetElem</span><span class="params">(L,i,*e)</span>:将线性表工中的第i个位置元素值返回给e。</span><br><span class="line">    <span class="title function_">LocateElem</span><span class="params">(L,e)</span>:在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回0表示失败。</span><br><span class="line">    <span class="title function_">ListInsert</span><span class="params">(*L,<span class="number">1</span>,e)</span>:在线性表L中的第i个位置插入新元素e。</span><br><span class="line">    <span class="title function_">ListDelete</span><span class="params">(*L,i,*e)</span>:删除线性表L中第i个位置元素，并用e返回其值。</span><br><span class="line">    <span class="title function_">ListLength</span><span class="params">(L)</span>:返回线性表工的元素个数。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><p>对于不同的应用，线性表的基本操作是不同的，上述操作是最基本的，对于实际问题中涉及的关于线性表的更复杂操作，完全可以用这些基本操作的组合来实现。</p><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><p>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p><p>线性表的顺序存储的结构代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 20<span class="comment">/*存储空间初始分配量*/</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;<span class="comment">/*ElemType类型根据实际情况而定，这里假设为int*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data[MAXSIZE];<span class="comment">/*数组存储数据元素，最大值为MAXSIZE*/</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">/*线性表当前长度*/</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><p>描述顺序存储结构需要三个属性：</p><ul><li>存储空间的起始位置：数组data,它的存储位置就是存储空间的存储位置。</li><li>线性表的最大存储容量：数组长度MaxSize</li><li>线性表的当前长度：length。</li></ul><p>线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是O(1)；而插入或删除时，时间复杂度都是O(n)。这就说明，它比较适合元素个数不太变化，而更多是存取数据的应用。</p><style>.tevtcahokcjf{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310171643911.png" class="tevtcahokcjf" alt="image-20240310171643911"><h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h4><p>把存储数据元素信息的域称为<strong>数据域</strong>，把存储直接后继位置的域称为<strong>指针域</strong>。指针域中存储的信息称做指针或链。这两部分信息组成数据元素的存储映像，称为<strong>结点</strong>(Node)。</p><p>n个结点链结成一个链表，即为线性表(a1,a2,…,an)的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做<strong>单链表</strong>。</p><style>.bbkphwcxbfkv{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310172014096.png" class="bbkphwcxbfkv" alt="image-20240310172014096"><p>链表中第一个结点的存储位置叫做头指针，最后一个结点指针为“空”（通常用NULL或“”符号表示）。</p><style>.ffwyegkgljac{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310172154481.png" class="ffwyegkgljac" alt="image-20240310172154481"><p>为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针。</p><style>.ytapdeagamwy{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310172335921.png" class="ytapdeagamwy" alt="image-20240310172335921"><p>单链表中，在C语言中可用结构指针来描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*线性表的单链表存储结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span><span class="comment">/*LinkList*/</span></span><br></pre></td></tr></table></figure><p>从整个算法推导出：单链表插入和删除的时间复杂度都是O(n)。如果在不知道第ⅰ个元素的指针位置，单链表数据结构在插入和删除操作上，与线性表的顺序存储结构是没有太大优势的。但如果，我们希望从第ⅰ个位置，插入10个元素，对于顺序存储结构意味着，每一次插入都需要移动n-1个元素，每次都是O(n)。而单链表，我们只需要在第一次时，找到第1个位置的指针，此时为O(n)，接下来只是简单地通过赋值移动指针而已，时间复杂度都是O(1)。显然，<strong>对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显</strong>。</p><p>单链表初始化可以分为头插法和尾插法。</p><h4 id="优缺点对比"><a href="#优缺点对比" class="headerlink" title="优缺点对比"></a>优缺点对比</h4><style>.ktwotvaylhld{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310185256076.png" class="ktwotvaylhld" alt="image-20240310185256076"><p>通过上面的对比，我们可以得出一些经验性的结论：</p><ul><li>若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。</li><li>当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。而如果事先知道线性表的大致长度，比如一年12个月，一周就是星期一至星期日共七天，这种用顺序存储结构效率会高很多。</li></ul><h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><p>一般来说，静态链表其实是为了给没有指针的高级语言设计的一种<u>实现单链表</u>能力的方法。</p><p>静态链表：数组的元素都是由两个数据域组成，data和cur。数据域data，用来存放数据元素；而游标cur相当于单链表中的next指针，存放该元素的后继在数组中的下标。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*线性表的静态链表存储结构*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1000<span class="comment">/*假设链表的最大长度是1000*/</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> cur;<span class="comment">/*游标（Cursor),为0时表示无指向*/</span></span><br><span class="line">&#125;Component,StaticLinkList [MAXSIZE];</span><br></pre></td></tr></table></figure><style>.dljpuuvmygqa{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310191237396.png" class="dljpuuvmygqa" alt="image-20240310191237396"><style>.urmotfhceute{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310191436110.png" class="urmotfhceute" alt="image-20240310191436110"><p>对数组第一个和最后一个元素作为特殊元素处理，不存数据。数组第一个元素，即下标为0的元素的cur就存放备用链表的第一个结点的下标；而数组的最后一个元素的cur则存放第一个有数值的元素的下标，相当于单链表中的头结点作用，当整个链表为空时，则为0。通常把未被使用的数组元素称为备用链表。</p><style>.aiwyhednslip{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310191841055.png" class="aiwyhednslip" alt="image-20240310191841055"><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p>循环链表（circular linked list)：将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表。</p><style>.aoycuoctimmg{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310192613955.png" class="aoycuoctimmg" alt="image-20240310192613955"><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>双向链表(double linked list)：在单链表的每个结点中，再设置一个指向其前驱结点的指针域。所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*线性表的双向链表存储结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">prior</span>;</span><span class="comment">/*直接前驱指针*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">next</span>;</span><span class="comment">/*直接后继指针*/</span></span><br><span class="line">&#125;DulNode,*DuLinkList;</span><br></pre></td></tr></table></figure><style>.apjhgviyvyms{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310192911127.png" class="apjhgviyvyms" alt="image-20240310192911127"><h3 id="线性表的特殊形式"><a href="#线性表的特殊形式" class="headerlink" title="线性表的特殊形式"></a>线性表的特殊形式</h3><h4 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h4><style>.ddhmugklhaqs{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310200725374.png" class="ddhmugklhaqs" alt="image-20240310200725374"><h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>栈是限定<u>仅在表尾进行插入和删除操作</u>的<strong>线性表</strong>。</p><p>把允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom)，不含任何数据元素的栈称为空栈。栈又称为后进先出(Last In First Out)的线性表，简称LIF0结构。</p><p>是在线性表的表尾进行插入和删除操作，这里表尾是指栈顶，而不是栈底。</p><p>栈的插入操作，叫作进栈，也称压栈、入栈。栈的删除操作，叫作出栈，也有的叫作弹栈。</p><style>.merlwwcejmwu{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310193755011.png" class="merlwwcejmwu" alt="image-20240310193755011"><p><strong>抽象数据类型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT栈(<span class="built_in">stack</span>)</span><br><span class="line">Data</span><br><span class="line">同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line">    <span class="title function_">InitStack</span><span class="params">(*S)</span>:初始化操作，建立一个空栈S。</span><br><span class="line">    <span class="title function_">DestroyStack</span><span class="params">(*S)</span>:若栈存在，则销毁它。</span><br><span class="line">    <span class="title function_">ClearStack</span><span class="params">(*S)</span>:将栈清空。</span><br><span class="line">    <span class="title function_">StackEmpty</span><span class="params">(S)</span>:若栈为空，返回<span class="literal">true</span>,否则返回<span class="literal">false</span>。</span><br><span class="line">    <span class="title function_">GetTop</span><span class="params">(S,*e)</span>:若栈存在且非空，用e返回S的栈顶元素。</span><br><span class="line">    <span class="title function_">Push</span><span class="params">(*S,e)</span>:若栈S存在，插入新元素e到栈S中并成为栈顶元素。</span><br><span class="line">    <span class="title function_">Pop</span><span class="params">(*S,*e)</span>:刷除栈S中栈顶元素，并用e返回其值。</span><br><span class="line">    <span class="title function_">StackLength</span><span class="params">(s)</span>：返回栈s的元素个数。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><p><strong>顺序存储空间</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SElemType;<span class="comment">/*SElemType类型根据实际情况而定，这里假设为int*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType data [MAXSIZE];</span><br><span class="line">    <span class="type">int</span> top;<span class="comment">/*用于栈顶指针*/</span></span><br><span class="line">)SqStack;</span><br></pre></td></tr></table></figure><p><strong>两栈共享空间</strong></p><p>如果有两个相同类型的栈，为它们各自开辟了数组空间，极有可能是第一个栈已经满了，再进栈就溢出了，而另一个栈还有很多存储空间空闲。可以用一个数组来存储两个栈。</p><p>数组有两个端点，两个栈有两个栈底，让一个栈的栈底为数组的始端，即下标为0处，另一个栈为数组的末端，即下标为数组长度n-1处。这样，两个栈如果增加元素，就是两端点向中间延伸。</p><style>.wnwfkbkrhnpo{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310194413443.png" class="wnwfkbkrhnpo" alt="image-20240310194413443"><p><strong>链式存储结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode,*LinkstackPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linkstack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LinkStackPtr top;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;Linkstack;</span><br></pre></td></tr></table></figure><p>链式存储结构简称为链栈。由于栈只是栈顶来做插入和删除操作，一般把栈顶放在单链表的头部。且栈顶在头部了，单链表中比较常用的头结点也就失去了意义，通常对于链栈来说，是不需要头结点的。</p><style>.prvsebkqjsmf{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310195044901.png" class="prvsebkqjsmf" alt="image-20240310195044901"><h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>队列是只允许在一端进行插入操作、而在另一端进行删除操作的<strong>线性表</strong>。</p><p>队列是一种先进先出(First In First Out)的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。</p><style>.xsyqrktmkwhd{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310195623075.png" class="xsyqrktmkwhd" alt="image-20240310195623075"><p><strong>抽象数据类型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT队列(Queue)</span><br><span class="line">Data</span><br><span class="line">同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line">    <span class="title function_">InitQueue</span><span class="params">(*Q)</span>:初始化操作，建立一个空队列Q。</span><br><span class="line">    <span class="title function_">DestroyQueue</span><span class="params">(*Q)</span>：若队列Q存在，则销毁它。</span><br><span class="line">    <span class="title function_">c1earQueue</span><span class="params">(*Q)</span>:将队列Q清空。</span><br><span class="line">    <span class="title function_">QueueEmpty</span><span class="params">(Q)</span>:若队列Q为空，返回<span class="literal">true</span>,否则返回<span class="literal">false</span>。</span><br><span class="line">    <span class="title function_">GetHead</span><span class="params">(Q,*e)</span>:若队列Q存在且非空，用e返回队列Q的队头元素。</span><br><span class="line">    <span class="title function_">EnQueue</span><span class="params">(*Q,e)</span>:若队列Q存在，插入新元素e到队列Q中并成为队尾元素。</span><br><span class="line">    <span class="title function_">DeQueue</span><span class="params">(*Q,*e)</span>:刷除队列Q中队头元素，并用e返回其值。</span><br><span class="line">    <span class="title function_">QueueLength</span><span class="params">(Q)</span>:返回队列Q的元素个数</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><p><strong>顺序存储结构——循环队列</strong></p><p>把队列的这种头尾相接的顺序存储结构称为循环队列，解决“假溢出”问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;<span class="comment">/*QElemType类型根据实际情况而定，这里假设为int*/</span></span><br><span class="line"><span class="comment">/*循环队列的顺序存储结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType data [MAXSIZE];</span><br><span class="line">    <span class="type">int</span> front;<span class="comment">/*头指针*/</span></span><br><span class="line">    <span class="type">int</span> rear;<span class="comment">/*尾指针，若队列不空，指向队列尾元素的下一个位置*/</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><p><strong>链式存储结构</strong></p><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，简称为链队列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;<span class="comment">/*QElemType类型根据实际情况而定，这里假设为int*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>/*结，点结构*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,*Queueptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>/*队列的链表结构*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QueuePtr front,rear;<span class="comment">/*队头、队尾指针*/</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><h4 id="串"><a href="#串" class="headerlink" title="串"></a>串</h4><p>串(string)是由零个或多个字符组成的有限序列，又名叫字符串。</p><p>空串：零个字符的串称为空串(null string)，它的长度为零，可以直接用两双引号““””表示。</p><p>空格串：是只包含空格的串。注意它与空串的区别，空格串是有内容有长度的，而且可以不止一个空格。</p><p>子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含子串的串称为主串。子串在主串中的位置就是子串的第一个字符在主串中的序号。</p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><style>.ykvyrjaypnpm{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310212604183.png" class="ykvyrjaypnpm" alt="image-20240310212604183"><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>树(Tree)是n(n≥0)个结点的有限集。n&#x3D;0时称为空树。在任意一棵非空树中：（1)有且仅有一个特定的称为根（Root)的结点；(2)当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1、T2、…、Tm,其中每一个集合本身又是一棵树，并且称为根的子树(SubTree)，如图6-2-1所示。</p><style>.oyorvzuhobyr{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310212118317.png" class="oyorvzuhobyr" alt="image-20240310212118317"><p>树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为结点的度(Degree)。度为0的结点称为叶结点(Leaf)或终端结点；度不为0的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。</p><p>结点的子树的根称为该结点的孩子(Child)，相应地，该结点称为孩子的双亲(Parent))。同一个双亲的孩子之间互称兄弟(Sibling)。结点的祖先是从根到该结点所经分支上的所有结点。所以对于H来说，D、B、A都是它的祖先。反之，以某结点为根的子树中的任一结点都称为该结点的子孙。</p><style>.kdcijgkcxkrk{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310212407672.png" class="kdcijgkcxkrk" alt="image-20240310212407672"><p>结点的层次(Level)从根开始定义起，根为第一层，根的孩子为第二层。若某结点在第l层，则其子树的根就在第l+1层。其双亲在同一层的结点互为堂兄弟。显然图6-2-6中的D、E、F是堂兄弟，而G、H、I、J也是。树中结点的最大层次称为树的深度(Depth)或高度，当前树的深度为4。</p><style>.ccbvuwphoudd{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310212501552.png" class="ccbvuwphoudd" alt="image-20240310212501552"><p>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。</p><p>森林(Forest)是m(m&gt;≥0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。</p><h4 id="树的抽象数据类型"><a href="#树的抽象数据类型" class="headerlink" title="树的抽象数据类型"></a>树的抽象数据类型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ADT树(tree)</span><br><span class="line">Data</span><br><span class="line">树是由一个根结点和若干棵子树构成。树中结点具有相同数据类型及层次关系。</span><br><span class="line">Operation</span><br><span class="line">    <span class="title function_">InitTree</span><span class="params">(*T)</span>:构造空树T。</span><br><span class="line">    <span class="title function_">DestroyTree</span><span class="params">(*T)</span>:销毁树T。</span><br><span class="line">    <span class="title function_">CreateTree</span><span class="params">(*T,definition)</span>:按definition中给出树的定义来构造树。</span><br><span class="line">    <span class="title function_">ClearTree</span><span class="params">(*T)</span>：若树T存在，则将树T清为空树。</span><br><span class="line">    <span class="title function_">TreeEmpty</span><span class="params">(T)</span>:若T为空树，返回<span class="literal">true</span>,否则返回<span class="literal">false</span>。</span><br><span class="line">    <span class="title function_">TreeDepth</span><span class="params">(T)</span>:返回T的深度。</span><br><span class="line">    <span class="title function_">Root</span><span class="params">(T)</span>:返回T的根结点。</span><br><span class="line">    <span class="title function_">Value</span><span class="params">(T,cure)</span>:cure是树T中一个结，点，返回此结，点的值。</span><br><span class="line">    <span class="title function_">Assign</span><span class="params">(T,cure,value)</span>:给树T的结点cure赋值为value。</span><br><span class="line">    <span class="title function_">Parent</span><span class="params">(T,cure)</span>：若cure是树T的非根结点，则返回它的双亲，否则返回空。</span><br><span class="line">    <span class="title function_">LeftChild</span><span class="params">(T,cure)</span>：若cure是树T的非叶结点，则返回它的最左孩子，否则返回空。</span><br><span class="line">    <span class="title function_">Rightsibling</span><span class="params">(T,cure)</span>:若cure有右兄弟，则返回它的右兄弟，否则返回空。</span><br><span class="line">    <span class="title function_">InsertChild</span><span class="params">(*T,*p,i,c)</span>:其中p指向树T的某个结点，i为所指结，点p的度加上1，非空树c与T不相交，操作结果为插入c为树T中P指结点的第i棵子树。</span><br><span class="line">    <span class="title function_">DeleteChild</span><span class="params">(*T,*p,i)</span>：其中p指向树T的某个结，点，i为所指结点p的度，操作结果为删除T中p所指结，点的第i棵子树。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h4 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><h5 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h5><p>假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点到链表中的位置。也就是说，每个结点除了知道自己是谁以外，还知道它的双亲在哪里。</p><style>.utfwekhablqu{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310212931093.png" class="utfwekhablqu" alt="image-20240310212931093"><p>其中data是数据域，存储结点的数据信息。而parent是指针域，存储该结点的双亲在数组中的下标。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*树的双亲表示法结，点结构定义*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX TREE SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> TElemType;<span class="comment">/*树结点的数据类型，目前暂定为整型*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span>/*结，点结构*/</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;<span class="comment">/*结，点数据*/</span></span><br><span class="line">    <span class="type">int</span> parent;<span class="comment">/*双亲位置*/</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*树结构*/</span></span><br><span class="line">    PTNode nodes[MAX TREE SIZE];<span class="comment">/*结，点数组*/</span></span><br><span class="line">    <span class="type">int</span> r,n;<span class="comment">/*根的位置和结，点数*/</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240320080831747.png" class="" title="image-20240320080831747"><p>这样的存储结构，可以根据结点的 parent 指针很容易找到它的双亲结点，所用的时间复杂度为 0(1), 直到 parent为 -1 时，表示找到了树结点的根。可如果要知道结点的孩子是什么，需要遍历整个结构才行。改进，增加一个结点最左边孩子的域：</p><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240320081150897.png" class="" title="image-20240320081150897"><h5 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h5><p>由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法。不过，树的每个结点的度，也就是它的孩子个数是不同的。可以设计两种方案来解决。</p><p><strong>方案一</strong></p><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240320080635070.png" class="" title="image-20240320080635070"><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240320080725073.png" class="" title="image-20240320080725073"><p>这种方法对于树中各结点的度相差很大时，显然是很浪费空间的，因为有很多的结点，它的指针域都是空的。</p><p><strong>方案二</strong></p><p>第二种方案每个结点指针域的个数等于该结点的度。</p><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240320081418221.png" class="" title="image-20240320081418221"><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240320081439091.png" class="" title="image-20240320081439091"><p><strong>孩子表示法</strong></p><p>具体办法是，把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。为此设计两种结点结构，一个是孩子链表的孩子结点，另一个是表头数组的表头结点：</p><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240320081822288.png" class="" title="image-20240320081822288"><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240320081833919.png" class="" title="image-20240320081833919"><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240320081601095.png" class="" title="image-20240320081601095"><h5 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h5><p>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">／＊树的孩子兄弟表示法结构定义＊／</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">rightsib</span>;</span> </span><br><span class="line">) CSNode,*CSTree;</span><br></pre></td></tr></table></figure><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240320082142357.png" class="" title="image-20240320082142357"><p>这个表示法的最大好处是它把一棵复杂的树变成了一棵二叉树。</p><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>二叉树(Binary Tree)是n(n≥0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</p><p>二叉树的特点有：</p><ul><li>每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。注意不是<br>  只有两棵子树，而是最多有。没有子树或者有一棵子树都是可以的。</li><li>左子树和右子树是有顺序的，次序不能任意颠倒。</li><li>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。下图中，树1和树2是同一棵树，但它们却是不同的二叉树。就好像你一不小心，摔伤了手，伤的是左手还是右手，对你的生活影响度是完全不同的。</li></ul><style>.uqlzpziavflf{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240311152344220.png" class="uqlzpziavflf" alt="image-20240311152344220"><p>满二叉树：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。</p><style>.ijdliotylnus{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240311155009325.png" class="ijdliotylnus" alt="image-20240311155009325"><p>完全二叉树：对一棵具有n个结点的二叉树按层序编号，如果编号为i(1≤i≤)的结点与同样深度的满二叉树中编号为1的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。</p><style>.vonqughaeuyp{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240311155123367.png" class="vonqughaeuyp" alt="image-20240311155123367"><h5 id="二叉树性质"><a href="#二叉树性质" class="headerlink" title="二叉树性质"></a>二叉树性质</h5><h5 id="二叉树存储结构"><a href="#二叉树存储结构" class="headerlink" title="二叉树存储结构"></a>二叉树存储结构</h5><h6 id="二叉树顺序存储结构"><a href="#二叉树顺序存储结构" class="headerlink" title="二叉树顺序存储结构"></a><strong>二叉树顺序存储结构</strong></h6><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240320082409494.png" class="" title="image-20240320082409494"><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240320082420080.png" class=""><h6 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a><strong>二叉链表</strong></h6><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240320082734688.png" class="" title="image-20240320082734688"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">／＊二叉树的二叉链表结点结构定义＊／</span><br><span class="line">ypedef <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> /*结点结构＊／</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data; <span class="comment">/*结点数据＊／</span></span><br><span class="line"><span class="comment">    struct BiTNode *lchild, *rchild; /*左右孩子指针＊／</span></span><br><span class="line"><span class="comment">) BiTNode, *BiTree;</span></span><br></pre></td></tr></table></figure><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240320082821050.png" class="" title="image-20240320082821050"><p>如果有需要，还可以再增加一个指向其双亲的指针域，那样就称之为<strong>三叉链表</strong>。</p><h5 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h5><h6 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h6><p>若二叉树为空，则空操作返回；否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。</p><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240320083038647.png" class="" title="image-20240320083038647"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*二叉树的前序遍历递归算法*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrderTraverse</span> <span class="params">(BiTree T)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (T==<span class="literal">NULL</span>) </span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%c&quot;</span>, T-&gt;data) ; <span class="comment">/*显示结点数据，可以更改为其他对结点操作*/</span></span><br><span class="line">    PreOrderTraverse (T-&gt;lchild) ; <span class="comment">/*再先序遍历左子树＊／</span></span><br><span class="line"><span class="comment">    PreOrderTraverse (T-&gt;rchild) ; / *最后先序遍历右子树＊／</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h6 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h6><p>若树为空，则空操作返回；否则从根结点开始（注意并不是先访问根结点），先遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。</p><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240320083052047.png" class="" title="image-20240320083052047"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的中序遍历递归算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse</span> <span class="params">(Bi Tree T)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (T==<span class="literal">NULL</span>) </span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">    InOrderTraverse(T-&gt;lchild) ; <span class="comment">/*中序遍历左子树＊／</span></span><br><span class="line"><span class="comment">    printf (&quot;耘&quot;, T-&gt;data) ; /*显示结点数据，可以更改为其他对结点操作＊／</span></span><br><span class="line"><span class="comment">    InOrderTraverse (T-&gt;rchild) ; /*最后中序遍历右子树＊／</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>已知前序和中序遍历，可以确定一棵二叉树。</p><h6 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h6><p>若树为空，则空操作返回；否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。</p><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240320083104576.png" class="" title="image-20240320083104576"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">／＊二叉树的后序遍历递归算法＊／</span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrderTraverse</span> <span class="params">(Bi Tree T)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (T==<span class="literal">NULL</span>) </span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">    PostOrderTraverse (T-&gt;lchild) ; <span class="comment">/*先后序遍历左子树＊／</span></span><br><span class="line"><span class="comment">    PostOrderTraverse (T-&gt;rchild) ; /*再后序遍历右子树＊／</span></span><br><span class="line"><span class="comment">    printf (&quot;釭&quot;, T-&gt;data) ; /*显示结点数据，可以更改为其他对结点操作＊／</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>已知前序和后序遍历，不能确定一棵二叉树。</p><h6 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h6><p>若树为空，则空操作返回；否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问 。</p><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240320083555934.png" class="" title="image-20240320083555934"><h5 id="二叉树建立"><a href="#二叉树建立" class="headerlink" title="二叉树建立"></a>二叉树建立</h5><p>为了能让每个结点确认是否有左右孩子，对它进行扩展。也就是将二叉树中每个结点的空指针引出一个虚结点，其值为一特定值，比如”#”。我们称这种处理后的二叉树为原二叉树的扩展二叉树。扩展二叉树就可以做到一个遍历序列确定一棵二叉树了。</p><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240320084713563.png" class="" title="image-20240320084713563"><h5 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h5><p>图中现指针域并不是都充分的利用了，有许多的”&#x2F;\“，也就是空指针域的存在，可以想办法利用起来。</p><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240320084809464.png" class="" title="image-20240320084809464"><p>可以考虑利用那些空地址，存放指向结点在某种遍历次序下的前驱和后继结点的地址。这种指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树(Threaded Binary Tree)。</p><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240320085041235.png" class="" title="image-20240320085041235"><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>图(Graph)是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E),其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。</p><p>略。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><h4 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h4><p>算法：是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p><p>算法的基本特性：输入（零个或多个输入）、输出（至少有一个或多个）、有穷性、确定性和可行性。有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。确定性：算法的每一步骤都具有确定的含义，不会出现二义性。可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。可行性意味着算法可以转换为程序上机运行，并得到正确的结果。</p><p>算法的设计要求：正确性、可读性、健壮性、高效率和低存储量需求。</p><h4 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><p>算法效率的度量方法。事后统计方法：这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算。</p><p>算法的度量方法：事后统计方法（不科学、不准确）、事前分析估算方法。</p><p>算法的时间复杂度，也就是算法的时间量度，记作：T[n]&#x3D;O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。</p><p>用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。推导大O阶：</p><ol><li>用常数1取代运行时间中的所有加法常数。</li><li>在修改后的运行次数函数中，只保留最高阶项。</li><li>如果最高阶项存在且不是1，则去除与这个项相乘的常数。得到的结果就是大O阶。</li></ol><style>.lrinkuuunioy{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310164109629.png" class="lrinkuuunioy" alt="image-20240310164109629"><h4 id="算法空间复杂度"><a href="#算法空间复杂度" class="headerlink" title="算法空间复杂度"></a>算法空间复杂度</h4><p>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)&#x3D;O(f(n),其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。</p><p>通常，我们都使用“时间复杂度”来指运行时间的需求，使用“空间复杂度”指空间需求。当不用限定词地使用“复杂度”时，通常都是指时间复杂度。</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>参考：<a href="https://www.cnblogs.com/maybe2030/p/4715035.html#top">https://www.cnblogs.com/maybe2030/p/4715035.html#top</a></p><p><strong>查找算法分类：</strong></p><p>1）静态查找和动态查找；</p><p>注：静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。</p><p>2）无序查找和有序查找。</p><p>无序查找：被查找数列有序无序均可； 有序查找：被查找数列必须为有序数列。</p><p><strong>七大查找算法：</strong></p><ul><li>1顺序查找</li><li>2二分查找</li><li>3插值查找</li><li>4斐波那契查找</li><li>5树表查找</li><li>6分块查找</li><li>7哈希查找</li></ul><h4 id="1-顺序查找-O-n"><a href="#1-顺序查找-O-n" class="headerlink" title="1 顺序查找(O(n))"></a>1 顺序查找(O(n))</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*顺序查找，a为数组，n为要查找的数组个数，key为要查找的关键字*/</span></span><br><span class="line"><span class="type">int</span> Sequential <span class="title function_">Search</span> <span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i]==key)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化，设置哨兵：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*有哨兵顺序查找*/</span></span><br><span class="line"><span class="type">int</span> Sequential <span class="title function_">Search2</span> <span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    a[<span class="number">0</span>]=key;<span class="comment">/*设置a[0]为关键字值，我们称之为“哨兵”*/</span></span><br><span class="line">    i=n;</span><br><span class="line">    <span class="comment">/*循环从数组尾部开始*/</span></span><br><span class="line">    <span class="keyword">while</span> (a[i]!=key)</span><br><span class="line">    &#123;</span><br><span class="line">        i--</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> i;<span class="comment">/*返回0则说明查找失败*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这里优化后，会改变原数组a[0]的值？</p><h4 id="2-有序查找"><a href="#2-有序查找" class="headerlink" title="2 有序查找"></a>2 有序查找</h4><p>有序查找为插值插值类，有三种有序表查找，本质上是分隔点的选择不同，各有优劣，实际开发时可根据数据的特点综合考虑再做出选择。</p><h5 id="二分查找-O-logn"><a href="#二分查找-O-logn" class="headerlink" title="二分查找(O(logn))"></a>二分查找(O(logn))</h5><p>折半查找(Binary Search)技术，又称为二分查找。</p><p>它的前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Binary <span class="title function_">Search</span> <span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> low,high,mid;</span><br><span class="line">    <span class="number">1</span>ow=<span class="number">1</span>:<span class="comment">/*定义最低下标为记录首位*/</span></span><br><span class="line">    high=n;<span class="comment">/*定义最高下标为记录末位*/</span></span><br><span class="line">    <span class="keyword">while</span> (low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;<span class="comment">/*折半*/</span></span><br><span class="line">        <span class="keyword">if</span> (key&lt;a[mid]<span class="comment">/*若查找值比中值小*/</span></span><br><span class="line">        high=mid<span class="number">-1</span>;<span class="comment">/*最高下标调整到中位下标小一位*/</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key&gt;a[mid])<span class="comment">/*若查找值比中值大*/</span></span><br><span class="line">        low=mid+<span class="number">1</span>;<span class="comment">/*最低下标调整到中位下标大一位*/</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*若相等则说明mid即为查找到的位置*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过由于折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，这样的算法已经比较好了。</p><p>但对于需要<u>频繁执行插入或删除操作</u>的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。</p><h5 id="插值查找-O-logn"><a href="#插值查找-O-logn" class="headerlink" title="插值查找(O(logn))"></a>插值查找(O(logn))</h5><p>折半查找公式：</p><p>$m i d&#x3D;\frac{l o w+h i g h}{2}&#x3D;l o w+\frac{1}{2}\bigl(h i g h-l o w\bigr)$</p><p>改变$1&#x2F;2$变成$\frac{k e y-a[l o w]}{a[h i g h]-a[l o w]}$：</p><p>$m i d&#x3D;l o w+\frac{k e y-a[l o w]}{a[h i g h]-a[l o w]}(h i g h-l o w)$</p><p>代码中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> mid=(low+high)/<span class="number">2</span>;<span class="comment">/*折半*/</span></span><br><span class="line"><span class="comment">//改成：</span></span><br><span class="line">mid=low+(high-low)*（key-a[low])/(a[high]-a[<span class="number">1</span>ow]);<span class="comment">/*插值*/</span></span><br></pre></td></tr></table></figure><h5 id="斐波那契查找-O-logn"><a href="#斐波那契查找-O-logn" class="headerlink" title="斐波那契查找(O(logn))"></a>斐波那契查找(O(logn))</h5><p>斐波那契查找(Fibonacci Search)，它是利用了黄金分割原理来实现的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Fibonacci <span class="title function_">Search</span> <span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> low,high,mid,i,k;</span><br><span class="line">    <span class="number">10</span>w=<span class="number">1</span>;<span class="comment">/*定义最低下标为记录首位*/</span></span><br><span class="line">    high=n; <span class="comment">/*定义最高下标为记录末位*/</span></span><br><span class="line">    k=<span class="number">0</span>:</span><br><span class="line">    <span class="keyword">while</span>(n&gt;F[k]<span class="number">-1</span>)<span class="comment">/*计算n位于斐波那契数列的位置*/</span></span><br><span class="line">        k++:</span><br><span class="line">    <span class="keyword">for</span>（i=n;<span class="number">1</span>&lt;F[k]<span class="number">-1</span>;i++)<span class="comment">/*将不满的数值补全*/</span></span><br><span class="line">        a[i]=a[n];</span><br><span class="line">    <span class="keyword">while</span> (low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=low+F[k<span class="number">-1</span>]<span class="number">-1</span>;<span class="comment">/*计算当前分隔的下标*/</span></span><br><span class="line">        <span class="keyword">if</span> (key&lt;a[mid])<span class="comment">/*若查找记录小于当前分隔记录*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            high=mid<span class="number">-1</span>;<span class="comment">/*最高下标调整到分隔下标mid-1处*/</span></span><br><span class="line">            k=k<span class="number">-1</span>:<span class="comment">/*斐波那契数列下标减一位*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key&gt;a[mid])<span class="comment">/*若查找记录大于当前分隔记录*/</span></span><br><span class="line">        &#123;</span><br><span class="line">            low=mid+<span class="number">1</span>;<span class="comment">/*最低下标调整到分隔下标mid+1处*/</span></span><br><span class="line">            k=k<span class="number">-2</span>;<span class="comment">/*斐波那契数列下标减两位*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid&lt;=n)</span><br><span class="line">                <span class="keyword">return</span> mid;<span class="comment">/*若相等则说明mid即为查找到的位置*/</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> n;<span class="comment">/*若mid&gt;n说明是补全数值，返回n*/</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-索引查找"><a href="#3-索引查找" class="headerlink" title="3 索引查找"></a>3 索引查找</h4><p>索引按照结构可以分为线性索引、树形索引和多级索引。</p><p>所谓线性索引就是将索引项集合组织为线性结构，也称为索引表。重点介绍三种线性索引：稠密索引、分块索引和倒排索引。</p><h5 id="稠密索引"><a href="#稠密索引" class="headerlink" title="稠密索引"></a>稠密索引</h5><p>稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项。</p><style>.gsqkrybewxcn{zoom: 67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240311092732507.png" class="gsqkrybewxcn" alt="image-20240311092732507"><p>对于稠密索引这个索引表来说，索引项一定是按照关键码<strong>有序</strong>的排列。</p><h5 id="分块索引（分块查找）"><a href="#分块索引（分块查找）" class="headerlink" title="分块索引（分块查找）"></a>分块索引（分块查找）</h5><p>稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大。为了减少索<br>引项的个数，我们可以对数据集进行分块，使其分块有序，然后再对每一块建立一个<br>索引项，从而减少索引项的个数。</p><p>分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件：</p><ul><li>块内无序，即每一块内的记录不要求有序。当然，你如果能够让块内有序<br>  对查找来说更理想，不过这就要付出大量时间和空间的代价，因此通常我<br>  们不要求块内有序。</li><li>块间有序，例如，要求第二块所有记录的关键字均要大于第一块中所有记<br>  录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键<br>  字…因为只有块间有序，才有可能在查找时带来效率。</li><li>最大关键码，它存储每一块中的最大关键字，这样的好处就是可以使得在<br>  它之后的下一块中的最小关键字也能比这一块最大的关键字要大；</li><li>存储了块中的记录个数，以便于循环时使用；</li><li>用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历。</li></ul><style>.ljtjuqwkwpkq{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240311093022179.png" class="ljtjuqwkwpkq" alt="image-20240311093022179"><p>在分块索引表中查找，就是分两步进行：</p><ol><li>在分块索引表中查找要查关键字所在的块。由于分块索引表是块间有序的，<br> 因此很容易利用折半、插值等算法得到结果。例如，在图8-5-4的数据集中<br> 查找62，我们可以很快可以从左上角的索引表中由57&lt;62&lt;96得到62在第<br> 三个块中。</li><li>根据块首指针找到相应的块，并在块中顺序查找关键码。因为块中可以是无序<br> 的，因此只能顺序查找。</li></ol><h5 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h5><h4 id="4-树表查找"><a href="#4-树表查找" class="headerlink" title="4 树表查找"></a>4 树表查找</h4><p>假设查找的数据集是普通的顺序存储，那么插入操作就是将记录放在表的末端，给表记录数加一即可，删除操作可以是删除后，后面的记录向前移，也可以是要删除的元素与最后一个元素互换，表记录数减一，反正整个数据集也没有什么顺序，这样的效率也不错。应该说，插入和删除对于顺序存储结构来说，效率是可以接受的，但这样的表由于无序造成查找的效率很低。</p><p>如果查找的数据集是有序线性表，并且是顺序存储的，查找可以用折半、插值、斐波那契等查找算法来实现，可惜，因为有序，在插入和删除操作上，就需要耗费大量的时间。</p><p>在查找时插入或删除的查找表称为动态查找表。</p><p>以下查找方法可以使得插入和删除效率不错，又可以比较高效率地实现查找。</p><h5 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h5><p>二叉排序树(Binary Sort Tree),又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树。</li></ul><h5 id="平衡二叉树（AVL树）"><a href="#平衡二叉树（AVL树）" class="headerlink" title="平衡二叉树（AVL树）"></a>平衡二叉树（AVL树）</h5><p>平衡二叉树(Self-Balancing Binary Search Tree或Height-Balanced Binary Search Tree)，是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1。</p><h5 id="平衡二叉树（红黑树）"><a href="#平衡二叉树（红黑树）" class="headerlink" title="平衡二叉树（红黑树）"></a>平衡二叉树（红黑树）</h5><h5 id="多路查找树（2-3、B、B-树）"><a href="#多路查找树（2-3、B、B-树）" class="headerlink" title="多路查找树（2-3、B、B+树）"></a>多路查找树（2-3、B、B+树）</h5><p>多路查找树(muitl-way search tree),其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素。由于它是查找树，所有元素之间存在某种特定的排序关系。</p><p>23树是这样的一棵多路查找树：其中的每一个结点都具有两个孩子（我们称它为2结点)或三个孩子（我们称它为3结点）。</p><p>B树(B-ree)是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。结点最大的孩子数目称为B树的阶(order)，因此，2-3树是3阶B树，2-3-4树是4阶B树。</p><p>B+树是应文件系统所需而出的一种B树的变形树，注意严格意义上讲，它其实已经不是第六章定义的树了。在B树中，每一个元素在该树中只出现一次，有可能在叶子结点上，也有可能在分支结点上。而在B+树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者（叶子结点）中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针。</p><h4 id="5-哈希查找"><a href="#5-哈希查找" class="headerlink" title="5 哈希查找"></a>5 哈希查找</h4><p>哈希查找，即哈希表查找，或者散列表查找。</p><p>散列技术：是在记录的存储位置和它的关键字之间建立一个确定的对应关系，使得每个关键字key对应一个存储位置f(key)。查找时，根据这个确定的对应关系找到给定值key的映射f(key)，若查找集合中存在这个记录，则必定在f(key)的位置上。</p><p>这里把这种对应关系f称为散列函数，又称为哈希(Hash)函数。按这个思想，采用散列技术将记录存储在一块<u>连续的存储空间</u>中，这块连续存储空间称为<strong>散列表或哈希表</strong>(Hash table)。那么关键字对应的记录存储位置我们称为散列地址。</p><p>散列技术最适合的求解问题是<u>查找与给定值相等的记录</u>。</p><p>哈希冲突：在理想的情况下，每一个关键字，通过散列函数计算出来的地址都是不一样的，可现实中，这只是一个理想。我们时常会碰到两个关键字ky1≠ key2,但是却有f(key1)&#x3D;f(key2)，这种现象称为冲突（(collision)，并把key1和 key2称为这个散列函数的同义词(synonym)。</p><h6 id="散列函数的构造"><a href="#散列函数的构造" class="headerlink" title="散列函数的构造"></a>散列函数的构造</h6><p><strong>1、直接定址法</strong></p><p>以取关键字的某个线性函数值为散列地址，即 f(key)&#x3D;a×key+b（a、b为常数)这样的散列函数优点就是简单、均匀，也不会产生冲突，但这需要事先知道关键字的分布情况，<u>适合查找表较小且连续的情况</u>。由于这样的限制，在现实应用中，此方法虽然简单，但却并不常用。</p><p><strong>2、数字分析法</strong></p><style>.kxqyhwxbmdxb{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310215844580.png" class="kxqyhwxbmdxb" alt="image-20240310215844580"><p><strong>3、平方取中法</strong></p><p>这个方法计算很简单，假设关键字是1234，那么它的平方就是1522756，再抽取中间的3位就是227，用做散列地址。再比如关键字是4321，那么它的平方就是 18671041,抽取中间的3位就可以是671，也可以是710，用做散列地址。</p><p><u>平方取中法比较适合于不知道关键字的分布，而位数又不是很大的情况。</u></p><p><strong>4、折叠法</strong></p><p>折叠法是将关键字从左到右分割成位数相等的几部分（注意最后一部分位数不够时可以短些)，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。</p><p>比如我们的关键字是9876543210，散列表表长为三位，我们将它分为四组， 987|654|321|0,然后将它们叠加求和987+654+321+0&#x3D;1962，再求后3位得到散列地址为962。有时可能这还不能够保证分布均匀，不妨从一端向另一端来回折叠后对齐相加。比如我们将987和321反转，再与654和0相加，变成789+654+123+0&#x3D;1566，此时散列地址为566。</p><p><u>折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。</u></p><p><strong>5、除留余数法</strong></p><p>此方法为最常用的构造散列函数方法。对于散列表长为的散列函数公式为：f(key)&#x3D;key mod p(p≤m)，mod是取模（求余数）的意思。事实上，这方法不仅可以对关键字直接取模，也可在折叠、平方取中后再取模。</p><p>因此根据前辈们的经验，若散列表表长为，通常p为小于或等于表长（最好接近m)的最小质数或不包含小于20质因子的合数。</p><p><strong>6、随机数法</strong></p><p>选择一个随机数，取关键字的随机函数值为它的散列地址。也就是f(key)&#x3D;random(key)。这里random是随机函数。当关键字的长度不等时，采用这个方法构造散列函数是比较合适的。</p><h6 id="处理散列冲突的方法"><a href="#处理散列冲突的方法" class="headerlink" title="处理散列冲突的方法"></a>处理散列冲突的方法</h6><p><strong>1、开放定址法</strong></p><p>所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</p><p>线性探测法</p><p><strong>2、再散列函数法</strong></p><p>每当发生散列地址冲突时，就换一个散列函数计算，相信总会有一个可以把冲突解决掉。这种方法能够使得关键字不产生聚集，当然，相应地也增加了计算的时间。</p><p><strong>3、链地址法</strong></p><p>将所有关键字为同义词的记录存储在一个单链表中，我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。</p><style>.vijmbwfgdkmo{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310221703440.png" class="vijmbwfgdkmo" alt="image-20240310221703440"><p><strong>4、公共溢出区法</strong></p><p>为所有冲突的关键字建立了一个公共的溢出区来存放。</p><style>.tibjftojfmoq{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240310221818961.png" class="tibjftojfmoq" alt="image-20240310221818961"><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><strong>参考：</strong></p><p><a href="https://www.cnblogs.com/onepixel/p/7674659.html">https://www.cnblogs.com/onepixel/p/7674659.html</a></p><p><a href="https://www.zhihu.com/question/485281894/answer/2526978559">https://www.zhihu.com/question/485281894/answer/2526978559</a></p><p> <strong>排序的分类</strong></p><p>按在排序过程中是否涉及数据的内、外存交换来分类，排序大致分为两类：<code>内部排序</code>和<code>外部排序</code>。</p><p><strong>内排序</strong>是在排序整个过程中，待排序的所有记录<u>全部被放置在内存</u>中。<strong>外排序</strong>是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在<u>内外存之间多次交换数据</u>才能进行。外排序是一种线性时间复杂度的排序，<u>利用空间来换时间</u>。</p><p>根据排序过程中借助的主要操作，我们把<strong>内排序</strong>分为：<u>插入排序、交换排序、选择排序和归并排序</u>。<strong>外排序</strong>可以分为：<u>计数排序、桶排序和基数排序</u>。</p><p>按照是否通过比较来决定元素间的相对次序，排序可以分为<code>比较类排序</code>和<code>非比较类排序</code>。</p><p><strong>十大排序</strong></p><style>.ilujothhejyt{zoom: 50%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/849589-20190306165258970-1789860540.png" class="ilujothhejyt" alt="img"><style>.stkiqrvmwymh{zoom: 50%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/849589-20180402133438219-1946132192.png" class="stkiqrvmwymh" alt="img"><h4 id="1冒泡排序"><a href="#1冒泡排序" class="headerlink" title="1冒泡排序"></a>1冒泡排序</h4><p>冒泡排序(Bubble Sort)一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。</p><style>.ukborraqjszr{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/849589-20171015223238449-2146169197.gif" class="ukborraqjszr" alt="img"><p>简单实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 让大的沉底</span></span><br><span class="line">                <span class="type">int</span> temp = a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bubble_sort</span>(a, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若序列已经有序，为减少两两间的比较，可以设置标志flag</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span> &amp;&amp; flag; i++) &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 让大的沉底</span></span><br><span class="line">                <span class="type">int</span> temp = a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = temp;</span><br><span class="line">                </span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2简单选择排序"><a href="#2简单选择排序" class="headerlink" title="2简单选择排序"></a>2简单选择排序</h4><p>简单选择排序法(Simple Selection Sort)就是通过n-i次关键字间的比较，从 n-i+1个记录中选出关键字最小的记录，并和第i（1≤i≤n)个记录交换之。</p><style>.rqmbilexumei{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/849589-20171015224719590-1433219824.gif" class="rqmbilexumei" alt="img"><p>思路：首先在未排序的序列中找到最小或者最大的元素，放到排序序列的起始位置，然后再从未排序的序列中继继续寻找最小或者最大元素，然后放到已经排序序列的末尾。以此类推，直到所有元素排序完毕。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> <span class="comment">//交換兩個變數，C语言可以这样写：swap(&amp;a, &amp;b);</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">select_sort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123; <span class="comment">//走訪未排序的元素</span></span><br><span class="line">            <span class="keyword">if</span>(a[min] &gt; a[j]) &#123;          <span class="comment">//找到目前最小值</span></span><br><span class="line">                min = j;                 <span class="comment">//紀錄最小值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(a[min], a[i]);              <span class="comment">//做交換，C++可以不用自己写swap</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3直接插入排序"><a href="#3直接插入排序" class="headerlink" title="3直接插入排序"></a>3直接插入排序</h4><p>直接插入排序(Straight Insertion Sort)的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。</p><style>.xxsxnextimxk{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/849589-20171015225645277-1151100000.gif" class="xxsxnextimxk" alt="img"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_sort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, key;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        key = a[i];</span><br><span class="line">        <span class="keyword">for</span>(j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; key; j--) &#123;</span><br><span class="line">            a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        a[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4希尔排序"><a href="#4希尔排序" class="headerlink" title="4希尔排序"></a>4希尔排序</h4><p>1959年Shell发明，第个突破O(n^2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><style>.chgtvladohuq{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/849589-20180331170017421-364506073.gif" class="chgtvladohuq" alt="img"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shell_sort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, gap, key;</span><br><span class="line">    <span class="keyword">for</span>(gap = n / <span class="number">2</span>; gap &gt;= <span class="number">1</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = gap; i &lt; n; i++) &#123;</span><br><span class="line">            key = a[i];</span><br><span class="line">            <span class="keyword">for</span>(j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; key; j -= gap) &#123;</span><br><span class="line">                a[j + gap] = a[j];</span><br><span class="line">            &#125;</span><br><span class="line">            a[j + gap] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5归并排序"><a href="#5归并排序" class="headerlink" title="5归并排序"></a>5归并排序</h4><p>归并排序的步骤，是把一个数组切分成两个，接着递归，一直到单个元素，然后再合并，单个元素合并成小数组，小数组合并成大数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> start, <span class="type">int</span> mid, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> start1 = start, end1 = mid;</span><br><span class="line">    <span class="type">int</span> start2 = mid + <span class="number">1</span>, end2 = end;</span><br><span class="line">    <span class="type">int</span> temp[<span class="number">10000</span>], k = <span class="number">0</span>, i; <span class="comment">//temp临时存放合并后的数组</span></span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)</span><br><span class="line">        temp[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1)</span><br><span class="line">        temp[k++] = a[start1++];</span><br><span class="line">    <span class="keyword">while</span> (start2 &lt;= end2)</span><br><span class="line">        temp[k++] = a[start2++];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        a[start + i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将a数组区间[start, end]进行归并排序（递归实现）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(a, start, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(a, mid + <span class="number">1</span>, end);</span><br><span class="line">    <span class="built_in">merge</span>(a, start, mid, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将a数组区间[start, end]进行归并排序（C++循环实现）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//step为组内元素个数，step / 2为左子区间元素个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> step = <span class="number">2</span>; step / <span class="number">2</span> &lt; len; step *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i += step) &#123; <span class="comment">// 对每一组</span></span><br><span class="line">            <span class="type">int</span> mid = i + (step - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">//区间元素个数为step，故end = i + step - 1</span></span><br><span class="line">            <span class="keyword">if</span>(mid + <span class="number">1</span> &lt;= len) &#123; <span class="comment">//右子区间左端点&lt;=右端点</span></span><br><span class="line">                <span class="built_in">merge</span>(a, i, mid, <span class="built_in">min</span>(i + step - <span class="number">1</span>, len - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6快速排序"><a href="#6快速排序" class="headerlink" title="6快速排序"></a>6快速排序</h4><p>快速排序是面试最高频的排序算法。大概过程：</p><ul><li>选出一个基准数，基准值一般取序列最左边的元素</li><li>重新排序序列，比基准值小的放在基准值左边，比基准值大的放在基准值右边，这就是所谓的分区</li></ul><p>快排也采用了“<a href="https://www.zhihu.com/search?q=%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22685658029%22%7D">分治思想</a>”，需要使用到递归，这一点跟归并排序相同；不同的是比较过程， 快排序不需要“合并”的过程，因为递归分解后，数据已经是有序的。</p><style>.sohfwssrjgnj{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/v2-310b8d349be98f5f3f03852809f14564_b.jpg" class="sohfwssrjgnj" alt="img"><p>快速排序实现方法分为<u>单边扫描和双边扫描</u>快速排序。</p><p><strong>单边扫描快速排序</strong></p><p>选择一个数作为基准数pivot，同时设定一个标记 mark 代表左边序列最右侧的下标位置，接下来遍历数组，如果元素大于基准值，无操作，继续遍历，如果元素小于基准值，则把 mark + 1 ，再将 mark 所在位置的元素和遍历到的元素交换位置，mark 这个位置存储的是比基准值小的数据，当遍历结束后，将基准值与 mark 所在元素交换位置。</p><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/849589-20171015230936371-1413523412.gif" class="" title="img"><p><strong>双边扫描快速排序</strong></p><p>选择一个数作为基准值，然后从数组左右两边进行扫描，先从左往右找到一个大于基准值的元素，将它填入到right指针位置，然后转到从右往左扫描，找到一个小于基准值的元素，将他填入到left指针位置。</p><p>快排最好的情况是，每次正好中分，复杂度为O(nlogn)。最差情况，复杂度为O(n^2)：</p><h4 id="7堆排序"><a href="#7堆排序" class="headerlink" title="7堆排序"></a>7堆排序</h4><p>简单选择排序，它在待排序的个记录中选择一个最小的记录需要比较n-1次。可惜的是，这样的操作并没有把每一趟的比较结果保存下来，在后一趟的比较中，有许多比较在前一趟已经做过了，但由于前一趟排序时未保存这些比较结果，所以后一趟排序时又重复执行了这些比较操作，因而记录的比较次数较多。</p><p>堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p><style>.hwntkskuxgbk{zoom:67%;}</style><img src="/2024/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20240311155553808.png" class="hwntkskuxgbk" alt="image-20240311155553808"><p>堆排序(Heap Sort)就是利用堆（假设利用大顶堆）进行排序的方法。它的基本思想是，将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值)，然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次小值。如此反复执行，便能得到一个有序序列了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> heap[maxn], n = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对heap数组在[low, high]范围进行向下调整</span></span><br><span class="line"><span class="comment">//其中low为欲调整结点的数组下标，high一般为堆的最后一个元素的数组下标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">downAdjust</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = low, j = i * <span class="number">2</span>; <span class="comment">//i为欲调整结点，j为其左孩子</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high) &#123;</span><br><span class="line">        <span class="comment">//如果右孩子存在且值大于左孩子</span></span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt;= high &amp;&amp; heap[j + <span class="number">1</span>] &gt; heap[j]) &#123;</span><br><span class="line">            j = j + <span class="number">1</span>; <span class="comment">//j存储右孩子下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果孩子中最大的权值比欲调整结点i大</span></span><br><span class="line">        <span class="keyword">if</span>(heap[j] &gt; heap[i]) &#123; <span class="comment">//建大顶堆，以完成升序排序</span></span><br><span class="line">            <span class="built_in">swap</span>(heap[j], heap[i]);</span><br><span class="line">            i = j; <span class="comment">//权值比i大的孩子结点变成下一个欲调整结点</span></span><br><span class="line">            j = i * <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//孩子的权值均比欲调整结点i小，调整结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--) &#123; <span class="comment">//只需对非叶子结点进行调整，而且要先把下面的结点调整好</span></span><br><span class="line">        <span class="built_in">downAdjust</span>(i, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">createHeap</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt; <span class="number">1</span>; i--) &#123; <span class="comment">//倒着枚举，直到堆中只有一个元素</span></span><br><span class="line">        <span class="built_in">swap</span>(heap[i], heap[<span class="number">1</span>]); <span class="comment">//把堆顶交换到当前无序序列的最后一个</span></span><br><span class="line">        <span class="built_in">downAdjust</span>(<span class="number">1</span>, i - <span class="number">1</span>); <span class="comment">//在1~i - 1的坐标范围内调整堆顶</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; heap[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">heapSort</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; heap[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8计数排序"><a href="#8计数排序" class="headerlink" title="8计数排序"></a>8计数排序</h4><p>计数排序的大致过程：</p><ul><li>找出待排序的数组中最大max和最小的元素min，创建一个最大下标为max或(max-min)的空数组arr</li><li>统计数组中每个值为i的元素出现的次数，存入数组arr的第i项：</li><li>对所有的计数累加（从arr中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第arr(i)项，每放一个元素就将arr(i)减去1。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(max &lt; arr[i])</span><br><span class="line">            max = arr[i]; <span class="comment">// 得到数组中元素的最大取值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> *count = <span class="keyword">new</span> <span class="type">int</span>[max + <span class="number">1</span>]; <span class="comment">// 申请计数数组count，存放原数组中值与索引对应的元素出现的次数</span></span><br><span class="line">    <span class="built_in">fill</span>(count, count + max + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        count[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= max; i++) &#123;</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>]; <span class="comment">// 依次累加，从count数组中的第一个元素开始，每一项和前一项相加</span></span><br><span class="line">    &#125; <span class="comment">// 累加后count[i]代表arr中小于等于i的元素总个数</span></span><br><span class="line">    <span class="type">int</span> *result = <span class="keyword">new</span> <span class="type">int</span>[len]; <span class="comment">// 目标数组，存放排序之后的结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 反向填充目标数组        </span></span><br><span class="line">        result[count[arr[i]] - <span class="number">1</span>] = arr[i]; <span class="comment">// 将每个元素i放在目标数组的第C[i]项</span></span><br><span class="line">        count[arr[i]]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        arr[i] = result[i]; <span class="comment">// 把目标数组复制回原数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []count; <span class="comment">// 释放分配的空间</span></span><br><span class="line">    <span class="keyword">delete</span> []result; <span class="comment">// 释放分配的空间</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>计数排序实际上不适合有负数的，元素偏移值过大的数组。</p><h4 id="9桶排序"><a href="#9桶排序" class="headerlink" title="9桶排序"></a>9桶排序</h4><p>桶排序大概的过程：</p><ul><li>设置指定数量个的数组当作空桶；</li><li>遍历输入数据，并且把元素一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BucketSort</span> implements IArraySort &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">static</span> <span class="keyword">final</span> InsertSort insertSort = <span class="keyword">new</span> <span class="built_in">InsertSort</span>();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] <span class="built_in">sort</span>(<span class="type">int</span>[] sourceArray) throws Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.<span class="built_in">copyOf</span>(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bucketSort</span>(arr, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] <span class="built_in">bucketSort</span>(<span class="type">int</span>[] arr, <span class="type">int</span> bucketSize) throws Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> minValue = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; minValue) &#123;</span><br><span class="line">                minValue = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; maxValue) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> bucketCount = (<span class="type">int</span>) Math.<span class="built_in">floor</span>((maxValue - minValue) / bucketSize) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] buckets = <span class="keyword">new</span> <span class="type">int</span>[bucketCount][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用映射函数将数据分配到各个桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> index = (<span class="type">int</span>) Math.<span class="built_in">floor</span>((arr[i] - minValue) / bucketSize);</span><br><span class="line">            buckets[index] = <span class="built_in">arrAppend</span>(buckets[index], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> arrIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对每个桶进行排序，这里使用了插入排序</span></span><br><span class="line">            bucket = insertSort.<span class="built_in">sort</span>(bucket);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> value : bucket) &#123;</span><br><span class="line">                arr[arrIndex++] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动扩容，并保存数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param arr</span></span><br><span class="line"><span class="comment">     * @param value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] <span class="built_in">arrAppend</span>(<span class="type">int</span>[] arr, <span class="type">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.<span class="built_in">copyOf</span>(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10基数排序"><a href="#10基数排序" class="headerlink" title="10基数排序"></a>10基数排序</h4><p>它的基本原理是将元素按照位数切割成不同的数字，然后按照每个位数进行比较，大概过程：</p><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radixi进行计数排序（利用计数排序适用于小范围数的特点）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxbit</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span> </span>&#123; <span class="comment">//辅助函数，求数据的最大位数</span></span><br><span class="line">    <span class="type">int</span> maxData = data[<span class="number">0</span>]; <span class="comment">// 最大数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; <span class="comment">// 先求出最大数，再求其位数。</span></span><br><span class="line">        <span class="keyword">if</span> (maxData &lt; data[i])</span><br><span class="line">            maxData = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (maxData &gt;= p) &#123;</span><br><span class="line">        maxData /= <span class="number">10</span>;</span><br><span class="line">        ++d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span> <span class="comment">//基数排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">maxbit</span>(data, n);</span><br><span class="line">    <span class="type">int</span> *tmp = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    <span class="type">int</span> *count = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; <span class="comment">//计数器</span></span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">int</span> radix = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= d; i++) &#123; <span class="comment">//进行d次排序</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            count[j] = <span class="number">0</span>; <span class="comment">//每次分配前清空计数器</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>; <span class="comment">//统计每个桶中的记录数</span></span><br><span class="line">            count[k]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            count[j] = count[j - <span class="number">1</span>] + count[j]; <span class="comment">//将tmp中的位置依次分配给每个桶</span></span><br><span class="line">        <span class="keyword">for</span>(j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123; <span class="comment">//将所有桶中记录依次收集到tmp中</span></span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>;</span><br><span class="line">            tmp[count[k] - <span class="number">1</span>] = data[j];</span><br><span class="line">            count[k]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++) <span class="comment">//将临时数组的内容复制到data中</span></span><br><span class="line">            data[j] = tmp[j];</span><br><span class="line">        radix = radix * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []tmp;</span><br><span class="line">    <span class="keyword">delete</span> []count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><p>基数排序：根据键值的每位数字来分配桶；</p><p>计数排序：每个桶只存储单一键值；</p><p>桶排序：每个桶存储一定范围的数值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字图像传统分割方法</title>
      <link href="/2024/03/03/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E4%BC%A0%E7%BB%9F%E5%88%86%E5%89%B2%E6%96%B9%E6%B3%95/"/>
      <url>/2024/03/03/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E4%BC%A0%E7%BB%9F%E5%88%86%E5%89%B2%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><h3 id="内容来源"><a href="#内容来源" class="headerlink" title="内容来源"></a>内容来源</h3><p>[1]<a href="https://zhuanlan.zhihu.com/p/70758906">https://zhuanlan.zhihu.com/p/70758906</a></p><p>[2]黄鹏,郑淇,梁超.图像分割方法综述[J].武汉大学学报(理学版),2020,66(06):519-531.</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>OpenCV中文文档：<a href="https://apachecn.github.io/opencv-doc-zh/">https://apachecn.github.io/opencv-doc-zh/</a></p><p>OpenCV API接口说明：<a href="https://docs.opencv.org/4.x/d6/d00/tutorial_py_root.html">https://docs.opencv.org/4.x/d6/d00/tutorial_py_root.html</a></p><p>注意：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">显示图像方面，在整数表示的颜色空间中，数值范围是0-255，但在浮点数表示的颜色空间中，数值范围是0-1.0，所以要把0-255归一化。若是不做归一化处理，数值大于1的都会变为1.0处理</span><br></pre></td></tr></table></figure><h2 id="1基于阈值分割"><a href="#1基于阈值分割" class="headerlink" title="1基于阈值分割"></a>1基于阈值分割</h2><p>基于阈值的图像分割方法实质是通过设定不同的灰度阈值，对图像灰度直方图进行分类，灰度值在同一个灰度范围内的像素认为属于同一类并具有一定相似性，该类方法是一种常用的灰度图像分割方法，常用的方法包括直方图技术法、熵算法、Otsu、自适应阈值等。</p><img src="/2024/03/03/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E4%BC%A0%E7%BB%9F%E5%88%86%E5%89%B2%E6%96%B9%E6%B3%95/clip_image002.jpg" class="" title="正在加载图片"><h3 id="1-1全局阈值分割"><a href="#1-1全局阈值分割" class="headerlink" title="1.1全局阈值分割"></a>1.1全局阈值分割</h3><p>如果像素值大于阈值，则会被赋为一个值（可能为白色），否则会赋为另一个值（可能为黑色）。</p><p>OpenCV函数接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">threshold</span><span class="params">( InputArray src, OutputArray dst,<span class="type">double</span> thresh, <span class="type">double</span> maxval, <span class="type">int</span> type )</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参数说明：</p><p><strong>函数返回值</strong>：做阈值分割的像素阈值；</p><p><strong>src</strong>: 输入图像矩阵，<strong>单通道</strong>的8位或32位图像矩阵，可以是float类型；</p><p><strong>dst</strong>:输出图像矩阵，与src类型一致，size大小一致；</p><p><strong>thresh</strong>:分割所需的图像阈值；</p><p><strong>maxval</strong>: <code>当type 选择ThresholdTypes::THRESH_BINARY,或hresholdTypes::THRESH_BINARY_INV二者之一时，像素的最大值；</code></p><p><strong>type</strong>:类型有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ThresholdTypes</span> &#123;</span><br><span class="line">    THRESH_BINARY     = <span class="number">0</span>, <span class="comment">// 大于thresh 为 maxval,否则为 0</span></span><br><span class="line">    THRESH_BINARY_INV = <span class="number">1</span>,<span class="comment">// 大于thresh 为 0,否则为 maxval</span></span><br><span class="line">    THRESH_TRUNC      = <span class="number">2</span>, <span class="comment">// 大于thresh 为 thresh,否则为 0</span></span><br><span class="line">    THRESH_TOZERO     = <span class="number">3</span>, <span class="comment">// 大于thresh 不变,否则为 0</span></span><br><span class="line">    THRESH_TOZERO_INV = <span class="number">4</span>, <span class="comment">// 大于thresh 为 0,否则 不变</span></span><br><span class="line">    THRESH_MASK       = <span class="number">7</span>,</span><br><span class="line">    THRESH_OTSU       = <span class="number">8</span>, <span class="comment">// 使用OTSU阈值</span></span><br><span class="line">    THRESH_TRIANGLE   = <span class="number">16</span> <span class="comment">// 使用三角形算法阈值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>最后两种是配合前5种算法一起使用的，具体用法为:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">threshold</span>(Src8, Dst8, <span class="number">78</span>, <span class="number">255</span>, ThresholdTypes::THRESH_BINARY | ThresholdTypes::THRESH_OTSU);</span><br><span class="line"><span class="comment">// 这里阈值78不起作用</span></span><br></pre></td></tr></table></figure><h3 id="1-2自适应阈值分割"><a href="#1-2自适应阈值分割" class="headerlink" title="1.2自适应阈值分割"></a>1.2自适应阈值分割</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">adaptiveThreshold</span>(src,maxValue,adaptiveMethod,thresholdType,blockSize,C,dst=None)</span><br></pre></td></tr></table></figure><p><strong>src</strong>：输入</p><p><strong>maxValue</strong>：Double类型的，阈值的最大值</p><p><strong>adaptiveMethod</strong>：Int类型的，这里有两种选择</p><ul><li>1 —— ADAPTIVE_THRESH_MEAN_C（通过平均的方法取得平均值）</li><li>2 —— ADAPTIVE_THRESH_GAUSSIAN_C(通过高斯取得高斯值)<br>  不过这两种方法最后得到的结果要减掉参数里面的C值</li></ul><p><strong>thresholdType</strong>：Int类型的，方法如下：</p><ul><li>THRESH_BINARY 二进制阈值化 -&gt; 大于阈值为1 小于阈值为0</li><li>THRESH_BINARY_INV 反二进制阈值化 -&gt; 大于阈值为0 小于阈值为1</li><li>THRESH_TRUNC 截断阈值化 -&gt; 大于阈值为阈值，小于阈值不变</li><li>THRESH_TOZERO 阈值化为0 -&gt; 大于阈值的不变，小于阈值的全为0</li><li>THRESH_TOZERO_INV 反阈值化为0 -&gt; 大于阈值为0，小于阈值不变</li></ul><p><strong>blockSize</strong>：Int类型的，这个值来决定像素的邻域块有多大。注意：这里的blockSize的值要为奇数，否则会给出这样的提示：Assertion failed (blockSize % 2 &#x3D;&#x3D; 1 &amp;&amp; blockSize &gt; 1) in cv::adaptiveThreshold</p><p><strong>C</strong>：偏移值调整量，计算adaptiveMethod用到的参数。</p><h3 id="1-3-Otsu-二值化"><a href="#1-3-Otsu-二值化" class="headerlink" title="1.3 Otsu 二值化"></a>1.3 Otsu 二值化</h3><h2 id="2基于区域分割"><a href="#2基于区域分割" class="headerlink" title="2基于区域分割"></a>2基于区域分割</h2><p>基于区域的图像分割方法是根据图像的空间信息进行分割，通过像素的相似性特征对像素点进行分类并构成区域，常用方法包括区域生长、区域分裂合并、分水岭算法等。</p><h3 id="2-1区域生长算法"><a href="#2-1区域生长算法" class="headerlink" title="2.1区域生长算法"></a>2.1区域生长算法</h3><p>区域生长的基本思想是将具有相似性质的像素集合起来构成区域。步骤：</p><ul><li>先对每个需要分割的区域找一个种子像素作为生长的起点；</li><li>然后将种子像素周围邻域中与种子像素具有相同或相似性质的像素合并到种子像素所在的区域中；（通过某种事先确定的生长或相似准则来判定，例如常见的基于区域灰度差、基于区域灰度分布统计性质）</li><li>将这些新像素当做新的种子像素继续进行上面的过程，直到再没有满足条件的像素可被包括进来。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用区域增长算法分割灰度图像</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SegmentImageWithAreaGrow</span><span class="params">(cv::Mat src_image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cv::Mat src_gray;</span><br><span class="line">    <span class="built_in">cvtColor</span>(src_image,src_gray,CV_BGR2GRAY);</span><br><span class="line">    normalized_image.<span class="built_in">convertTo</span>(src_gray, CV_8U, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设第一个种子点为图片中心</span></span><br><span class="line">    <span class="type">int</span> firstSeed_x = <span class="built_in">round</span>(src_gray.cols / <span class="number">2</span>);    </span><br><span class="line">    <span class="type">int</span> firstSeed_y = <span class="built_in">round</span>(src_gray.rows / <span class="number">2</span>);</span><br><span class="line">    cv::Point firstSeed = cv::<span class="built_in">Point</span>(firstSeed_x, firstSeed_y);</span><br><span class="line">    <span class="comment">//存放生长区域</span></span><br><span class="line">    cv::Mat growArea = cv::Mat::<span class="built_in">zeros</span>(src_gray.<span class="built_in">size</span>(), CV_8UC1);    </span><br><span class="line">    <span class="comment">//为第一个生长点赋值</span></span><br><span class="line">    growArea.<span class="built_in">at</span>&lt;uchar&gt;(cv::<span class="built_in">Point</span>(firstSeed.x, firstSeed.y)) = src_gray.<span class="built_in">at</span>&lt;uchar&gt;(cv::<span class="built_in">Point</span>(firstSeed.x, firstSeed.y));</span><br><span class="line">    cv::Point waitSeed;    <span class="comment">//待生长种子点</span></span><br><span class="line">    <span class="type">int</span> waitSeed_value = <span class="number">0</span>;    <span class="comment">//待生长种子点像素值</span></span><br><span class="line">    <span class="type">int</span> opp_waitSeed_value = <span class="number">0</span>;   <span class="comment">//mat_thresh中对应待生长种子点处的像素值</span></span><br><span class="line">    std::vector&lt;cv::Point&gt; seedVector;     <span class="comment">//种子栈</span></span><br><span class="line">    seedVector.<span class="built_in">push_back</span>(firstSeed);    <span class="comment">//将种子放入栈中最后一个位置</span></span><br><span class="line">    <span class="type">int</span> direct[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">0</span>&#125; &#125;;   <span class="comment">//4邻域,应该用4邻域减小时间复杂度</span></span><br><span class="line">    <span class="comment">//int direct[8][2] = &#123; &#123;-1,-1&#125;, &#123;0,-1&#125;, &#123;1,-1&#125;, &#123;1,0&#125;, &#123;1,1&#125;, &#123;0,1&#125;, &#123;-1,1&#125;, &#123;-1,0&#125; &#125;;  //8邻域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!seedVector.<span class="built_in">empty</span>())     <span class="comment">//种子栈不为空则生长，即遍历栈中所有元素后停止生长</span></span><br><span class="line">    &#123;</span><br><span class="line">        cv::Point seed = seedVector.<span class="built_in">back</span>();     <span class="comment">//取出最后一个元素</span></span><br><span class="line">        seedVector.<span class="built_in">pop_back</span>();         <span class="comment">//删除栈中最后一个元素,防止重复扫描</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)    <span class="comment">//遍历种子点的4邻域</span></span><br><span class="line">        &#123;</span><br><span class="line">            waitSeed.x = seed.x + direct[i][<span class="number">0</span>];    <span class="comment">//第i个坐标0行，即x坐标值</span></span><br><span class="line">            waitSeed.y = seed.y + direct[i][<span class="number">1</span>];    <span class="comment">//第i个坐标1行，即y坐标值</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//检查是否是边缘点</span></span><br><span class="line">            <span class="keyword">if</span> (waitSeed.x &lt; <span class="number">0</span> || waitSeed.y &lt; <span class="number">0</span> ||</span><br><span class="line">                waitSeed.x &gt;(src_gray.cols - <span class="number">1</span>) || (waitSeed.y &gt; src_gray.rows - <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            waitSeed_value = growArea.<span class="built_in">at</span>&lt;uchar&gt;(cv::<span class="built_in">Point</span>(waitSeed.x, waitSeed.y));   <span class="comment">//为待生长种子点赋对应位置的像素值</span></span><br><span class="line">            opp_waitSeed_value = src_gray.<span class="built_in">at</span>&lt;uchar&gt;(cv::<span class="built_in">Point</span>(waitSeed.x, waitSeed.y));</span><br><span class="line">            <span class="keyword">if</span> (waitSeed_value == <span class="number">0</span>)     <span class="comment">//判断waitSeed是否已经被生长，避免重复生长造成死循环</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (opp_waitSeed_value != <span class="number">0</span>)     <span class="comment">//区域生长条件，根据自己的需求修改</span></span><br><span class="line">                &#123;</span><br><span class="line">                    growArea.<span class="built_in">at</span>&lt;uchar&gt;(cv::<span class="built_in">Point</span>(waitSeed.x, waitSeed.y)) = src_gray.<span class="built_in">at</span>&lt;uchar&gt;(cv::<span class="built_in">Point</span>(waitSeed.x, waitSeed.y));</span><br><span class="line">                    seedVector.<span class="built_in">push_back</span>(waitSeed);    <span class="comment">//将满足生长条件的待生长种子点放入种子栈中</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;原图&quot;</span>, normalized_image);</span><br><span class="line">    cv::<span class="built_in">imshow</span>(<span class="string">&quot;区域增长分割结果&quot;</span>, growArea);</span><br><span class="line">    cv::<span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return growArea;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2分水岭算法"><a href="#2-2分水岭算法" class="headerlink" title="2.2分水岭算法"></a>2.2分水岭算法</h3><p>基本思想是把图像看作是测地学上的拓扑地貌，图像中每一点像素的灰度值表示该点的海拔高度，每一个局部极小值及其影响区域称为集水盆，而集水盆的边界则形成分水岭。</p><p>分水岭的概念和形成可以通过模拟浸入过程来说明。在每一个局部极小值表面，刺穿一个小孔，然后把整个模型慢慢浸入水中，随着浸入的加深，每一个局部极小值的影响域慢慢向外扩展，在两个集水盆汇合处构筑大坝，即形成分水岭。</p><p>分水岭比较经典的计算方法是L. Vincent提出的。在该算法中，分水岭计算分两个步骤，一个是排序过程，一个是淹没过程。首先对每个像素的灰度级进行从低到高排序，然后在从低到高实现淹没过程中， 对每一个局部极小值在h阶高度的影响域采用先进先出（FIFO）结构进行判断及标注。</p><p>分水岭变换得到的是输入图像的集水盆图像，集水盆之间的边界点，即为分水岭。显然，分水岭表示的是输入图像极大值点。因此，为得到图像的边缘信息，通常把梯度图像作为输入图像，即： grad(f(x,y))&#x3D;((f(x-1,y)-f(x+1,y))^2 + (f(x,y-1)-f(x,y+1))^2)^0.5 式中，f(x,y)表示原始图像，grad(.)表示梯度运算。</p><h2 id="3基于边缘分割"><a href="#3基于边缘分割" class="headerlink" title="3基于边缘分割"></a>3基于边缘分割</h2><p>二维图像上的边缘检测是指检测出图像上灰度不连续的像素，筛选假边缘、保留真边缘，并尽量维护边缘的连接性，主要方法有基于差分的边缘检测、基于模糊理论的边缘检测、基于小波变换的边缘检测、基于数学形态学的边缘检测等。常用的一般是基于差分的边缘检测算子：基于一阶导数的算子（Roberts 算子、Prewitt 算子和 Sobel等）、基于二阶导数的算子（Laplace算子、LoG算子等）、Canny 算子等。</p><h3 id="3-1Canny边缘检测"><a href="#3-1Canny边缘检测" class="headerlink" title="3.1Canny边缘检测"></a>3.1Canny边缘检测</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Canny</span><span class="params">( InputArray image, OutputArray edges,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">double</span> threshold1, <span class="type">double</span> threshold2,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">int</span> apertureSize = <span class="number">3</span>, <span class="type">bool</span> L2gradient = <span class="literal">false</span> )</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>src</code>输入图像,必须是8-bits;</li><li><code>edges</code>输出的图像边缘</li><li><code>threshold1, threshold2</code>对应的T1,T2：<ul><li>梯度值大于T2的像素点称为强边缘,保留作为图像边缘;</li><li>梯度值小于T1的像素点不是边缘,舍弃;</li><li>针对梯度值大于T1,小于T2的像素点,称为弱边缘;针对弱边缘,需要进一步判定其是否的真正的边缘像素点;判别的方法就是,<strong>当弱边缘像素点周围8个领域内存在强边缘像素时,则该弱边缘变成强边缘点,否则不是边缘点;</strong></li></ul></li><li><code>apertureSize</code>是<code>Sobel</code>算子的大小;</li><li><code>L2gradient</code>表示计算梯度值时是否使用L2(就是默认的计算方式);</li></ul><p>如果设置<code>L2gradient=True</code>,则梯度值的计算方式为:G&#x3D;|Gx|+|Gy|</p><h2 id="4基于聚类分割"><a href="#4基于聚类分割" class="headerlink" title="4基于聚类分割"></a>4基于聚类分割</h2><p>基于聚类的图像分割方法将具有特征相似性的像素点聚集到同一区域，反复迭代聚类结果至收敛，最终将所有像素点聚集到几个不同的类别中，完成图像区域的划分，从而实现分割，常用的方法有K-Means聚类等。</p><h2 id="5基于图论的图像分割方法"><a href="#5基于图论的图像分割方法" class="headerlink" title="5基于图论的图像分割方法"></a>5基于图论的图像分割方法</h2><p>基于图论的图像分割方法将分割问题转换成图的划分，通过对目标函数的最优化求解，完成分割过程，常用方法有Graph Cut 等图分割。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码命名规范</title>
      <link href="/2024/03/02/%E4%BB%A3%E7%A0%81%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
      <url>/2024/03/02/%E4%BB%A3%E7%A0%81%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p>内容来源：<a href="https://www.zhihu.com/question/31498049/answer/3288298579">https://www.zhihu.com/question/31498049/answer/3288298579</a></p><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p><a href="https://www.zhihu.com/search?q=%E8%9B%87%E5%BD%A2%E5%91%BD%E5%90%8D%E6%B3%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3288298579%7D">蛇形命名法</a>(Snake Case): <code>snake_case</code></p><p>短横线命名法(Kebab Case): <code>kebab-case</code></p><p><a href="https://www.zhihu.com/search?q=%E9%A9%BC%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%86%99&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3288298579%7D">驼峰式大小写</a>(Camel Case): <code>camelCase</code></p><p><a href="https://www.zhihu.com/search?q=%E5%B8%95%E6%96%AF%E5%8D%A1%E5%91%BD%E5%90%8D%E6%B3%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3288298579%7D">帕斯卡命名法</a>(Pascal Case): <code>PascalCase</code></p><p>全部小写(lowercase): <code>lowercaseall</code></p><p>大写(uppercase): <code>UPPER_CASE_WITH_UNDERSCORES</code></p><blockquote><p><a href="https://www.zhihu.com/search?q=%E7%9F%AD%E6%A8%AA%E7%BA%BF%E5%91%BD%E5%90%8D%E6%B3%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3288298579%7D">短横线命名法</a>: 多用于 css 名</p></blockquote><ul><li>函数命名, 变量命名, 文件命名要有描述性; 少用缩写。</li></ul><table><thead><tr><th>对象</th><th>规则</th><th>示例</th><th>Google</th><th>Qt</th></tr></thead><tbody><tr><td>目录</td><td>snake_case</td><td>snake_case</td><td>snake_case</td><td>PascalCase</td></tr><tr><td>C\C++文件</td><td>PascalCase</td><td>PascalCase.h</td><td>snake_case</td><td>lowercaseall &#x2F; PascalCase</td></tr><tr><td>类型</td><td>PascalCase</td><td>PascalCase</td><td>PascalCase</td><td>Q + PascalCase</td></tr><tr><td>变量</td><td>camelCase</td><td>camelCase</td><td>snake_case</td><td></td></tr><tr><td>参数</td><td>camelCase</td><td>camelCase</td><td>snake_case</td><td></td></tr><tr><td>类<a href="https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3288298579%7D">数据成员</a></td><td>m_ + camelCase</td><td>m_camelCase</td><td>snake_case + _</td><td>m_ + snake_case</td></tr><tr><td>静态变量</td><td>c + PascalCase</td><td>cPascalCase</td><td>k + PascalCase</td><td></td></tr><tr><td>全局变量</td><td>c + PascalCase</td><td>cPascalCase</td><td>k + PascalCase</td><td></td></tr><tr><td>函数 getter</td><td>camelCase()</td><td>camelCase()</td><td>snake_case()</td><td>camelCase()</td></tr><tr><td>函数 setter</td><td>setCamelCase()</td><td>setcamelCase()</td><td>set_snake_case()</td><td>setCamelCase()</td></tr><tr><td>函数 getter(bool)</td><td>isCamelCase()</td><td>isCamelCase()</td><td>snake_case()</td><td>isCamelCase()</td></tr><tr><td>函数 setter(bool)</td><td>setCamelCase()</td><td>setCamelCase()</td><td>set_snake_case()</td><td>setCamelCase()</td></tr><tr><td>函数</td><td>camelCase()</td><td>camelCase()</td><td>PascalCase</td><td>camelCase()</td></tr><tr><td>命名空间(最高级)</td><td>snake_case，顶级<a href="https://www.zhihu.com/search?q=%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3288298579%7D">命名空间</a>的名称应当是项目名</td><td>afm</td><td>snake_case</td><td></td></tr><tr><td>命名空间</td><td>snake_case</td><td>snake_case</td><td>snake_case</td><td></td></tr><tr><td><a href="https://www.zhihu.com/search?q=%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3288298579%7D">枚举类型</a></td><td>PascalCase</td><td>PascalCase</td><td>PascalCase</td><td></td></tr><tr><td><a href="https://www.zhihu.com/search?q=%E6%9E%9A%E4%B8%BE%E5%80%BC&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3288298579%7D">枚举值</a></td><td>c + PascalCase</td><td>cPascalCase</td><td>k + PascalCase</td><td></td></tr><tr><td>宏</td><td>UPPER_CASE_WITH_UNDERSCORES</td><td>UPPER_CASE_WITH_UNDERSCORES</td><td>UPPER_CASE_WITH_UNDERSCORES</td><td></td></tr><tr><td>其它文件</td><td>建议：小写单词</td><td>lower_case_with_underscores.png</td><td></td><td></td></tr></tbody></table><ul><li>使用通用的缩写，或者产品内部有共识的缩写字母</li><li>命名空间不要使用 <code>std</code></li><li>一些约定俗称的变量名是允许的。 <code>i,j,k</code> 用于迭代变量 <code>T</code> 用于模板参数</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Visual Studio的属性配置解释</title>
      <link href="/2024/02/27/Visual-Studio%E7%9A%84%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E8%A7%A3%E9%87%8A/"/>
      <url>/2024/02/27/Visual-Studio%E7%9A%84%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<blockquote><p>来源：<a href="https://blog.csdn.net/u012043391/article/details/54972127">包含目录、库目录、附加包含目录、附加库目录、附加依赖项之详解</a> 学习备份<br>VS项目中的包含目录、库目录、附加包含目录、附加库目录、附加依赖项均在”项目-&gt;属性-&gt;配置属性”下进行配置，具体说明如下：</p></blockquote><style>.uawunwcbhnom{zoom:67%;}</style><img src="/2024/02/27/Visual-Studio%E7%9A%84%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E8%A7%A3%E9%87%8A/image-20240227200847074.png" class="uawunwcbhnom" alt="image-20240227200847074"><h2 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h2><p>VC++目录：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">包含目录：寻找<span class="selector-id">#include</span>&lt;xxxx<span class="selector-class">.h</span>&gt;中的xxxx<span class="selector-class">.h</span>的搜索目录</span><br><span class="line"></span><br><span class="line">库目录：寻找<span class="selector-class">.lib</span>文件的搜索目录</span><br></pre></td></tr></table></figure><p>C&#x2F;C++：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常规-&gt;附加包含目录：寻找<span class="selector-id">#include</span>&lt;xxxx<span class="selector-class">.h</span>&gt;中的xxxx<span class="selector-class">.h</span>的搜索目录（每一项对应一个文件夹XXXX，文件夹中包含了编译时所需的头文件，使用时直接<span class="selector-id">#include</span>&lt;XXXX&gt;即可）</span><br></pre></td></tr></table></figure><p>链接器：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">常规-&gt;附加库目录：寻找<span class="selector-class">.lib</span>文件的搜索目录</span><br><span class="line"></span><br><span class="line">输入-&gt;附加依赖项：lib库（C++的库会把函数、类的声明放在*<span class="selector-class">.h</span>中，实现放在*<span class="selector-class">.cpp</span>或*<span class="selector-class">.cc</span>中。编译之后，*<span class="selector-class">.cpp</span>，*<span class="selector-class">.cc</span>，*<span class="selector-class">.c</span>会被打包成一个<span class="selector-class">.lib</span>文件，这样可以保护源代码）</span><br></pre></td></tr></table></figure><h2 id="区别与使用"><a href="#区别与使用" class="headerlink" title="区别与使用"></a>区别与使用</h2><h3 id="包含目录和附加包含目录（库目录和附加库目录）的区别："><a href="#包含目录和附加包含目录（库目录和附加库目录）的区别：" class="headerlink" title="包含目录和附加包含目录（库目录和附加库目录）的区别："></a>包含目录和附加包含目录（库目录和附加库目录）的区别：</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">包含目录：修改了系统的<span class="keyword">include</span>宏的值，是全局的；</span><br><span class="line"></span><br><span class="line">附加包含目录：用于当前项目，对其他项目没有影响。</span><br><span class="line"></span><br><span class="line">（库目录和附加库目录的区别同上）</span><br></pre></td></tr></table></figure><ol><li>可知包含目录和附加包含目录（库目录和附加库目录）的区别主要在于全局还是当前，那么当需要对某工程添加这些目录时，通常情况下，都是在附加包含目录和附加库目录中添加的。</li><li>要使用一个库，除了要include其头文件以外（附加包含目录），还要在链接过程中把lib加进去（附加库目录、附加依赖项）。</li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">附加包含目录---添加工程的头文件目录：</span><br><span class="line"></span><br><span class="line">  项目<span class="punctuation">-&gt;</span>属性<span class="punctuation">-&gt;</span>配置属性<span class="punctuation">-&gt;</span>C/C++<span class="punctuation">-&gt;</span>常规<span class="punctuation">-&gt;</span>附加包含目录：加上头文件的存放目录；</span><br><span class="line"></span><br><span class="line">附加库目录---添加文件引用的lib静态库路径：</span><br><span class="line"></span><br><span class="line">  项目<span class="punctuation">-&gt;</span>属性<span class="punctuation">-&gt;</span>配置属性<span class="punctuation">-&gt;</span>链接器<span class="punctuation">-&gt;</span>常规<span class="punctuation">-&gt;</span>附加库目录：加上lib文件的存放目录；</span><br><span class="line"></span><br><span class="line">附加依赖项---添加工程引用的lib文件名：</span><br><span class="line"></span><br><span class="line">  项目<span class="punctuation">-&gt;</span>属性<span class="punctuation">-&gt;</span>配置属性<span class="punctuation">-&gt;</span>链接器<span class="punctuation">-&gt;</span>输入<span class="punctuation">-&gt;</span>附加依赖项：加上lib文件名。</span><br></pre></td></tr></table></figure><p>参考<a href="https://zhuanlan.zhihu.com/p/37918581#:~:text=%E7%9B%AE%E5%89%8D%E4%BB%A5lib%E5%90%8E%E7%BC%80%E7%9A%84%E5%BA%93%E6%9C%89%E4%B8%A4%E7%A7%8D%EF%BC%8C%E4%B8%80%E7%A7%8D%E4%B8%BA%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%8C%E5%8F%A6%E4%B8%80%E7%A7%8D%E4%B8%BA%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5%E5%BA%93%E7%9A%84%E5%AF%BC%E5%85%A5%E5%BA%93%20%28Import%20Libary%EF%BC%8C%E7%AE%80%E7%A7%B0%E2%80%9C%E5%AF%BC%E5%85%A5%E5%BA%93%E2%80%9D%EF%BC%89%E3%80%82,%E9%9D%99%E6%80%81%E5%BA%93%E6%98%AF%E4%B8%80%E4%B8%AA%E6%88%96%E8%80%85%E5%A4%9A%E4%B8%AAobj%20%28%E4%B8%AD%E9%97%B4%E6%96%87%E4%BB%B6%29%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%8C%85%EF%BC%8C%E6%89%80%E4%BB%A5%E6%9C%89%E4%BA%BA%E5%B9%B2%E8%84%86%E6%8A%8A%E4%BB%8Eobj%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90lib%E7%9A%84%E8%BF%87%E7%A8%8B%E7%A7%B0%E4%B8%BAArchive%EF%BC%8C%E5%8D%B3%E5%90%88%E5%B9%B6%E5%88%B0%E4%B8%80%E8%B5%B7%E3%80%82%20%E6%AF%94%E5%A6%82%E4%BD%A0%E9%93%BE%E6%8E%A5%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E5%BA%93%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%85%B6%E4%B8%AD%E6%9C%89%E9%94%99%EF%BC%8C%E5%AE%83%E4%BC%9A%E5%87%86%E7%A1%AE%E7%9A%84%E6%89%BE%E5%88%B0%E6%98%AF%E5%93%AA%E4%B8%AAobj%E6%9C%89%E9%94%99%EF%BC%8C%E5%8D%B3%E9%9D%99%E6%80%81lib%E5%8F%AA%E6%98%AF%E5%A3%B3%E5%AD%90%E3%80%82%20%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%80%E8%88%AC%E4%BC%9A%E6%9C%89%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AF%BC%E5%85%A5%E5%BA%93%EF%BC%8C%E6%96%B9%E4%BE%BF%E7%A8%8B%E5%BA%8F%E9%9D%99%E6%80%81%E8%BD%BD%E5%85%A5%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%8C%E5%90%A6%E5%88%99%E4%BD%A0%E5%8F%AF%E8%83%BD%E5%B0%B1%E9%9C%80%E8%A6%81%EF%BC%88%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDdll%EF%BC%8C%E5%8D%B3%EF%BC%9A%EF%BC%89%E8%87%AA%E5%B7%B1LoadLibary%E8%B0%83%E5%85%A5DLL%E6%96%87%E4%BB%B6%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E6%89%8B%E5%B7%A5GetProcAddress%E8%8E%B7%E5%BE%97%E5%AF%B9%E5%BA%94%E5%87%BD%E6%95%B0%E4%BA%86%E3%80%82">动态链接库DLL和静态链接库Lib</a>的讲解，目前以lib后缀的库有两种，一种为静态链接库，另一种为动态连接库的导入库 (Import Libary，简称“导入库”）。动态链接库比较重要的文件有三个：.h .dll .lib；静态链接库比较重要的文件有两个：.h .lib。</p><ol><li>当需要向项目中添加.dll动态链接库时，直接将需要添加的.dll文件拖拽到项目生成的.exe所在的文件夹下即可（项目-&gt;属性-&gt;配置属性-&gt;常规-&gt;输出目录，可以看到.exe生成在哪个目录下）。</li><li>在添加上述几个目录的路径的时候，可以看到$(xxxx)，这就是宏了，可以点开右下角的宏查看这些分别代表什么字符串。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> vs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>奥比中光Femto Bolt相机</title>
      <link href="/2024/02/27/%E5%A5%A5%E6%AF%94%E4%B8%AD%E5%85%89Femto-Bolt%E7%9B%B8%E6%9C%BA%E8%AF%B4%E6%98%8E/"/>
      <url>/2024/02/27/%E5%A5%A5%E6%AF%94%E4%B8%AD%E5%85%89Femto-Bolt%E7%9B%B8%E6%9C%BA%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="几种深度相机对比"><a href="#几种深度相机对比" class="headerlink" title="几种深度相机对比"></a>几种深度相机对比</h2><p>参考了网上众多的资料，以下是其中一个视频中对市面上常见相机拍摄的点云结果对比，例如ZED MINI相机、OAK-D-LITE相机、OAK-D-PRO相机、D415相机、D435相机、Femto Bolt相机、Azure Kinect相机和L515相机等，如图所示。</p><img src="/2024/02/27/%E5%A5%A5%E6%AF%94%E4%B8%AD%E5%85%89Femto-Bolt%E7%9B%B8%E6%9C%BA%E8%AF%B4%E6%98%8E/image-20240227194218747.png" class="" title="image-20240227194218747"><p>其点云成像质量如下：</p><img src="/2024/02/27/%E5%A5%A5%E6%AF%94%E4%B8%AD%E5%85%89Femto-Bolt%E7%9B%B8%E6%9C%BA%E8%AF%B4%E6%98%8E/image-20240227194320228.png" class="" title="image-20240227194320228"><p>以上几款相机分别基于双目视觉、结构光和ToF飞行时间原理，从生成点云的质量效果上看，还是ToF原理的微软Kinect相机较好，如图所示。微软的深度相机依次经过以下几个版本的变化：Kinect V1、Kinect V2和Azure Kinect，目前以上三种深度相机都已停产。</p><img src="/2024/02/27/%E5%A5%A5%E6%AF%94%E4%B8%AD%E5%85%89Femto-Bolt%E7%9B%B8%E6%9C%BA%E8%AF%B4%E6%98%8E/image-20240227194428583.png" class="" title="image-20240227194428583"><img src="/2024/02/27/%E5%A5%A5%E6%AF%94%E4%B8%AD%E5%85%89Femto-Bolt%E7%9B%B8%E6%9C%BA%E8%AF%B4%E6%98%8E/image-20240227194433149.png" class="" title="image-20240227194433149"><h2 id="Femto-Bolt深度相机"><a href="#Femto-Bolt深度相机" class="headerlink" title="Femto Bolt深度相机"></a>Femto Bolt深度相机</h2><p>Femto Bolt深度相机是微软和奥比中光合作，在2023年10月最新推出的Azure Kinect的替代品，其相关硬件如图所示。</p><img src="/2024/02/27/%E5%A5%A5%E6%AF%94%E4%B8%AD%E5%85%89Femto-Bolt%E7%9B%B8%E6%9C%BA%E8%AF%B4%E6%98%8E/image-20240227194453313.png" class="" title="image-20240227194453313"><img src="/2024/02/27/%E5%A5%A5%E6%AF%94%E4%B8%AD%E5%85%89Femto-Bolt%E7%9B%B8%E6%9C%BA%E8%AF%B4%E6%98%8E/image-20240227194457093.png" class="" title="image-20240227194457093"><p>Femto Bolt 深度相机采用了微软最新的先进ToF传感技术，拥有与微软Azure Kinect深度相机完全一致的工作模式和性能表现，其拍摄的深度图效果如图所示。现Azure Kinect深度相机市场售价6000元左右，而Femto Bolt 深度相机价格2866元，综合比较可见Femto Bolt相机的性价比较高。</p><img src="/2024/02/27/%E5%A5%A5%E6%AF%94%E4%B8%AD%E5%85%89Femto-Bolt%E7%9B%B8%E6%9C%BA%E8%AF%B4%E6%98%8E/image-20240227194530212.png" class="" title="image-20240227194530212">]]></content>
      
      
      
        <tags>
            
            <tag> Orbbec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-应用编程</title>
      <link href="/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux应用编程"><a href="#Linux应用编程" class="headerlink" title="Linux应用编程"></a>Linux应用编程</h1><h2 id="Linux文件I-O编程"><a href="#Linux文件I-O编程" class="headerlink" title="Linux文件I&#x2F;O编程"></a>Linux文件I&#x2F;O编程</h2><p>Linux系统中，I&#x2F;O的类型可以分为标准I&#x2F;O与文件I&#x2F;O。同时针对I&#x2F;O的操作模式，也实现了阻塞I&#x2F;O、非阻塞I&#x2F;O、多路复用I&#x2F;O以及异步I&#x2F;O，这四种典型的模型。</p><p>标准I&#x2F;O和文件I&#x2F;O是为了实现对文件读写而封装的两套不同的用户程序编程接口，<strong>文件I&#x2F;O</strong>采用直接系统调用的方式实现对文件的读写；<strong>标准I&#x2F;O</strong>采用间接系统调用（库函数）的方式实现对文件的读写。</p><style>.uzkgttoylxqk{zoom: 50%;}</style><img src="/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/7766f41fb2da79b707371d53018949ce.png" class="uzkgttoylxqk" alt="Linux 编程基础1--文件IO和标准IO、系统调用与库函数_标准 i&#x2F;o 库函数 和 文件i&#x2F;o 系统调用-CSDN博客"><h3 id="Linux文件结构"><a href="#Linux文件结构" class="headerlink" title="Linux文件结构"></a>Linux文件结构</h3><p>在Linux中，一切都是文件。通常程序可以像使用文件那样使用磁盘文件、串行口、打印机和其他设备。大多数情况下，只需要使用5个基本的函数——open、close、read、write和ioctl。</p><p>文件，除了本身包含的内容以外，还有名字和一些属性，即”管理信息“，包括文件的创建、修改日期和访问权限。这些属性被保存在文件的inode节点中，这是文件系统中的一个特殊的数据块，同时它还包含文件的长度和文件在磁盘上的存放位置。</p><h4 id="文件的类型"><a href="#文件的类型" class="headerlink" title="文件的类型"></a>文件的类型</h4><p>（1）普通文件(regular file)。这种文件是最常见的文件类型，其数据形式可以是文本或二进制数据。</p><p>（2）目录文件(directory file)。这种文件包含其他类型文件的名字以及指向与这些文件有关的信息的指针。对一个目录文件具有读许可权的任一进程都可以读该目录文件的内容，但只有内核才有写目录文件的权限。</p><p>（3）字符设备文件(character special file)。这种文件被视为对字符设备的一种抽象，它代表的是应用程序对硬件设备的访问接口，Linux应用程序通过对该文件进行操作来实现对设备的访问。</p><p>（4）块设备文件(block special file)。这种文件类似于字符设备文件，只是它用于磁盘设备。Linux系统中的所有设备或者抽象为字符设备文件，或者为块设备文件。</p><p>（5）管道文件(pipe)。这种文件用于进程间的通信，有时也将其称为命名管道。</p><p>（6）套接字文件(socket)。这种文件用于进程间的网络通信，也可用于在一台宿主机上的进程之间的本地通信。</p><p>（7）符号链接文件(symbolic link)。这种文件指向另一个文件。</p><table><thead><tr><th>字符类型</th><th>说明</th></tr></thead><tbody><tr><td>b</td><td>块设备文件</td></tr><tr><td>c</td><td>字符设备文件</td></tr><tr><td>d</td><td>目录</td></tr><tr><td>-</td><td>普通文件</td></tr><tr><td>l</td><td>链接文件</td></tr><tr><td>s</td><td>套接字文件</td></tr><tr><td>p</td><td>管道文件</td></tr></tbody></table><p>在以上7种文件类型中，字符设备文件和块设备文件一般在学习linux驱动中使用，管道文件一般在进程通信中使用，套接字文件一般在Linux网络编程中使用，故这里暂时只对<u>目录文件和符号链接文件</u>进行说明。</p><h4 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h4><p>目录也是文件，它是一种特殊类型的文件。不过在现代的Linux中，即使是超级用户可能也不再被允许直接对目录进行写操作了。</p><p>目录是用于保存其他文件的节点号和名字的文件。目录文件中的每个数据项都是指向某个文件节点的链接，删除文件名就等于删除与之对应的链接。文件的节点号可以通过ln -i命令查看，也可以通过使用ln命令在不同的目录中创建指向同一个文件的链接。</p><p><code>删除目录中的一个文件，实质是删除该文件所对应的目录项，此时指向该文件的链接数减1。但是，该文件中的数据可能仍然能够通过其他指向该文件的链接访问到。如果，指向该文件的链接数变为0（比如使用ls -l命令后，输出内容中访问权限后面的那个数字），就表示该节点以及其指向的数据不再被使用，磁盘上的相应位置的存储空间会被标记为可用空间。</code></p><p>目录中包含文件，也包含子目录，这构成了文件系统的层次结构。根目录&#x2F;位于目录层次最顶端，下面的各级目录例如&#x2F;bin、&#x2F;etc、&#x2F;lib等子目录包含着系统中的所有文件。对于现实中的硬件设备，Linux文件系统为这些设备提供接口的文件一般放在&#x2F;dev子目录中。</p><style>.etxjblrrzwfb{zoom: 50%;}</style><img src="/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/640" class="etxjblrrzwfb" alt="图片"><h4 id="符号链接文件"><a href="#符号链接文件" class="headerlink" title="符号链接文件"></a>符号链接文件</h4><p>符号链接文件类似于Windows系统的快捷方式，只保留目标文件的地址，而不用占用存储空间。使用链接文件和使用目标文件的效果是一样的。符号链接文件指定不同的访问权限，以控制对文件的共享和保证安全性。</p><p>Linux中有两种类型的链接：硬链接和软链接。</p><p>硬链接是利用Linux系统中为每个文件分配的物理编号i节点建立链接。因此，硬链接不能跨越文件系统。硬链接的文件属性基本与源文件是基本一致的，可以进行同步更新。这种方式类似于Windows系统中将文件复制一份。</p><p>软链接是利用文件的路径名建立链接。通常建立软链接使用绝对路径而不是相对路径，以最大限度保证可移植性。软链接更像是Windows中创建快捷方式。软链接权限不会改变源文件（目标文件）的权限。</p><p>硬链接和软链接的不同之处在于：源文件删除后，软链接无法定位到源文件，所以会显示没有文件；硬链接类似于复制，删除源文件，硬链接依然可以访问。假如删除源文件后，重新创建一个同名文件，软链接将恢复；硬链接则不再有效。因为文件的i节点已经改变。</p><p>需要注意的是，修改硬链接的目标文件名，硬链接依然有效，软链接将断开；对一个已存在的链接文件执行移动或删除操作，有可能导致链接的断开。</p><h4 id="文件和设备"><a href="#文件和设备" class="headerlink" title="文件和设备"></a>文件和设备</h4><p>硬件设备在Linux中通常被映射为文件，比较重要的设备文件有3个：&#x2F;dev&#x2F;console、&#x2F;dev&#x2F;tty、&#x2F;dev&#x2F;null。</p><p>&#x2F;dev&#x2F;console：该设备是系统控制台，错误和诊断的信息通常会被发送到这个设备。每个UNIX系统都会有一个指定的终端或显示屏用来接收控制台消息。</p><p>&#x2F;dev&#x2F;tty：如果一个进程有控制终端，那么该设备文件就是这个终端（例如键盘、显示屏）的别名。若是系统自动运行的进程和脚本就没有控制终端，无法打开&#x2F;dev&#x2F;tty。</p><p>&#x2F;dev&#x2F;null：该文件是空设备文件，所有写向这个设备的输出都将被丢弃。若读该设备会立刻返回一个文件尾标志，在cp命令中可以利用它做复制空文件的源文件。常把不需要的输出重定向到&#x2F;dev&#x2F;null。</p><p>&#x2F;dev设备中的其他设备包括：硬盘软盘、通信端口、磁带驱动器、CD-ROM、声卡等设备的名字随系统的不同而不同，Linux发行版通常提供超级用户使用的应用程序，来管理普通用户无法访问的设备，例如挂载文件系统的mount命令。</p><p>设备被分为字符设备和块设备。两者区别在于访问设备时是否需要一次读写一整块。一般情况下，块设备是那些支持某些类型文件系统的设备，例如硬盘。</p><h3 id="系统调用说明"><a href="#系统调用说明" class="headerlink" title="系统调用说明"></a>系统调用说明</h3><p><strong>API</strong></p><p>应用程序接口API(Application Programming Interface) ，是程序员在用户空间下可以直接使用的函数接口，是一些预定义的函数，比如常用的read()、malloc()、free()、abs()函数等，这些函数都具有一定功能，说明了如何获得一个给定的服务，跟内核没有必然的联系。。</p><p><strong>系统调用</strong></p><p>操作系统负责管理和分配所有的计算机资源，为了更好地服务于应用程序，操作系统提供了一组特殊接口——系统调用接口层。系统调用接口层（System Call Iinterface，SCI）<u>介于应用层与内核层之间（系统调用接口层不属于内核层，但它是由内核函数实现的）</u>。为了安全考虑，应用程序不可以直接访问硬件资源。在单片机开发中，由于不需要操作系统，因此开发人员可以编写代码直接访问硬件；而在嵌入式系统中，通常需要操作系统，程序访问硬件资源的方式就发生了改变。</p><p>系统调用：使用少量的函数对文件和设备进行访问和控制。系统调用执行的流程如下：</p><p>（1）应用程序代码调用封装的func()函数，该函数是一个包装的系统调用的函数。</p><p>（2）func()函数负责准备向内核传递参数，并触发软中断int 0x80切换到内核。</p><p>（3）CPU被软中断打断后，执行中断处理函数，即系统调用处理函数（system_call）。</p><p>（4）system_call调用系统调用服务例程（sys_func），真正开始处理该系统调用。</p><p><strong>区别</strong></p><p>api是函数的定义，规定了这个函数的功能，跟内核无直接关系。而系统调用是通过中断向内核发请求，实现内核提供的某些服务。</p><p>程序员调用的是API（API函数），然后通过与系统调用共同完成函数的功能。 因此，API是一个提供给应用程序的接口，一组函数，是与程序员进行直接交互的。系统调用则不与程序员进行交互的，它是根据API函数，通过一个软中断机制向内核提交请求，以获取内核服务的接口。</p><h3 id="write系统调用"><a href="#write系统调用" class="headerlink" title="write系统调用"></a>write系统调用</h3><p>系统调用write的作用是把缓冲区buf的前nbytes个字节写入与文件描述符fildes关联的文件中。它返回实际写入的字节数。如果文件描述符有错或者底层的设备驱动程序对数据块长度比较敏感，该返回值可能会小于nbytes。如果这个函数返回0，就表示未写入任何数据：如果它返回的是-1，就表示在writei调用中出现了错误，错误代码保存在全局变量errno里。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">size t <span class="title function_">write</span><span class="params">(<span class="type">int</span> fildes, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((write(<span class="number">1</span>,<span class="string">&quot;Here is some data\n&quot;</span>,<span class="number">18</span>)) != <span class="number">18</span>)</span><br><span class="line">        write(<span class="number">2</span>,<span class="string">&quot;A write error has occurred on file descriptor 1\n&quot;</span>,<span class="number">46</span>);</span><br><span class="line">    <span class="built_in">exit</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><style>.jlproymkhifh{zoom:67%;}</style><img src="/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/image-20220412160356559.png" class="jlproymkhifh" alt="image-20220412160356559"><h3 id="read系统调用"><a href="#read系统调用" class="headerlink" title="read系统调用"></a>read系统调用</h3><p>系统调用read的作用是：从与文件描述符fildes相关联的文件里读入nbytes个字节的数据，并把它们放到数据区buf中。它返回实际读入的字节数，这可能会小于请求的字节数。如果read调用返回0，就表示未读入任何数据，己到达了文件尾。同样，如果返回的是-1，就表示read调用出现了错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fildes, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span>;</span><br></pre></td></tr></table></figure><h3 id="open系统调用"><a href="#open系统调用" class="headerlink" title="open系统调用"></a>open系统调用</h3><p>简单地说，open建立了一条到文件或设备的访问路径。如果调用成功，它将返回一个可以被read、writ和其他系统调用使用的文件描述符。这个文件描述符是唯一的，它不会与任何其他运行中的进程共享。如果两个程序同时打开同一个文件，它们会分别得到两个不同的文件描述符。如果它们都对文件进行写操作，那么它们会各写各的，它们分别接着上次离开的位置继续往下写。它们的数据不会交织在一起，而是彼此互相覆盖。两个程序对文件的读写位置（偏移值）不同。可以通过使用文件锁功能来防止出现冲突，在后面会介绍该功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> oflags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> oflags, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"></span><br><span class="line">#严格来说，在遵循POSIX规范的系统上，使用open系统调用并不需要包括头文件sys/types.h和sys/stat.h，但在某些UNIX系统上，它们可能是必不可少的。</span><br></pre></td></tr></table></figure><p>of1ags参数是通过必需文件访问模式与其他可选模式相结合的方式来指定的，open调用必须指定表中所示的文件访问模式之一。</p><style>.ezctzrgfiwil{zoom:67%;}</style><img src="/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/image-20220412161048941.png" class="ezctzrgfiwil" alt="image-20220412161048941"><p>open调用还可以在oflags参数中包括下列可选模式的组合(用“按位或 | ”操作)。</p><ul><li><p>O_APPEND:把写入数据追加在文件的末尾。</p></li><li><p>O_TRUNC:把文件长度设置为零，丢弃已有的内容。</p></li><li><p>O_CREAT:如果需要，就按参数mode中给出的访问模式创建文件。</p></li><li><p>O_EXCL:与O_CREAT一起使用，确保调用者创建出文件。Open调用是一个原子操作，也就是说，它只执行一个函数调用。使用这个可选模式可以防止两个程序同时创建同一个文件。如果文件己经存在，open调用将失败。其他可以使用的oflags值请参考open调用的手册页。</p></li></ul><p>当使用带有O_CREAT标志的open调用来创建文件时，你必须使用有3个参数格式的open调用。第三个参数mode是几个标志按位或后得到的，这些标志在头文件sys&#x2F;stat.h.中定义，如下所示。</p><ul><li><p>S_IRUSR:读权限，文件属主。</p></li><li><p>S_IWUSR:写权限，文件属主。</p></li><li><p>S_IXUSR:执行权限，文件属主。</p></li><li><p>S_IRGRP:读权限，文件所属组。</p></li><li><p>S_IWGRP:写权限，文件所属组。</p></li><li><p>S_IXGRP:执行权限，文件所属组。</p></li><li><p>S_IROTH:读权限，其他用户。</p></li><li><p>S_IW0TH:写权限，其他用户。</p></li><li><p>S_IXOTH:执行权限，其他用户。</p></li></ul><p>看下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open (<span class="string">&quot;myfile&quot;</span>,O_CREAT,S_IRUSR|S_IXOTH);</span><br></pre></td></tr></table></figure><p><code>有几个因素会对文件的访问权限产生影响。首先，指定的访问权限只有在创建文件时才会使用；其次，用户掩码(由shell的umask命令设定)会影响到被创建文件的访问权限。open调用里给出的mode值将与当时的用户掩码的反值做AND操作。举例来说，如果用户掩码被设置为001，并且指定了SIOH模式标志，那么其他用户对创建的文件不会拥有执行权限，因为用户掩码中指定了不允许向其他用户提供执行权限。因此，open和creat调用中的标志实际上是发出设置文件访问权限的请求，所请求的权限是否会被设置取决于当时umask的值。</code></p><h3 id="close系统调用"><a href="#close系统调用" class="headerlink" title="close系统调用"></a>close系统调用</h3><p>你可以使用close调用终止文件描述符fildes与其对应文件之间的关联。文件描述符被释放并能够重新使用。close调用成功时返回0，出错时返回-1.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fildes)</span>;</span><br></pre></td></tr></table></figure><p>注意，检查close调用的返回结果非常重要。有的文件系统，特别是网络文件系统，可能不会在关闭文件之前报告文件写操作中出现的错误，这是因为在执行写操作时，数据可能未被确认写入。</p><h3 id="ioctl系统调用"><a href="#ioctl系统调用" class="headerlink" title="ioctl系统调用"></a>ioctl系统调用</h3><p>ioctl调用有点像是个大杂烩。它提供了一个用于控制设备及其描述符行为和配置底层服务的接口。原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fildes, <span class="type">int</span> cmd, ...)</span>;</span><br></pre></td></tr></table></figure><h3 id="其他系统调用"><a href="#其他系统调用" class="headerlink" title="其他系统调用"></a>其他系统调用</h3><h4 id="lseek系统调用"><a href="#lseek系统调用" class="headerlink" title="lseek系统调用"></a>lseek系统调用</h4><p>lseek系统调用对文件描述符fildes的读写指针进行设置。也就是说，你可以用它来设置文件的下一个读写位置。读写指针既可被设置为文件中的某个绝对位置，也可以把它设置为相对于当前位置或文件尾的某个相对位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fildes, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><p>offset参数用来指定位置，而whence参数定义该偏移值的用法。whence可以取下列值之一。</p><ul><li>SEEK_SET: offset是一个绝对位置。</li><li>SEEK_CUR: offset是相对于当前位置的一个相对位置。</li><li>SEEK_END: offset是相对于文件尾的一个相对位置。</li></ul><p>lseek返回从文件头到文件指针被设置处的字节偏移值，失败时返回-1。参数offset的类型off_t是一个与具体实现有关的整数类型，它定义在头文件sys&#x2F;types.h中。</p><h4 id="fstat、stat和lstat系统调用"><a href="#fstat、stat和lstat系统调用" class="headerlink" title="fstat、stat和lstat系统调用"></a>fstat、stat和lstat系统调用</h4><p>fstat系统调用返回与打开的文件描述符相关的文件的状态信息，该信息将会写到一个buf结构中，buf的地址以参数形式传递给fstat。<br>下面是它们的原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fildes, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure><p><code>注意：包含头文件sys/types.h是可选的，但由于一些系统调用的定义针对那些某天可能会做出调整的标准类型使用了别名，所以但在程序中使用系统调用时，我们还是推荐将这个头文件包含进去。</code></p><p>相关函数stat和lstat返回的是通过文件名查到的状态信息。它们产生相同的结果，但当文件是一个符号链接时，lstat返回的是该符号链接本身的信息，而stat返回的是该链接指向的文件的信息。stat结构的成员在不同的类UNIX系统上会有所变化，但一般会包括表中所示的内容。</p><style>.ixoubbdsxlbr{zoom:67%;}</style><img src="/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/image-20220418165001235.png" class="ixoubbdsxlbr" alt="image-20220418165001235"><h4 id="dup和dup2系统调用"><a href="#dup和dup2系统调用" class="headerlink" title="dup和dup2系统调用"></a>dup和dup2系统调用</h4><p>dup系统调用提供了一种复制文件描述符的方法，使我们能够通过两个或者更多个不同的描述符来访问同一个文件。这可以用于在文件的不同位置对数据进行读写。dup系统调用复制文件描述符fildes，返回一个新的描述符。dup2系统调用则是通过明确指定目标描述符来把一个文件描述符复制为另外一个。<br>它们的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> fildes)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> fildes, <span class="type">int</span> fildes2)</span>;</span><br></pre></td></tr></table></figure><h3 id="文件维护相关调用"><a href="#文件维护相关调用" class="headerlink" title="文件维护相关调用"></a>文件维护相关调用</h3><h4 id="chmod系统调用"><a href="#chmod系统调用" class="headerlink" title="chmod系统调用"></a>chmod系统调用</h4><p>可以通过chmod系统调用来改变文件或目录的访问权限。这构成了shell程序chmod的基础。<br>该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path,<span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>path参数指定的文件被修改为具有mode参数给出的访问权限。参数mode的定义与open系统调用中的一样，也是对所要求的访问权限进行按位OR操作。除非程序被赋予适当的特权，否则只有文件的属主或超级用户可以修改它的权限。</p><h4 id="chown系统调用"><a href="#chown系统调用" class="headerlink" title="chown系统调用"></a>chown系统调用</h4><p>超级用户可以使用chown系统调用来改变一个文件的属主。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">uid_t</span> owner, gidt group)</span>;</span><br></pre></td></tr></table></figure><p>这个调用使用的是用户ID和组D的数字值(通过getuid和getgid调用获得)和一个用于限定谁可以修改文件属主的系统值。如果已经设置了适当的特权，文件的属主和所属组就会改变。</p><h4 id="unlink、link和symlink系统调用"><a href="#unlink、link和symlink系统调用" class="headerlink" title="unlink、link和symlink系统调用"></a>unlink、link和symlink系统调用</h4><p>可以使用unlink系统调用来删除一个文件。unlink系统调用删除一个文件的目录项并减少它的链接数。它在成功时返回0，失败时返回-1。如果想通过调用这个函数来成功别除文件，就必须拥有该文件所属目录的写和执行权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathl,<span class="type">const</span> <span class="type">char</span> *path2)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">symlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path1,<span class="type">const</span> <span class="type">char</span> *path2)</span>;</span><br></pre></td></tr></table></figure><p>如果一个文件的链接数减少到零，并且没有进程打开它，这个文件就会被别除。事实上，目录项总是被立刻删除，但文件所占用的空间要等到最后一个进程（如果有的话）关闭它之后才会被系统回收。程序使用的就是这个调用。文件上其他的链接表示这个文件还有其他名字，这通常是由ln程序创建的。你可以使用link系统调用在程序中创建一个文件的新链接。</p><h4 id="mkdir和rmdir系统调用"><a href="#mkdir和rmdir系统调用" class="headerlink" title="mkdir和rmdir系统调用"></a>mkdir和rmdir系统调用</h4><p>可以使用mkdir和rmdir系统调用来建立和删除目录。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path,<span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>mkdir系统调用用于创建目录，它相当于mkdir程序。mkdir调用将参数path作为新建目录的名字。目录的权限由参数mode设定，其含义将按open系统调用的O_CREAT选项中的有关定义设置。当然，它还要服从umask的设置情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure><p>rmdir系统调用用于删除目录，但只有在目录为空时才行。rmdir程序就是用这个系统调用来完成工作的。</p><h4 id="chdir系统调用和getcwd函数"><a href="#chdir系统调用和getcwd函数" class="headerlink" title="chdir系统调用和getcwd函数"></a>chdir系统调用和getcwd函数</h4><p>程序可以像用户在文件系统里那样来浏览目录。就像你在shell里使用cd命令来切换目录一样，程序使用的是chdir系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure><p>程序可以通过调用getcwd函数来确定自己的当前工作目录。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *buf,<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>getcwd函数把当前目录的名字写到给定的缓冲区buf里。如果目录名的长度超出了参数size给出的缓冲区长度(一个ERANGE错误)，它就返回NULL。如果成功，它返回指针buf。</p><p><code>如果在程序运行过程中，目录被删除(EINVAL错误)或者有关权限发生了变化（EACCESS错误），getcwd也可能会返回NULL.</code></p><h3 id="目录扫描相关调用"><a href="#目录扫描相关调用" class="headerlink" title="目录扫描相关调用"></a>目录扫描相关调用</h3><p>Linux系统上一个常见问题就是扫描目录，也就是确定一个特定目录下存放的文件。在shell程序设计中，这很容易做到——只需让shell做一次表达式的通配符扩展。在过去，UNIX操作系统的各种变体都允许用户通过编程访问底层文件系统结构。你仍然可以把目录当作一个普通文件那样打开，并直接读取目录数据项，但不同的文件系统结构及其实现已经使这种方法没什么可移植性了。现在，一整套标准的库函数已经被开发出来，使得目录的扫描工作变得简单多了。</p><p>与目录操作有关的函数在dirent.h头文件中声明。它们使用一个名为DIR的结构作为目录操作的基础。被称为目录流的指向这个结构的指针(DIR*)被用来完成各种目录操作，其使用方法与用来操作普通文件的文件流(FILE*)非常相似。目录数据项本身则在dirent结构中返回，该结构也是在dirent.h头文件里声明的，这是因为用户不应直接改动DIR结构中的数据字段。</p><p>dirent结构中包含的目录项内容包括以下部分。</p><ul><li>ino_t dino: 文件的inode节点号。</li><li>char d_name[ ]: 文件的名字。</li></ul><p>下面将介绍下面这几个函数：</p><ul><li>opendir、closedir</li><li>readdir</li><li>telldir</li><li>seekdir</li><li>closedir</li></ul><h4 id="opendir函数"><a href="#opendir函数" class="headerlink" title="opendir函数"></a>opendir函数</h4><p>opendiri函数的作用是打开一个目录并建立一个目录流。如果成功，它返回一个指向DIR结构的指针，该指针用于读取目录数据项。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure><p>opendir在失败时返回一个空指针。注意，目录流使用一个底层文件描述符来访问目录本身，所以如果打开的文件过多，opendir可能会失败。</p><h4 id="readdir函数"><a href="#readdir函数" class="headerlink" title="readdir函数"></a>readdir函数</h4><p>readdir函数返回一个指针，该指针指向的结构里保存着目录流dirp中下一个目录项的有关资料。后续的readdir调用将返回后续的目录项。如果发生错误或者到达目录尾，readdir将返回NULL。POSIX兼容的系统在到达目录尾时会返回NULL,但并不改变erno的值，只有在发生错误时才会设置errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure><p>注意，如果在readdir函数扫描目录的同时还有其他进程在该目录里创建或删除文件，readdir将不保证能够列出该目录里的所有文件（和子目录）。</p><h4 id="telldir函数"><a href="#telldir函数" class="headerlink" title="telldir函数"></a>telldir函数</h4><p>telldir函数的返回值记录着一个目录流里的当前位置。你可以在随后的seekdir调用中利用这个值来重置目录扫描到当前位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">telldir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure><h4 id="seekdir函数"><a href="#seekdir函数" class="headerlink" title="seekdir函数"></a>seekdir函数</h4><p>seekdir函数的作用是设置目录流dirp的目录项指针。loc的值用来设置指针位置，它应该通过前一个telldir调用获得。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">seekdir</span><span class="params">(DIR *dirp, <span class="type">long</span> <span class="type">int</span> loc)</span>;</span><br></pre></td></tr></table></figure><h4 id="closedir函数"><a href="#closedir函数" class="headerlink" title="closedir函数"></a>closedir函数</h4><p>closedir函数关闭一个目录流并释放与之关联的资源。它在执行成功时返同0，发生错误时返回-1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="错误处理调用"><a href="#错误处理调用" class="headerlink" title="错误处理调用"></a>错误处理调用</h3><p>前面介绍的许多系统调用和函数都会因为各种各样的原因而失败。它们会在失败时设置外部变量errno的值来指明失败的原因。许多不同的函数库都把这个变量用做报告错误的标准方法。值得重申的是，程序必须在函数报告出错之后立刻检查errno变量，因为它可能被下一个函数调用所覆盖，即使下一个函数自身并没有出错，也可能会覆盖这个变量。</p><p>错误代码的取值和含义都列在头文件errno.h里，如下所示。</p><ul><li>EPERM:操作不允许。</li><li>ENOENT:文件或目录不存在。</li><li>EINTR:系统调用被中断。</li><li>EIO:I&#x2F;O错误。</li><li>EBUSY:设备或资源忙。</li><li>EEXIST:文件存在。</li><li>EINVAL:无效参数。</li><li>EMFILE:打开的文件过多。</li><li>ENODEV:设备不存在。</li><li>EISDIR:是一个目录。</li><li>ENOTDIR:不是一个目录。</li></ul><p>有两个非常有用的函数可以用来报告出现的错误，它们是strerror和perror.</p><h4 id="strerror函数"><a href="#strerror函数" class="headerlink" title="strerror函数"></a>strerror函数</h4><p>strerror函数把错误代码映射为一个字符串，该字符串对发生的错误类型进行说明。这在记录错误条件时十分有用。</p><p>该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strerror</span><span class="params">(<span class="type">int</span> errnum)</span>;</span><br></pre></td></tr></table></figure><p>它可能在标准错误输出中给出如下的输出结果：</p><p><code>program: Too many open files</code></p><h4 id="perror函数"><a href="#perror函数" class="headerlink" title="perror函数"></a>perror函数</h4><p>perror函数也把errno变量中报告的当前错误映射到一个字符串，并把它输出到标准错误输出流。该字符串的前面先加上字符串s（如果不为空）中给出的信息，再加上一个冒号和一个空格。</p><p>该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure><h3 id="高级主题：fcntl和mmap"><a href="#高级主题：fcntl和mmap" class="headerlink" title="高级主题：fcntl和mmap"></a>高级主题：fcntl和mmap</h3><p>该部分较少使用。</p><h4 id="fcntl系统调用"><a href="#fcntl系统调用" class="headerlink" title="fcntl系统调用"></a>fcntl系统调用</h4><p>fcntl系统调用对底层文件描述符提供了更多的操纵方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fildes, <span class="type">int</span> cmd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fildes, <span class="type">int</span> cmd, <span class="type">long</span> arg)</span>;</span><br></pre></td></tr></table></figure><p>利用fcntl系统调用，你可以对打开的文件描述符执行各种操作，包括对它们进行复制、获取和设置文件描述符标志、获取和设置文件状态标志，以及管理建议性文件锁等。</p><p>对不同操作的选择是通过选取命令参数cmd不同的值来实现的，其取值定义在头文件fcntl.h中。根据所选择命令的不同，系统调用可能还需要第三个参数arg。</p><ul><li>fcntl(fildes, F_DUPFD, newfd): 这个调用返回一个新的文件描述符，其数值等于或大于整数newfd。新文件描述符是描述符fildes的一个副本。根据已打开文件数目和newfd值的情况，它的效果可能和系统调用dup(fildes)完全一样。</li><li>fcntl(fildes, F_GETFD): 这个调用返回在fcntl.h头文件里定义的文件描述符标志，其中包括FD_CLOEXEC，它的作用是决定是否在成功调用了某个exec系列的系统调用之后关闭该文件描述符。</li><li>fcntl(fildes, F_SETFD, flags): 这个调用用于设置文件描述符标志，通常仅用来设置FD_CLOEXEC。</li><li>fcntl(fildes, F_GETFL)和fcntl(fildes, F_SETFL, flags): 这两个调用分别用来获取和设置文件状态标志和访问模式。你可以利用在fcntl.h头文件中定义的掩码O_ACCMODE来提取出文件的访问模式。其他标志包括那些当open调用使用O_CREAT打开文件时作为第三参数出现的标志。注意，你不能设置所有的标志，特别是不能通过fcntl设置文件的权限。</li></ul><h4 id="mmap函数"><a href="#mmap函数" class="headerlink" title="mmap函数"></a>mmap函数</h4><p>UNX提供了一个有用的功能以允许程序共享内存，Liux内核从2.0版本开始已经把这一功能包括进来。map（内存映射）函数的作用是建立一段可以被两个或更多个程序读写的内存。一个程序对它所做出的修改可以被其他程序看见。</p><p>这要通过使用带特殊权限集的虚拟内存段来实现。对这类虚拟内存段的读写会使操作系统去读写磁盘文件中与之对应的部分。</p><p>mmap函数创建一个指向一段内存区域的指针，该内存区域与可以通过一个打开的文件描述符访问的文件的内容相关联。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fildes, <span class="type">off_t</span> off)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>通过传递off参数来改变经共享内存段访问的文件中数据的起始偏移值。</p></li><li><p>打开的文件描述符由fildes参数给出。</p></li><li><p>可以访问的数据量（即内存段的长度）由len参数设置。</p></li><li><p>你可以通过addr参数来请求使用某个特定的内存地址。如果它的取值是零，结果指针就将自动分配。这是推荐的做法，否则会降低程序的可移植性，因为不同系统上的可用地址范围是不一样的。</p></li><li><p>Prot参数用于设置内存段的访问权限。它是下列常数值的按位OR结果。</p><ul><li><p>PROT_READ: 允许读该内存段。</p></li><li><p>PROT_WRITE: 允许写该内存段。</p></li><li><p>PROT_EXEC: 允许执行该内存段。</p></li><li><p>PROT_NONE: 该内存段不能被访问。</p></li></ul></li><li><p>flags参数控制程序对该内存段的改变所造成的影响，可以使用的选项如下。</p><ul><li>MAP_PRIVATE: 内存段是私有的，对它的修改只对本进程有效。</li><li>MAP_SHARED: 把对该内存段的修改保存到磁盘文件中。</li><li>MAP_FIXED: 该内存段必须位于addr指定的地址处。</li></ul></li></ul><p><strong>msync函数</strong>的作用是：把在该内存段的某个部分或整段中的修改写回到被映射的文件中（或者从被映射文件里读出）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msync</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><p>内存段需要修改的部分由作为参数传递过来的起始地址addr和长度len确定。flags参数控制着执行修改的具体方式，可以使用的选项如下。</p><ul><li>MS_ASYNC: 采用异步写方式</li><li>MS_SYNC: 采用同步写方式</li><li>MS_INVALIDATE: 从文件中读回数据</li></ul><p><strong>munmap函数</strong>的作用是释放内存段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len)</span>;</span><br></pre></td></tr></table></figure><h3 id="proc文件系统"><a href="#proc文件系统" class="headerlink" title="&#x2F;proc文件系统"></a>&#x2F;proc文件系统</h3><p>Linux提供了一个特殊的文件系统procfs,它通常以&#x2F;proc目录的形式呈现。该目录中包含了许多特殊文件用来对驱动程序和内核信息进行更高层的访问。只要应用程序有正确的访问权限，它们就可以通过读写这些文件来获得信息或设置参数。</p><p>&#x2F;proc目录中的文件会随系统的不同而不同，当Linux&#x2F;版本中有更多的驱动程序和设施支持procfs文件系统时，该目录中就会包含更多的文件。在这里，将介绍一些&#x2F;proc目录中常用的文件，并简单讨论它们的用途。</p><style>.dukilywzjnpr{zoom: 50%;}</style><img src="/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/image-20220418194715505.png" class="dukilywzjnpr" alt="image-20220418194715505"><p>在多数情况下，只需直接读取这些文件就可以获得状态信息。</p><p>例如，&#x2F;proc&#x2F;cpuinfo给出的是cpu的详细信息：</p><style>.iewqzjqpuzpw{zoom: 50%;}</style><img src="/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/image-20220418194924696.png" class="iewqzjqpuzpw" alt="image-20220418194924696"><ul><li><p>类似地，&#x2F;proc&#x2F;meminfo和&#x2F;proc&#x2F;version分别给出的是内存使用情况和内核版本信息。</p></li><li><p>你可以通过特定内核函数获得更多的信息，它们位于&#x2F;proc目录的子目录中。例如，你可以通过&#x2F;proc&#x2F;net&#x2F;sockstat文件获得网络套接字的使用统计。</p></li><li><p>proc目录中的有些条目不仅可以被读取，而且可以被修改。例如，系统中所有运行的程序同时能打开的文件总数是Linux内核的一个参数。它的当前值可通过读取&#x2F;proc&#x2F;sys&#x2F;fs&#x2F;fi1e-max文件得到。</p></li><li><p>&#x2F;proc目录中以数字命名的子目录用于提供正在运行的程序的信息。</p></li></ul><h2 id="Linux标准I-O编程"><a href="#Linux标准I-O编程" class="headerlink" title="Linux标准I&#x2F;O编程"></a>Linux标准I&#x2F;O编程</h2><h3 id="标准I-O库概述"><a href="#标准I-O库概述" class="headerlink" title="标准I&#x2F;O库概述"></a>标准I&#x2F;O库概述</h3><p>针对输入输出操作直接使用底层系统调用的一个问题是它们的效率非常低：</p><ul><li><p>使用系统调用会影响系统的性能。与函数调用相比，系统调用的开销要大些，因为在执行系统调用时，Linux必须从运行用户代码切换到执行内核代码，然后再返回用户代码。减少这种开销的一个好方法是，在程序中尽量减少系统调用的次数，并且让每次系统调用完成尽可能多的工作。例如，每次读写大量的数据而不是每次仅读写一个字符。</p></li><li><p>硬件会限制对底层系统调用一次所能读写的数据块大小。</p></li></ul><p>为了给设备和磁盘文件提供更高层的接口，Linux发行版(和UNIX)提供了一系列的标准函数库。它们是一些由函数构成的集合，你可以把它们应用到自己的程序中，比如提供输出缓冲功能的标准&#x2F;O库。你可以高效地写任意长度的数据块，库函数则在数据满足数据块长度要求时安排执行底层系统调用。这就极大降低了系统调用的开销。</p><p>库函数有一个与之对应的标准头文件，例如与标准I&#x2F;O库对应的头文件是stdio.h。下图是对前面讨论的总结，它显示了Linux系统中各种文件函数与用户、设备驱动程序、内核和硬件之间的关系。</p><style>.jijsegdpqmna{zoom:67%;}</style><img src="/2024/02/27/linux-%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/image-20220412154827736.png" class="jijsegdpqmna" alt="image-20220412154827736"><p>标准I&#x2F;O库(stdio)及其头文件stdio.h为底层I&#x2F;O系统调用提供了一个通用的接口。这个库现在已经成为ANSI标准C的一部分，而前面见到的系统调用却还不是。标准I&#x2F;O库提供了许多复杂的函数用于格式化输出和扫描输入。它还负责满足设备的缓冲需求。</p><p>在很多方面，你使用标准&#x2F;O库的方式和使用底层文件描述符一样。你需要先打开一个文件以建立一个访问路径。这个操作的返回值将作为其他I&#x2F;O库函数的参数。在标准I&#x2F;O库中，与底层文件描述符对应的是流(stream)，它被实现为指向结构FILE的指针。</p><p><code>注意，不要把这里的文件流与C++语言中的输入输出流(iostream)以及AT&amp;T UNIX System V Release3中引入的进程间通信中的STREAMS模型相混淆，STEAMS模型不在本书的讨论范围之内。要想进一步了解STREAMS,请查阅X/Open规范(http:/www.opengroup.org)和随System V)版本一起提供的AT&amp;T STREAMS Programming Guide(《AT&amp;T STREAMS程序设计指南》）。</code></p><p>在启动程序时，有3个文件流是自动打开的。它们是stdin、stdout和stderr。它们都是在stdio.h头文件里定义的，分别代表着标准输入、标准输出和标准错误输出，与底层文件描述符0、1和2相对应。</p><p>下面主要介绍标准&#x2F;O库中的下列库函数：</p><ul><li>fopen、fclose</li><li>fread、fwrite</li><li>fflush-</li><li>fseek-</li><li>fgetc、getc、getchar</li><li>fputc、putc、putchar</li><li>fgets、gets</li><li>printf、fprintf和sprintf</li><li>scanf、fscanf和sscanf</li></ul><h4 id="fopen函数"><a href="#fopen函数" class="headerlink" title="fopen函数"></a>fopen函数</h4><p>fopen库函数类似于底层的open系统调用。它主要用于文件和终端的输入输出。如果需要对设备进行明确的控制，那最好使用底层系统调用，因为这可以避免用库函数带来的一些潜在问题，如输入输出缓冲。</p><p>该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br></pre></td></tr></table></figure><p>fopen:打开由filename参数指定的文件，并把它与一个文件流关联起来。mode参数指定文件的打开方式，它取下列字符串中的值。</p><ul><li>“r”或”rb”:以只读方式打开。</li><li>“w”或”wb”:以写方式打开，并把文件长度截短为零。</li><li>“a”或”ab”:以写方式打开，新内容追加在文件尾。</li><li>“r+”或”rb+”或”r+b”:以更新方式打开（读和写）。</li><li>“w+”或”wb+”或”w+b”:以更新方式打开，并把文件长度截短为零。</li><li>“a+”或”ab+”或”a+b”:以更新方式打开，新内容追加在文件尾。</li></ul><p><code>字母b表示文件是一个二进制文件而不是文本文件。</code></p><p><code>请注意，UNIX和Linux并不像MS-DOS那样区分文本文件和二进制文件。UNIX和Linux把所有文件都看作为二进制文件。另一个需要注意的地方是mode参数，它必须是一个字符串，而不是一个字符。所以总是应该使用双引号，而不是单引号。</code></p><p>fopen在成功时返回一个非空的FILE*指针，失败时返回ULL值，NULL值在头文件stdio.h里定义。可用的文件流数量和文件描述符一样，都是有限制的。实际的限制是由头文件stio.h中定义的FOPEN_MAX来定义的，它的值至少为8，在Linux系统中，通常是16。</p><h4 id="fread函数"><a href="#fread函数" class="headerlink" title="fread函数"></a>fread函数</h4><p>fread库函数用于从一个文件流里读取数据。数据从文件流stream读到由ptr指向的数据缓冲区里。fread和fwrite都是对数据记录进行操作，size参数指定每个数据记录的长度，计数器nitems给出要传输的记录个数。它的返回值是成功读到数据缓冲区里的记录个数（而<strong>不是字节数</strong>）。当到达文件尾时，它的返回值可能会小于nitems，甚至可以是零。</p><p>该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nitems, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><h4 id="fwrite函数"><a href="#fwrite函数" class="headerlink" title="fwrite函数"></a>fwrite函数</h4><p>fwrite库函数与fread有相似的接口。它从指定的数据缓冲区里取出数据记录，并把它们写到输出流中。它的返回值是成功写入的记录个数。</p><p>该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span> <span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nitems, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p><code>注意，不推荐把fread和fwrite用于结构化数据。部分原因在于用fwrite写的文件在不同的计算机体系结构之间可能不具备可移植性。</code></p><h4 id="fclose函数"><a href="#fclose函数" class="headerlink" title="fclose函数"></a>fclose函数</h4><p>fclose库函数关闭指定的文件流stream,使所有尚未写出的数据都写出。因为stdio库会对数据进行缓冲，所以使用fclose是很重要的。如果程序需要确保数据已经全部写出，就应该调用fclose函数。虽然当程序正常结束时，会自动对所有还打开的文件流调用fcIose函数，但这样做就没有机会检查由fclose报告的错误了。</p><p>该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><h4 id="fflush函数"><a href="#fflush函数" class="headerlink" title="fflush函数"></a>fflush函数</h4><p>fflush库函数的作用是把文件流里的所有未写出数据立刻写出。例如，可以用这个函数来确保在试图读入一个用户响应之前，先向终端送出一个交互提示符。使用这个函数还可以确保在程序继续执行之前重要的数据都已经被写到磁盘上。有时在调试程序时，还可以用它来确认程序是正在写数据而不是被挂起了。注意，调用fclose函数隐含执行了一次flush操作，所以你不必在调用fclose之前调用fflush。</p><p>该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fflush</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><h4 id="fseek函数"><a href="#fseek函数" class="headerlink" title="fseek函数"></a>fseek函数</h4><p>fseek函数是与lseek系统调用对应的文件流函数。它在文件流里为下一次读写操作指定位置。offset和whence参数的含义和取值与前面的lseek系统调用完全一样。但lseek返回的是一个off_t数值，而fseek返回的是一个整数：0表示成功，-1表示失败并设置errno指出错误。</p><p>该函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> <span class="type">int</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><h4 id="fgetc、getc和getchar函数"><a href="#fgetc、getc和getchar函数" class="headerlink" title="fgetc、getc和getchar函数"></a>fgetc、getc和getchar函数</h4><p>fgetc函数从文件流里取出下一个字节并把它作为一个字符返回。当它到达文件尾或出现错误时，它返回EOF，必须通过ferror或feof来区分这两种情况。</p><p>这些函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getc</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getchar</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>getc函数的作用和fgetc一样，但它有可能被实现为一个宏，如果是这样，stream参数就可能被计算不止一次，所以它不能有副作用(例如，它不能影响变量)。此外，你也不能保证能够使用getc的地址作为一个函数指针。getchar函数的作用相当于getc(stdin)，它从标准输入里读取下一个字符。</p><h4 id="fputc、putc和putchar函数"><a href="#fputc、putc和putchar函数" class="headerlink" title="fputc、putc和putchar函数"></a>fputc、putc和putchar函数</h4><p>futc函数把一个字符写到一个输出文件流中。它返回写入的值，如果失败，则返回EOF。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c,FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">putc</span><span class="params">(<span class="type">int</span> c,FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">putchar</span><span class="params">(<span class="type">int</span> c)</span>;</span><br></pre></td></tr></table></figure><p>类似于fgetc和getc之间的关系，putc函数的作用也相当于fputc,但它可能被实现为一个宏。putchar函数相当于putc(c,stdout)，它把单个字符写到标准输出。注意，putchar和getchar都是把字符当作int类型而不是char类型来使用的。这就允许文件尾(EOF)标识取值-1，这是一个超出字符数字编码范围的值。</p><h4 id="fgets和gets函数"><a href="#fgets和gets函数" class="headerlink" title="fgets和gets函数"></a>fgets和gets函数</h4><p>fgets函数从输入文件流stream里读取一个字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> n, FILE *stream)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure><p>fgets把读到的字符写到s指向的字符串里，直到出现下面某种情况：遇到换行符，己经传输了n-1个字符，或者到达文件尾。它会把遇到的换行符也传递到接收字符串里，再加上一个表示结尾的空字节\0。一次调用最多只能传输n-1个字符，因为它必须把空字节加上以结束字符串。</p><p>当成功完成时，fgets返回一个指向字符串s的指针。如果文件流己经到达文件尾，fgets会设置这个文件流的EOF标识并返回一个空指针。如果出现读错误，fgets返回一个空指针并设置errno以指出错误的类型。</p><p>gets函数类似于fgets,只不过它从标准输入读取数据并丢弃遇到的换行符。它在接收字符串的尾部加上一个null字节。</p><p><code>注意：gets对传输字符的个数并没有限制，所以它可能会溢出自己的传输缓冲区。因此，应该避免使用它并用fgets来代替。许多安全问题都可以追溯到在程序中使用了可能造成各种缓冲区溢出的函数，gets就是一个这样的函数，所以千万要小心！</code></p><h4 id="printf、fprintf和sprintf函数"><a href="#printf、fprintf和sprintf函数" class="headerlink" title="printf、fprintf和sprintf函数"></a>printf、fprintf和sprintf函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span> <span class="params">(<span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format,...)</span>;</span><br></pre></td></tr></table></figure><p>printf函数把自己的输出送到标准输出。fprintf函数把自己的输出送到一个指定的文件流。sprintf函数把自己的输出和一个结尾空字符写到作为参数传递过来的字符串s里。这个字符串必须足够容纳所有的输出数据。</p><p>普通字符在输出时不发生变化。转换控制符让printf取出传递过来的其他参数并对它们的格式过行编排。转换控制符总是以%字符开头。下面是一些常用的转换控制符。</p><ul><li>%d, %i: 以十进制格式输出一个整数。</li><li>%o, %x: 以八进制或十六进制格式输出一个整数。</li><li>%c: 输出一个字符。</li><li>%s: 输出一个字符串。</li><li>%f: 输出一个（单精度）浮点数。</li><li>%e: 以科学计数法格式输出一个双精度浮点数。</li><li>%g：以通用格式输出一个双精度浮点数。</li></ul><h4 id="scanf、fscanf和sscanf函数"><a href="#scanf、fscanf和sscanf函数" class="headerlink" title="scanf、fscanf和sscanf函数"></a>scanf、fscanf和sscanf函数</h4><p>scanf系列函数的工作方式与printf系列函数很相似，只是前者的作用是从一个文件流里读取数据，并把数据值放到以指针参数形式传递过来的地址处的变量中。它们也使用一个格式字符串来控制输入数据的转换，它所使用的许多转换控制符都与printf系列函数的一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">scanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *stream,<span class="type">const</span> <span class="type">char</span> *format,...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><p>scanf函数读入的值将保存到对应的变量里去，这些变量的类型必须正确，并且它们必须精确匹配格式字符串。否则，内存数据就可能会遭到破坏，从而使程序崩溃。编译器是不会对此做出错误提示的，但如果你运气够好，你可能会看到一个警告信息！</p><p>scanf系列函数的format格式字符串里同时包含着普通字符和转换控制符，就像printf函数中一样。但在scanf系列函数中，那些普通字符是用于指定在输入数据里必须出现的字符。</p><h4 id="其他流函数"><a href="#其他流函数" class="headerlink" title="其他流函数"></a>其他流函数</h4><p>stdio函数库里还有一些其他的函数使用流参数或标准流stdin、stdout和stderr,如下所示。</p><ul><li>fgetpos: 获得文件流的当前（读写）位置。</li><li>fsetpos: 设置文件流的当前（读写）位置。</li><li>ftell: 返回文件流当前（读写）位置的偏移值。</li><li>rewind: 重置文件流里的读写位置。</li><li>freopen: 重新使用一个文件流。</li><li>setvbuf: 设置文件流的缓冲机制。</li><li>remove: 相当于unlink函数，但如果它的path参数是一个目录的话，其作用就相当于rmdir函数。</li></ul><h4 id="文件流错误"><a href="#文件流错误" class="headerlink" title="文件流错误"></a>文件流错误</h4><p>为了表明错误，许多stdio库函数会返回一个超出范围的值，比如空指针或EOF常数。此时，错误由外部变量errno指出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> errno;</span><br></pre></td></tr></table></figure><p>注意，许多函数都可能改变errno的值。它的值只有在函数调用失败时才有意义。你必须在函数表明失败之后立刻对其进行检查。你应该总是在使用它之前将它先复制到另一个变量中，因为像fprintf这样的输出函数本身就可能改变errno的值。</p><p>你也可以通过检查文件流的状态来确定是否发生了错误，或者是否到达了文件尾。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ferror</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">clearerr</span><span class="params">(FILE *stream)</span></span><br></pre></td></tr></table></figure><p>ferror函数测试一个文件流的错误标识，如果该标识被设置就返回一个非零值，否则返回零。</p><p>feof函数测试一个文件流的文件尾标识，如果该标识被设置就返回非零值，否则返回零。我们可以像下面这样使用它：</p><p><code>if(feof (some_stream))</code></p><p>clearerr函数的作用是清除由stream指向的文件流的文件尾标识和错误标识。它没有返回值，也未定义任何错误。你可以通过使用它从文件流的错误状态中恢复。例如，在“磁盘己满”错误解决之后，继续开始写入文件流。</p><h4 id="文件流和文件描述符"><a href="#文件流和文件描述符" class="headerlink" title="文件流和文件描述符"></a>文件流和文件描述符</h4><p>每个文件流都和一个底层文件描述符相关联。你可以把底层的输入输出操作与高层的文件流操作混合使用，但一般来说，这并不是一个明智的做法，因为数据缓冲的后果难以预料。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fileno</span><span class="params">(FILE *stream)</span>;</span><br><span class="line">FILE *<span class="title function_">fdopen</span><span class="params">(<span class="type">int</span> fildes, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br></pre></td></tr></table></figure><p>你可以通过调用fileno函数来确定文件流使用的是哪个底层文件描述符。它返回指定文件流使用的文件描述符，如失败就返回-1。如果你需要对一个己经打开的文件流进行底层访问时（例如，对它调用fstat)，这个函数将很有用。</p><p>你可以通过调用fdopen函数在一个己打开的文件描述符上创建一个新的文件流。实质上，这个函数的作用是为一个已经打开的文件描述符提供stio缓冲区，这样解释可能更容易理解一些。</p><p>fdopen函数的操作方式与fopen函数是一样的，只是前者的参数不是一个文件名，而是一个底层的文件描述符。如果你已经通过open系统调用创建了一个文件（可能是出于为了更好地控制其访问权限的目的），但又想通过文件流来对它进行写操作，这个函数就很有用了。fdopen函数的mode参数与fopen函数的完全一样，但它必须符合该文件在最初打开时所设定的访问模式。fdopen返回一个新的文件流，失败时返回NULL。</p><h2 id="Linux-进程编程"><a href="#Linux-进程编程" class="headerlink" title="Linux 进程编程"></a>Linux 进程编程</h2><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>每种系统IPC进程间通信方式不十分一致，Linux综合了多个UNIX系统，主要有7种方式：</p><ul><li><p><del>file 文件</del></p></li><li><p>pipe 管道</p></li><li><p>singal 信号</p></li><li><p>System V IPC 机制</p><ul><li>semophore 信号量</li><li>semophore 共享内存</li><li>message queue 消息队列</li></ul></li><li><p>socket 套接字</p></li></ul><h4 id="pipe管道"><a href="#pipe管道" class="headerlink" title="pipe管道"></a>pipe管道</h4><p>当从一个进程连接数据流到另一个进程时，使用管道pipe。</p><p>例如shell中输入命令：<code>cmd1 | cmd2</code>，该命令经历以下过程：</p><ul><li>cmd1的标准输入来自终端键盘。</li><li>cmd1的标准输出传递给cmd2，作为它的标准输入。</li><li>cmd2的标准输出连接到终端屏幕。</li></ul><img src="《linux程序设计》阅读笔记/image-20220526104021506.png" alt="image-20220526104021506" style="zoom:67%;" /><h5 id="管道使用"><a href="#管道使用" class="headerlink" title="管道使用"></a>管道使用</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *<span class="title function_">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command, <span class="type">const</span> <span class="type">char</span> *open_mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pclose</span><span class="params">(FILE *stream_to_close)</span>;</span><br></pre></td></tr></table></figure><p><code>popen</code>函数允许一个程序将另外一个程序作为新进程来启动，他们之间可以传递数据。需要注意，一个管道只能单向传输信息，若想实现双向通信，需要使用两个管道。</p><ul><li>参数command为要运行的程序名和相应参数</li><li>参数open_mode取值为“r”时，调用popen的程序能够接收另外那个进程输出的数据，只需要使用标准I&#x2F;O库stdio中的函数（如fread函数）解析popen返回的FILE文件流即可；取值为“w”时，调用程序能够使用fwrite函数发送数据到另外那个进程，该进程可以从标准输入流中解析接收到的数据，一般来说进程并不知道接收到的数据是不是其他进程发送的，它只是简单地从标准输入流中接收并解析。</li></ul><p><code>pclose</code>函数负责关闭popen开启的文件流，并返回文件流关闭的退出码。pclose会一直等待popen完成后才执行，若调用程序在pclose执行前使用wait语句，那么退出状态会丢失，这时候返回-1，同时errno设置为ECHILD。</p><h5 id="先进先出管道：FIFOs"><a href="#先进先出管道：FIFOs" class="headerlink" title="先进先出管道：FIFOs"></a>先进先出管道：FIFOs</h5><p>为了在不相关的两个程序（即不是由共同祖先进程创建的）间进行数据传递，可以使用<code>FIFOs</code>，也称为命名管道<code>named pipes</code>。命名管道是一种特殊类型的文件（Linux中一切皆文件），在文件系统中有文件名，但行为和没有命名的管道类似。</p><p>可以使用命令行或者在程序中创建，命令行方法为输入<code>mkfifo filename</code>，在程序中创建方法如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syd/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mknod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">mode_t</span> mode | S_IFIFO, (<span class="type">dev_t</span>) <span class="number">0</span>)</span>;</span><br></pre></td></tr></table></figure><p><code>mknod</code>函数能创建许多特殊类型的文件，但唯一具有可移植性的方法是使用一个dev_t类型的0值，并将访问模式与S_IFIFO按位“或”。</p><p><strong>1、使用open打开FIFO文件</strong></p><p>使用open打开FIFO文件的主要限制是不能以O_RDWR的模式，因为管道是单向使用的，同样若想双向传递数据，应该使用两个FIFO。</p><p>打开FIFO文件和普通文件的区别是open函数第二个参数open_flag的O_NONBLOCK。使用该模式不仅会改变open函数的调用方式，还会改变open根据返回的文件描述符进行的读写请求方式。4种合法的结合形式如下：</p><ul><li>open(const char *path, O_RDONLY);</li><li>open(const char *path, O_RDONLY | O_NONBLOCK);</li><li>open(const char *path, O_WRONLY);</li><li>open(const char *path, O_WRONLY | O_NONBLOCK);</li></ul><h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><p>信号是UNIX和Linux系统响应某些条件而产生的一个事件。接收到该信号的进程会相应地采取一些行动。我们用术语生成(raise)表示一个信号的产生，使用术语捕获(catch)表示接收到一个信号。信号是由于某些错误条件而生成的，如内存段冲突、浮点处理器错误或非法指令等。它们由shell和终端处理器生成来引起中断，它们还可以作为在进程间传递消息或修改行为的一种方式，明确地由一个进程发送给另一个进程。无论何种情况，它们的编程接口都是相同的。信号可以被生成、捕获、响应或（至少对于一些信号）忽略。</p><p>信号的名称是在头文件signal.h中定义的。它们以SIG开头，见表。</p><img src="《linux程序设计》阅读笔记/image-20220525180744944.png" alt="image-20220525180744944" style="zoom:67%;" /><p><strong>如果进程接收到上面这些信号中的一个，但事先没有安排捕获它，进程将会立刻终止。</strong>通常，系统将生成核心转储文件core，并将其放在当前目录下。该文件是进程在内存中的映像，它对程序的调试很有用处。</p><p>其他信号：</p><img src="《linux程序设计》阅读笔记/image-20220525180917647.png" alt="image-20220525180917647" style="zoom:67%;" /><h5 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h5><p>进程可以通过调用<strong>kill函数</strong>向包括它本身在内的其他进程发送一个信号。如果程序没有发送该信号的权限，对kill函数的调用就将失败，失败的常见原因是目标进程由另一个用户所拥有。这个函数和同名的shell命令完成相同的功能，它的定义如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure><p>信号向我们提供了一个有用的闹钟功能。进程可以通过调用<strong>alam函数</strong>在经过预定时间后发送一个SIGALRM信号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure><p><strong>pause函数</strong>能将当前程序挂起直到有一个信号出现为止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p><strong>sigaction函数</strong>。上面的相关函数在传统的UNIX编程中较常见，而X&#x2F;Open和UNIX规范实现了更加强大的sigaction接口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oact)</span>;</span><br></pre></td></tr></table></figure><p>sigaction结构至少包括以下成员：<code>void (*) (int) sa_handler</code>、<code>sigset_t sa_mask</code>、<code>int sa_flags</code>。sa_handler为函数指针，指向收到信号sig后将调用的信号处理函数；sa_mask为信号集，在调用sa_handler指向的函数前，会先将其加入到信号屏蔽字中，其包含了将被阻塞且不会传递给该进程的信号。</p><h4 id="IPC机制：信号量、共享内存和消息队列"><a href="#IPC机制：信号量、共享内存和消息队列" class="headerlink" title="IPC机制：信号量、共享内存和消息队列"></a>IPC机制：信号量、共享内存和消息队列</h4><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">semctl</span><span class="params">(<span class="type">int</span> sem_id, <span class="type">int</span> semm_num, <span class="type">int</span> command, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> num_sems, <span class="type">int</span> sem_flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">semop</span><span class="params">(<span class="type">int</span> sem_id, <span class="keyword">struct</span> sembuf *sem_ops, <span class="type">size_t</span> num_sem_ops)</span>;</span><br></pre></td></tr></table></figure><p><code>semget</code>函数用于创建一个新信号量或取得一个已有信号量的键。程序对所有信号量的访问都是间接的，它先提供一个信号量键，再由系统生成一个相应的信号量标识符。只有semget函数能直接使用信号量键，其他信号量函数都是使用semget函数返回的信号量标识符。参数key是信号量键，不相关的进程可以通过它访问同一个信号量；参数num_ssems指定需要的信号量数目，取值一般为1；参数sem_flags和open函数的标志相似。</p><p><code>semop</code>函数用于改变信号量的值。</p><ul><li>参数sem_id是semget返回的信号量标识符</li><li>参数sem_ops是指向一个结构数组的指针，该结构数组包含以下成员<code>struct sembuf&#123;short sem_num; short sem_op; short sem_flg;&#125;</code>。成员sem_num为信号量编号，除非需要使用一组信号量，否则取值一般为0；成员sem_op为一次操作需要改变的数值，通常用到-1和+1两个值，-1为p操作表示它等待信号量变为可用，+1为v操作，此时它发送信号表示信号量现在可用；成员sem_flg一般被设置为SEM_UNDO，操作系统将跟踪当前进程对这个信号量的修改情况，若进程在没有释放该信号量的情况下终止，操作系统将自动释放该进程持有的信号量。</li></ul><p><code>semctl</code>函数用来直接控制信号量信息。</p><ul><li>参数sem_id为semget返回的信号量标识符。</li><li>参数sem_num同上所述。</li><li>参数command表示将要采取的动作。它可以设置许多值，常用的有两个：SETVAL表示将信号量初始化为一个已知的值，该值通过union semun结构中的val成员设置；IPC_RMID表示删除一个已经无需继续使用的信号量标识符。</li><li>若还有第四个参数，它是union semun结构，至少包含成员：<code>union semum&#123;int val; struct semid_ds *buf; unsigned short *array&#125;</code></li></ul><h5 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h5><p>共享内存允许不相关的两个进程访问同一个逻辑内存。不过它未提供同步机制，在第一个进程结束对共享内存的写操作前，并无自动的机制可以阻止第二个进程对其进行读写。</p><img src="《linux程序设计》阅读笔记/image-20220527064608117.png" alt="image-20220527064608117" style="zoom:67%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#innclude sys/shm.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">const</span> <span class="type">void</span> *shm_addr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shm_addr)</span>;</span><br></pre></td></tr></table></figure><p><code>shmget</code>函数用来创建共享内存，其返回值为一个共享内存标识符，标识符用于后续共享内存的其他函数。参数key为共享内存段命名；参数size为以字节为单位指定需要共享的内存容量；参数shmflg包含9个比特权限标志。</p><p><code>shmat</code>函数，返回值为指向共享内存的地址指针。第一次创建共享内存段时，它不能被任何进程访问，要想对其访问，必须将其连接到一个进程的地址空间中，该工作由shmat函数完成。参数shm_id为shmget函数返回的标识符；参数shm_addr指定共享内存连接到当前进程中的地址位置，一般为空指针，由系统选择共享内存出现的地址；参数shmflg为一组位标志，两个可能的取值为SHM_RND（与shm_addr参数一起使用，用来控制共享内存连接的地址）和SHM_RDONLY（使连接的内存只读）。</p><p><code>shmdt</code>函数用来将共享内存从当前进程中分离，使得当前进程不可再使用该共享内存。参数为shmat函数返回的地址指针。</p><p><code>shmctl</code>函数对共享内存进行控制。</p><ul><li>参数shm_id为shmget返回的标识符；</li><li>参数command为采取的动作，取值分别为IPC_STAT、IPC_SET和IPC_RMID。</li><li>参数buf为shmid_ds结构的指针，该结构包含成员：<code>struct shmid_ds&#123;uid_t shm_perm.uid; uid_t shm_perm.gid; mode_t shm_perm.mode;&#125;</code></li></ul><h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><p>消息队列和命名管道FIFO有相似之处，但少了在打开和关闭管道方面的复杂性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msg_ptr, <span class="type">size_t</span> msg_sz, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msg_ptr, <span class="type">size_t</span> msg_sz, <span class="type">long</span> <span class="type">int</span> msgtype, <span class="type">int</span> msgflg)</span>;</span><br></pre></td></tr></table></figure><p><code>msgget</code>函数用来创建一个消息队列。参数key为消息队列键；参数msgflg为9个权限标志。</p><p><code>msgsnd</code>函数用来把消息加到消息队列中。消息的结构需要注意“长度必须小于系统规定的上限”和“必须以长整型成员变量开始”这两个限制，消息的结构定义为：<code>struct my_message &#123;long int message_type; /*data*/&#125;</code>。参数msqid为msgget函数返回的标识符；参数msg_ptr为指向待发送消息的指针，注意消息的结构以长整型开始；参数msg_sz为指向消息的长度，长度不能包含长整型消息类成员变量长度；参数msgflg控制在当前消息队列满或队列消息到达系统范围的限制时将要发生的事情。</p><p><code>msgrcv</code>函数用来从一个消息队列中获取消息。参数msqid、msg_ptr和msg_sz如上所述；参数msgtype可以实现一种简单形式的接收优先级，若值为0则获取队列中第一个可用消息，若值大于0则获取具有相同类型的第一个消息，若值小于0则获取消息类型等于或小于msgtype绝对值的第一个消息；参数msgflg用于控制当队列中没有相应类型的消息可接收时将发生的动作。</p><p><code>msgctl</code>函数。</p><h4 id="socket套接字"><a href="#socket套接字" class="headerlink" title="socket套接字"></a>socket套接字</h4><p>前面几种进程通信方式，只有在同一台机器上的进程才能使用。socket套接字是管道概念的一个扩展，可以使同一台机器上的不同进程进行通信，也可以使不同机器上的进程之间进行通信，所以套接字还包括了计算机网络中的通信。</p><h5 id="套接字创建与运行"><a href="#套接字创建与运行" class="headerlink" title="套接字创建与运行"></a>套接字创建与运行</h5><p><strong>1、套接字属性</strong></p><p>套接字三个属性：域(domiain)、类型(type)和协议(protocol)。套接字还用地址作为名字，地址格式随域（协议族protocol family）不同而不同，每个协议族又可以用一个或多个地址族定义地址格式。</p><p><strong>域</strong>。域指定套接字通信中使用的网络介质，常见的域为<strong>AF_INET</strong>（AF_INET6表示Ipv6），用于网络套接字，它指Internet网络，其底层协议——网际协议IP使用IP地址来指定网络中的计算机。IP地址表示因特网中的服务器计算机，IP端口表示机器上某个特定的服务，外部程序通过IP地址和端口号的组合进行服务访问（标准服务有标准端口号，可以不用协商好端口号）。域为<strong>AF_UNIX</strong>用于本地套接字，其底层协议是文件输入&#x2F;输出，地址为文件名。</p><p><strong>套接字类型</strong>。域可能有多种通信方式，每种方式也有其不同特性。域为AF_INET时，其底层因特网协议则提供了以下两种通信机制：**流(stream)<strong>和</strong>数据报(datagram)**。流套接字由类型SOCK_STREAM指定，其在AF_INET域中通过TCP&#x2F;IP连接实现，详情参考TCP协议；数据报套接字由类型SOCK_DGRAM指定，其在AF_INET域中通过UDP&#x2F;IP连接实现，对发送的数据报有长度限制，详情参考UDP协议。</p><p><strong>套接字协议</strong>。若底层传输机制允许不止一个协议来提供套接字类型，就可以为套接字选择一个特定的协议。一般对于网络套接字和文件系统套接字，默认即可。</p><p><strong>2、创建套接字</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure><p>socket函数调用返回一个描述符，描述符用于read和write调用进行数据发送和接收，而close用于关闭套接字连接；其参数如前面所述，通信所用协议一般由domain和type决定，protocol设置为0表示使用默认协议。</p><p><strong>3、套接字地址</strong></p><p>每个域有自己的地址格式。对于AF_UNIX域，地址由结构sockaddr_un描述，其定义在头文件“sys&#x2F;un.”h中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span>&#123;</span></span><br><span class="line">  <span class="type">sa_family_t</span> sun_family;<span class="comment">//域</span></span><br><span class="line">  <span class="type">char</span> sun_path[];<span class="comment">//路径名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于AF_INET域，地址由结构sockaddr_in指定，其定义在头文件“netinet.h”中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> sin_family;<span class="comment">//域</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> sin_port;<span class="comment">//端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">//IP地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其中in_addr结构如下</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> s_addr;<span class="comment">//4字节组成32位的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4、命名套接字</strong></p><p>若让其他进程能够调用创建好的套接字，服务器程序需要给该套接字命名，这样AF_UNIX套接字会关联到一个文件系统的路径名，AF_INET套接字会关联到一个IP端口号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> socket, <span class="type">const</span> strcut sockaddr *address, <span class="type">size_t</span> address_len)</span>;</span><br></pre></td></tr></table></figure><p>参数socket为具体创建套接字的描述符；参数address使用通用地址类型(struct sockaddr *)，将上面介绍的两种具体地址类型进行转换，使地址与未命名的套接字进行绑定；参数address_len为地址结构的长度。</p><p><strong>5、创建套接字队列</strong></p><p>服务器程序须创建一个队列来保持未处理的连接请求，这使用listen系统调用完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> scoket, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure><p>参数backlog设置队列的长度，对未处理连接的数目进行限制，常用值为5。</p><p><strong>6、接受连接</strong></p><p>服务器程序创建并命名了套接字后，可以通过accept系统调用等待客户建立对该套接字的连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> socket, <span class="keyword">struct</span> sockaddr *address, <span class="type">size_t</span> *address_len)</span>;</span><br></pre></td></tr></table></figure><p>套接字必须先用<strong>bind</strong>命名，并用<strong>listen</strong>调用分配队列。连接的客户地址存放于address指向的结构中，若不关心客户地址，则address为空指针。</p><p>accept函数<u>将创建一个新套接字</u>来与客户进行通信，并返回新套接字的描述符，新套接字的类型和服务器监听套接字类型相同。若队列中没有未处理的连接，accept将阻塞（程序暂停）直到有客户建立连接为止。</p><p><strong>7、请求连接</strong></p><p>客户端通过connect调用，来将一个未命名的套接字和服务器的监听套接字进行连接，从而建立通信。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> socket, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *address, <span class="type">size_t</span> address_len)</span>;</span><br></pre></td></tr></table></figure><p><strong>8、关闭套接字</strong></p><p>通过<strong>close</strong>函数来终止服务器和客户端上的套接字连接。</p><p><strong>9、字节序问题</strong></p><p>通过套接字接口传递的端口号和地址都是二进制数字，不同计算机使用不同的字节序来表示整数。例如，Intel处理器将32为整数分为4个连续的字节，并按照小端字节序（高字节高内存，低字节低内存），而IBM则相反使用大端字节序，若两个处理数据不同的计算机以逐个字节的方式来复制，那么得到的最终数值就会不一致。</p><p>为了使其通过网络传输的多字节整数的值一致，需要定义一个网络字节序，服务器和客户端都必须在传输之前将主机内部整数表示方式转换为网络字节序，这个通过以下函数完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">htonl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> hostlong)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title function_">htons</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> hostshort)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> netlong)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> netshort)</span>;</span><br></pre></td></tr></table></figure><p>以上函数将16位和32位整数进行字节序转换，函数名是相应操作的简写，例如htonl表示“host to network,long”，若主机字节序和网络字节序相同，则为空操作。</p><h5 id="网络信息"><a href="#网络信息" class="headerlink" title="网络信息"></a>网络信息</h5><p>主机IP地址可以调用主机数据库函数来获取，若没有查询的主机或地址相关的数据项，则返回空指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyaddr</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> type)</span>;</span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其中函数返回的指针指向的结构体包括如下成员</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *h_name;<span class="comment">//主机名字</span></span><br><span class="line">    <span class="type">char</span> **h_aliase;<span class="comment">//别名列表</span></span><br><span class="line">    <span class="type">int</span> h_addrtype;<span class="comment">//地址类型</span></span><br><span class="line">    <span class="type">int</span> h_length;<span class="comment">//地址长度的字节数</span></span><br><span class="line">    <span class="type">char</span> **h_addr_list;<span class="comment">//地址列表（网络顺序）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与服务及其关联端口号相关信息，可以通过服务信息函数获取。其中proto参数指定连接的协议，取值为tcp或udp。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> servent *<span class="title function_">getservbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *proto)</span>;</span><br><span class="line"><span class="keyword">struct</span> servent *<span class="title function_">getservbyport</span><span class="params">(<span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span> *proto)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构servent至少包含以下成员</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *s_name;<span class="comment">//服务名称</span></span><br><span class="line">    <span class="type">char</span> **s_aliases;<span class="comment">//别名列表</span></span><br><span class="line">    <span class="type">int</span> s_port;<span class="comment">//IP端口号</span></span><br><span class="line">    <span class="type">char</span> *s_proto;<span class="comment">//服务的协议类型tcp或udp</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主机计算机数据库信息，可以调用gethostbyname函数，结果可以使用inet_ntoa将返回的地址从网络字节序转换为可以打印的字符串，字符串格式为“点分四元组”格式；而gethostname函数则是获取当前主机的名字，主机名字将被写入name指针指向的字符串中，若主机名太长，namelength会截断主机名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gethostname</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> namelength)</span>;</span><br></pre></td></tr></table></figure><h5 id="因特网守护进程"><a href="#因特网守护进程" class="headerlink" title="因特网守护进程"></a>因特网守护进程</h5><p>UNIX系统通常以超级服务器的方式来提供多项网络服务。超级服务器程序(因特网守护进程xinetd或inetd)同时监听许多端口地址上的连接。当有客户连接到某项服务时，守护程序就运行相应的服务器。这使得针对各项网络服务的服务器不需要一直运行着，它们可以在需要时启动。</p><p>因特网守护进程在现代Linux系统中是通过xinetd来实现的。xinetd实现方式取代了原来的UNIX程序inetd，尽管你仍然会在一些较老的Linux系统中以及其他的类UNIX系统中看到inetd的应用。</p><p>我们通常是通过一个图形用户界面来配置xinetd以管理网络服务，但我们也可以直接修改它的配置文件。它的配置文件通常是&#x2F;etc&#x2F;xinetd.conf和&#x2F;etc&#x2F;xinetd.d目录中的文件。每一个由xinetd提供的服务都在&#x2F;etc&#x2F;xinetd.d目录中有一个对应的配置文件。xinetd将在其启动时或被要求的情况下读取所有这些配置文件。</p><h5 id="套接字选项"><a href="#套接字选项" class="headerlink" title="套接字选项"></a>套接字选项</h5><p>可以使用许多选项来控制套接字连接的行为，使用setsockopt函数控制这些选项。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> socket, <span class="type">int</span> level, <span class="type">int</span> option_name, <span class="type">const</span> <span class="type">void</span> *option_value, <span class="type">size_t</span> option_len)</span>;</span><br></pre></td></tr></table></figure><p>其中参数level表示可以在协议层次的不同级别对选项进行设置。例如套接字级别设置为SOL_SOCKET，底层协议级别(如TCP、UDP)设置为该协议的编号（通过netinet&#x2F;in.h头文件或函数getprotobyname获取）。</p><p>选项名称和功能参考手册。</p><h5 id="select调用与多客户"><a href="#select调用与多客户" class="headerlink" title="select调用与多客户"></a>select调用与多客户</h5><p>在编写Linux程序时，经常会遇到需要检查好几个输入的状态才能确定下一步行动的情况。例如像终端仿真器的通信程序，需要有效同时读取键盘和串行口，若是在一个单用户的系统中，运行一个“忙等待”循环还可以接受，它不停扫描设备是否有数据，如果有数据到达就读取它，但就是很消耗CPU的时间。</p><p>select系统调用允许程序同时在多个底层文件描述符上等待输入的到达。这意味着终端仿真程序可以一直阻塞到有事情可做为止。类似地，服务器也可以通过同时在多个打开的套接字上等待请求到来的方法来处理多客户。</p><p><strong>select</strong>调用用于测试文件描述符集合中，是否有一个文件描述符已处于可读或可写状态或错误状态，它将阻塞以等待某个文件描述符进入上述这些状态。select系统调用原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure><p>select函数返回状态变化的描述符总数，会在以下情况返回：readfds有描述符可读、writefds有描述符可写或者errorsfds有描述符遇到错误条件，若以上3种情况都不发生，则超过timeout时间后会返回。参数<strong>nfds</strong>指定需测试的文件描述符数目，数量从0到(nfds-1)；其他三个参数<strong>readfds</strong>、<strong>writefds</strong>和<strong>errorfds</strong>可以被设置为空指针，表示不执行相应的测试；参数<strong>timeout</strong>用于防止无限期阻塞，若它是一个空指针并且套接字没有任何活动，这个调用将一直阻塞下去。</p><p>select函数对数据结构fd_set进行的操作，它是由打开的文件描述符构成的集合，有一组定义好的宏可以用来控制这些集合。<strong>FD_ZERO</strong>用于将fd_set初始化为空集合；<strong>FD_SET</strong>和<strong>FD_CLR</strong>分别用于在集合中设置和清除由参数fd传递的文件描述符；<strong>FD_ISSET</strong>函数用于当select返回时，可以测试描述符集合readfds、writefds和errorfds，找出需要注意的描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *fdset)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>;</span><br></pre></td></tr></table></figure><p>超时值由<strong>timeval</strong>结构控制：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">    <span class="type">time_t</span> tv_sec;<span class="comment">//秒，类型time_t被定义为一个整数</span></span><br><span class="line">    <span class="type">long</span> tv_usec;<span class="comment">//微秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="数据报与UDP"><a href="#数据报与UDP" class="headerlink" title="数据报与UDP"></a>数据报与UDP</h5><p>当客户需要发送一个短小的查询请求给服务器，并且期望接收到一个短小的响应时，我们一般就使用由UDP提供的服务。如果服务器处理客户请求的时间足够短，服务器就可以通过一次处理一个客户请求的方式来提供服务，从而允许操作系统将客户进入的请求放入队列。这简化了服务器程序的编写。</p><p>因为UDP提供的是不可靠服务，所以你可能发现数据报或响应会丢失。如果数据对于你来说非常重要，就需要小心编写UDP客户程序，以检查错误并在必要时重传。实际上，UDP数据报在局域网中是非常可靠的。</p><p>为了访问由UDP提供的服务，你需要像以前一样使用套接字和close系统调用，但你需要用两个数据报专用的系统调用sendto和recvfrom来代替原来使用在套接字上的read和write调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buffer, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr *from, <span class="type">socklen_t</span> *fromlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buffer, <span class="type">size_t</span> len, <span class="type">int</span> flgs, <span class="keyword">struct</span> sockaddr *from, <span class="type">socklen_t</span> *fromlen)</span>;</span><br></pre></td></tr></table></figure><p>flag参数一般设置为0。</p><h2 id="Linux-多线程编程"><a href="#Linux-多线程编程" class="headerlink" title="Linux 多线程编程"></a>Linux 多线程编程</h2><h2 id="Linux-tcp-ip网络编程"><a href="#Linux-tcp-ip网络编程" class="headerlink" title="Linux tcp&#x2F;ip网络编程"></a>Linux tcp&#x2F;ip网络编程</h2><h2 id="Linux系统信息获取"><a href="#Linux系统信息获取" class="headerlink" title="Linux系统信息获取"></a>Linux系统信息获取</h2><p>当为Linux(或UNIX和类UNIX系统)编写程序时，必须考虑到程序将在一个多任务环境中运行。这意味着在同一时间会有多个程序运行，它们共享内存、磁盘空间和CPU周期等机器资源。甚至同一程序也会有多个实例同时运行。最重要的是，这些程序能够互不干扰，能够了解它们的环境，并且能正确运行，不产生冲突(例如，试图与其他程序同时写同一个文件)。</p><p>程序能通过系统环境获得其相关运行条件的信息：</p><ul><li>向程序传递参数</li><li>环境变量</li><li>查看时间</li><li>临时文件</li><li>获得有关用户和主机的信息</li><li>生成和配置日志信息</li><li>了解系统各项资源的限制</li></ul><h4 id="程序参数"><a href="#程序参数" class="headerlink" title="程序参数"></a>程序参数</h4><p>当一个用C语言编写的Linux或UNIX程序运行时，它是从main函数开始的。对程序而言，main函数的声明如下所示：</p><p><code>int main(int argc, char *argv[])</code></p><p>shell将命令行输入的参数分解成单词并放入argv数组，argv[0]为程序名自身，若输入参数有n个，则共有n+1个实际参数。例如：<code>$ myprog left right &#39;and center&#39;</code></p><p>程序myprog将从main函数开始，main带的参数是：</p><p><code>argv: 4</code></p><p><code>argv: &#123;&quot;myprog&quot;, &quot;left&quot;, &quot;right&quot;, &quot;and center&quot;&#125;</code></p><p>一般在程序中，命令行参数设置有一定的原则：</p><ul><li>所有命令行开关都应以一个短横线 ‘-’ 开头，后面可以是数字或字母：-r -l。</li><li>若某选项需要值，该值应作为独立的参数紧跟在该选项后面：-xx value。</li><li>不带后续参数的选项可以在一个短横线后归并到一起：-lstr。</li><li>最好能为单字符开关增加一个更长的、更有意义的开关名：–help。</li></ul><h5 id="getopt函数"><a href="#getopt函数" class="headerlink" title="getopt函数"></a>getopt函数</h5><p>为了更好遵循上面的原则，Linux提供了getopt函数，它支持需要关联和非关联值的选项。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getopt</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *<span class="type">const</span> argv[ ], <span class="type">const</span> <span class="type">char</span> *optstring)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *optarg;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> optind, opterr, optopt;</span><br></pre></td></tr></table></figure><p>getopt函数将传递给程序的main函数的argc和argv作为参数，同时接受一个选项指定符字符串optstring，该字符串告诉getopt哪些选项可用，以及它们是否有关联值。optstring只是一个字符列表，每个字符代表一个单字符选项。如果一个字符后面紧跟一个冒号(：)，则表明该选项有一个关联值作为下一个参数。bash中的getopts命令执行类似的功能。</p><p>例如，我们可以用下面的调用来处理上面的例子：</p><p><code>getopt (argc, argv, &quot;if:lr&quot;);</code></p><p>它允许几个简单的选项：-i、-l、-r和-f，其中-f选项后要紧跟一个文件名参数。使用相同的参数，但以不同的顺序来调用命令将改变程序的行为。</p><p>getopt的返回值是argv数组中的下一个选项字符（如果有的话）。循环调用getopt就可以依次得到每个选项。getopt有如下行为。</p><p>如果选项有一个关联值，则外部变量optarg指向这个值。<br>如果选项处理完毕，getopt返回-1，特殊参数 ‘–’ 将使getopt停止扫描选项。</p><p>如果遇到一个无法识别的选项，getopt返回一个问号(？)，并把它保存到外部变量optopt中。</p><p>如果一个选项要求有一个关联值(例如例子中的-f)，但用户并未提供这个值，getopt通常将返回一个问号(？)。如果我们将选项字符串的第一个字符设置为冒号(：)，那么getopt将在用户未提供值的情况下返回冒号(：)而不是问号(？)。</p><p>外部变量optind被设置为下一个待处理参数的索引。getopt利用它来记录自己的进度。程序很少需要对这个变量进行设置。当所有选项参数都处理完毕后，optind将指向argv数组尾部可以找到其余参数的位置。</p><p><code>有些版本的getopt会在第一个非选项参数处停下来，返回-1并设置optind的值。而其他一些版本，如Linux提供的版本，能够处理出现在程序参数中任意位置的选项。注意，在这种情况下，getopt实际上重写了argv数组，把所有非选项参数都集中在一起，从argv[optind]位置开始。对GNU版本的getopt而言，这一行为是由环境变量POSIXLY_CORRECT控制的，如果它被设置，getopt就会在第一个非选项参数处停下来。此外，还有些getopt版本会在遇到未知选项时打印出错信息。注意，根据POSIX规范的规定，如果opterr变量是非零值，getopt就会向stderr打印一条出错信息。</code></p><h5 id="getopt-long函数"><a href="#getopt-long函数" class="headerlink" title="getopt_long函数"></a>getopt_long函数</h5><p>许多Linux应用程序也接受比我们在前面例子中所用的单字符选项含义更明确的参数。GNU C函数库包含getopt的另一个版本，称作getopt_long，它接受以双划线(-)开始的长参数。</p><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>UNIX规范为各种应用定义了许多标准环境变量，包括终端类型、默认的编辑器、时区等。C语言程序可以通过putenv和getenv函数来访问环境变量。</p><h5 id="putenv函数和getenv函数"><a href="#putenv函数和getenv函数" class="headerlink" title="putenv函数和getenv函数"></a>putenv函数和getenv函数</h5><p>环境由一组格式为“名字&#x3D;值”的字符串组成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">putenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="built_in">string</span>)</span>;</span><br></pre></td></tr></table></figure><p>getenv函数以给定的名字搜索环境中的一个字符串，并返回与该名字相关的值。如果请求的变量不存在，它就返回null。如果变量存在但无关联值，它将运行成功并返回一个空字符串，即该字符串的第一个字节是null。由于getenv返回的字符串是存储在getenv提供的静态空间中，所以如果想进一步使用它，你就必须将它复制到另一个字符串中，以免它被后续的getenv调用所覆盖。</p><p>putenv函数以一个格式为“名字&#x3D;值”的字符串作为参数，并将该字符串加到当前环境中。如果由于可用内存不足而不能扩展环境，它会失败并返回-1。此时，错误变量errno将被设置为ENOMEM。</p><p>在下面的实验中，你将编写一个程序来打印所选的任意环境变量的值。如果给程序传递第二个参数，你还将设置环境变量的值。</p><p><code>注意：环境仅对程序本身有效。你在程序里做的改变不会反映到外部环境中，这是因为变量的值不会从子进程（你的程序）传播到父进程(shell)。</code></p><h5 id="environ变量"><a href="#environ变量" class="headerlink" title="environ变量"></a>environ变量</h5><p>程序可以通过environ变量（一个以null结尾的字符串数组）直接访问这个字符串数组，其声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ</span><br></pre></td></tr></table></figure><p>例子，遍历并输出系统的环境变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> **env = environ;</span><br><span class="line">    <span class="keyword">while</span>(*env)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,*env);</span><br><span class="line">        env++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="《linux程序设计》阅读笔记/image-20220418221627496.png" alt="image-20220418221627496" style="zoom:50%;" /><h4 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h4><h5 id="time函数"><a href="#time函数" class="headerlink" title="time函数"></a>time函数</h5><p>时间通过一个预定义的类型time_t来处理。这是一个大到能够容纳以秒计算的日期和时间的整数类型。在Linux系统中，它是一个长整型，与处理时间值的函数一起定义在头文件time.h中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">time</span><span class="params">(<span class="type">time_t</span> *tloc)</span>;</span><br></pre></td></tr></table></figure><p>可以通过调用time函数得到底层的时间值，它返回的是从纪元开始至今的秒数。如果tloc不是一个空指针，time函数还会把返回值写入tloc指针指向的位置。</p><h5 id="difftime函数"><a href="#difftime函数" class="headerlink" title="difftime函数"></a>difftime函数</h5><p>以从1970年开始计算的秒数来表示时间和日期，对测算某些事情持续的时间是很有用的。可以把它考虑为简单地把两次调用time得到的值相减。然而ISO&#x2F;ANSI C标准委员会经过审议，并没有规定用time_t类型来测量任意时间之间的秒数，他们发明了一个函数difftime，该函数用来计算两个time_t值之间的秒数并以double类型返回它。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">difftime</span><span class="params">(<span class="type">time_t</span> timel, <span class="type">time_t</span> time2)</span>;</span><br></pre></td></tr></table></figure><h5 id="gmtime函数"><a href="#gmtime函数" class="headerlink" title="gmtime函数"></a>gmtime函数</h5><p>为了提供（对人类）更有意义的时间和日期，需要把时间值转换为可读的时间和日期。有一些标准函数可以帮我们做到这一点。gmtime函数把底层时间值分解为一个结构，该结构包含一些常用的成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">gmtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> timeval)</span>;</span><br></pre></td></tr></table></figure><p>tm结构被定义为至少包含表中所示的成员。</p><img src="《linux程序设计》阅读笔记/image-20220413154609767.png" alt="image-20220413154609767" style="zoom:67%;" /><p><code>不过，这儿有个小问题。如果在格林尼治标准时间(GMT)之外的时区运行这个程序，或者所在的地方像本例中那样采用了夏令时，你会发现时间（可能还有日期）是不对的。这是因为gmtime按GMT返回时间(现在GMT被称为世界标准时间，或UTC)Linux和UNIX这样做是为了同步全球各地的所有程序和系统。不同时区同一时刻创建的文件都会有相同的创建时间。要看当地时间，你需要使用localtime函数。</code></p><h5 id="localtime函数"><a href="#localtime函数" class="headerlink" title="localtime函数"></a>localtime函数</h5><p>使用localtime函数能输出当地时区的时间信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">localtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timeval)</span>;</span><br></pre></td></tr></table></figure><h5 id="mktime函数"><a href="#mktime函数" class="headerlink" title="mktime函数"></a>mktime函数</h5><p>使用mktime函数可以将localtime输出值转化为原始的时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">mktime</span><span class="params">(<span class="keyword">struct</span> tm *timeptr)</span>;</span><br></pre></td></tr></table></figure><h5 id="astime和ctime函数"><a href="#astime和ctime函数" class="headerlink" title="astime和ctime函数"></a>astime和ctime函数</h5><p>为了更“友好”地显示时间和日期，可以使用这两个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">astime</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> tm *timeptr)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">ctime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timeval)</span>;</span><br></pre></td></tr></table></figure><p>asctime函数返回一个字符串，它表示由tm结构timeptr所给出的时间和日期。这个返回的字符串有类似下面的格式，它总是这种长度为26个字符的固定格式：</p><p><code>Sun Jun 9 12:34:56 2007\n\0</code></p><p>ctime函数等效于调用下面这个函数，它以原始时间值为参数，并将它转换为一个更易读的本地时间：</p><p><code>asctime(localtime(timeval))</code></p><h5 id="strftime函数和strptime函数"><a href="#strftime函数和strptime函数" class="headerlink" title="strftime函数和strptime函数"></a>strftime函数和strptime函数</h5><p>为了对时间和日期字符串的格式有更多控制，Linux和现代的类UNIX系统提供了<strong>strftime函数</strong>。它很像是一个针对时间和日期的sprintf函数，工作方式也很类似：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strftime</span><span class="params">(<span class="type">char</span> *s, <span class="type">size_t</span> maxsize, <span class="type">const</span> <span class="type">char</span> *format, <span class="keyword">struct</span> tm *timeptr)</span>;</span><br></pre></td></tr></table></figure><p>strftime函数格式化timeptr指针指向的tm结构所表示的时间和日期，并将结果放在字符串s中。字符串被指定（至少）maxsize个字符长。format字符串用于控制写入字符串s的字符。与printf一样，它包含将被传给字符串的普通字符和用于格式化时间和日期元素的转换控制符。转换控制符见表。</p><img src="《linux程序设计》阅读笔记/image-20220418224755021.png" alt="image-20220418224755021" style="zoom:50%;" /><p>为了读取日期，你可以使用<strong>strptime函数</strong>，该函数以一个代表日期和时间的字符串为参数，并创建表示同一日期和时间的tm结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strptime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *format, <span class="keyword">struct</span> tm *timeptr)</span>;</span><br></pre></td></tr></table></figure><p>format字符串的构建方式和strftime的format字符串完全一样。strptime在字符串扫描方面类似于sscanf函数，也是查找可识别字段，并把它们写入对应的变量中。只是这里是根据format字符串来填充tm结构的成员。不过，strptimel的转换控制符与strftime的相比，限制要稍微松一些，因为strptime中的星期几和月份用缩写和全称都行，两者都匹配strptime中的a控制符，此外，strftime对小于10的数字总以0开头，而strptimel则把它看作是可选的。</p><p>strptime返回一个指针，指向转换过程处理的最后一个字符后面的那个字符。如果碰到不能转换的字符，转换过程就在该处停下来。调用程序需要检查是否己从传递的字符串中读入了足够多的数据，以确保tm结构中写入了有意义的值。</p><h4 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h4><p>很多情况下，程序会利用一些文件形式的临时存储手段。这些临时文件可能保存着一个计算的中间结果，也可能是关键操作前的文件备份。例如，一个数据库应用程序在删除记录时就可能使用临时文件。该文件收集需要保留的数据库条目，然后在处理结束后，这个临时文件就变成新的数据库，原来文件则被删除。</p><p>临时文件的这种用法很常见，但也有一个隐藏的缺点。必须确保应用程序为临时文件选取的文件名是唯一的。否则，因为Linux是一个多任务系统，另一个程序就可能选择同样的文件名，从而导致两个程序互相干扰。</p><h5 id="tmpna函数"><a href="#tmpna函数" class="headerlink" title="tmpna函数"></a>tmpna函数</h5><p>用tmpnam函数可以生成一个唯一的文件名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">tmpnam</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure><p>tmpnam函数返回一个不与任何己存在文件同名的有效文件名。如果字符串s不为空，文件名也会写入它。对tmpnaml的后续调用会覆盖存放返回值的静态存储区，所以如果tmpnam要被多次调用，就有必要给它传递一个字符串参数了。这个字符串的长度至少要有L_tmpnam(通常为20)个字符。tmpnam可以被一个程序最多调用TMP_MAX次（至少为几千次），每次它都会返回一个不同的文件名。</p><h5 id="tmpfile函数"><a href="#tmpfile函数" class="headerlink" title="tmpfile函数"></a>tmpfile函数</h5><p>如果遇到需要立刻使用临时文件的情况，你可以用tmpfile函数在给它命名的同时打开它。这点非常重要，因为另一个程序可能会创建出一个与tmpnam返回的文件名同名的文件。tmpfile函数则完全避免了这个问题的发生：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *<span class="title function_">tmpfile</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>tmpfile函数返回一个文件流指针，它指向一个唯一的临时文件。该文件以读写方式打开（通过w+方式的fopen)，当对它的所有引用全部关闭时，该文件会被自动删除。</p><p>如果出错，tmpfile返回空指针并设置errno的值。</p><h5 id="mktemp函数和mkstemp函数"><a href="#mktemp函数和mkstemp函数" class="headerlink" title="mktemp函数和mkstemp函数"></a>mktemp函数和mkstemp函数</h5><p>UNIX有另一种生成临时文件名的方式，就是使用mktemp和mkstemp函数。Linux也支持这两个函数，它们与tmpnam类似，不同之处在于可以为临时文件名指定一个模板，模板可以让你对文件的存放位置和名字有更多的控制：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">mktemp</span><span class="params">(<span class="type">char</span> *template)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkstemp</span><span class="params">(<span class="type">char</span> *template)</span>;</span><br></pre></td></tr></table></figure><p>mktemp函数以给定的模板为基础创建一个唯一的文件名。template参数必须是一个以6个x字符结尾的字符串。mktemp即函数用有效文件名字符的一个唯一组合来替换这些x字符。它返回一个指向生成的字符串的指针，如果不能生成一个唯一的名字，它就返回一个空指针。</p><p>mkstemp函数类似于tmpfile，它也是同时创建并打开一个临时文件。文件名的生成方法和mktemp一样，但是它的返回值是一个打开的、底层的文件描述符。</p><p><code>应该在程序中使用“创建并打开”函数tmpfile和mkstemp，而不要使用tmpnam和mktemp。</code></p><h4 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h4><p>除了init程序以外，所有的linux程序都是由其他程序或用户启动的。Linux运行的每个程序都是以某个用户的名义在运行，每个用户登录进入Linux系统时会有一个用户标识符UID，所以运行的程序会有一个关联的UID。</p><p>UID有自己的类型uid_t，定义在sys&#x2F;types.h中，是一个小整数。有些UID是系统预定义的，其他则是系统管理员在添加新用户时创建的。一般情况下，用户的UID值都大于100。</p><h5 id="getuid和getlogin函数"><a href="#getuid和getlogin函数" class="headerlink" title="getuid和getlogin函数"></a>getuid和getlogin函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">getuid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">getlogin</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>getuid函数返回程序关联的UID，它通常是启动程序的用户的UID。getlogin函数返回与当前用户关联的登录名。</p><p>系统文件&#x2F;etc&#x2F;passwd包含一个用户账号数据库。它由行组成，每行对应一个用户，包括用户名、加密口令、用户标识符(UID)、组标识符(GID)、全名、家目录和默认shell。下面是一个示例行：</p><p><code>neil:zBqxfgedfpk:500:100:Neil atthew:/home/neil:/bin/bash</code></p><p>如果编写一个程序，它能确定启动它的用户的UID，那么你就可以对它进行扩展，让它查找密码文件以找到用户的登录名和全名。</p><p>但我们并不推荐这种做法，因为为了提高系统的安全性，现代的类UNIX系统都不再使用简单的密码文件了。许多系统，包括Linux，都有一个使用shadow密码文件的选项，原来的密码文件中不再包含任何有用的加密口令信息（这些信息通常存放在&#x2F;etc&#x2F;shadow文件中，这是一个普通用户不能读取的文件）。为此，人们定义了一组函数来提供一个标准而有效的获取用户信息的编程接口。</p><h5 id="getpwuid和getpwnam函数"><a href="#getpwuid和getpwnam函数" class="headerlink" title="getpwuid和getpwnam函数"></a>getpwuid和getpwnam函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> password *<span class="title function_">getpwuid</span><span class="params">(<span class="type">uid_t</span> uid)</span>;</span><br><span class="line"><span class="keyword">struct</span> password *<span class="title function_">getpwnam</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure><p>密码数据库结构password定义在头文件pwd.h中，包含以下成员：</p><img src="《linux程序设计》阅读笔记/image-20220418232511926.png" alt="image-20220418232511926" style="zoom:67%;" /><p>有些UNIX系统可能对用户全名字段使用一个不同的名字。例如某些系统上是pw_gecos，其他系统是pw_comment。</p><p>getpwuid和getpwnam函数都返回一个指针，该指针指向某个用户对应的password结构。这个用户通过getpwuid的UID参数或通过getpwnam的用户登录名来确定。出错时，它们返回一个空指针并设置errno。</p><h5 id="getpwent函数"><a href="#getpwent函数" class="headerlink" title="getpwent函数"></a>getpwent函数</h5><p>如果要扫描密码文件中的所有信息，可以使用getpwent函数。它的作用是依次取出文件数据项：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">endpwent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">struct</span> password *<span class="title function_">getpwent</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setpwent</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>getpwent函数依次返回每个用户的信息数据项。当到达文件尾时，它返回一个空指针。</p><p>如果已经扫描了足够多的数据项，可以使用endpwent函数来终止处理过程。</p><p>setpwent函数重置读指针到密码文件的开始位置，这样下一个getpwent函数重新开始一个新的扫描。</p><h5 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h5><p>用户和组标识符还可以被其他一些不太常用的函数获得：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">geteuid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">gid_t</span> <span class="title function_">getgid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">gid_t</span> <span class="title function_">getegid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">#只有超级用户才能调用setuid和setgid函数</span><br><span class="line"><span class="type">int</span> <span class="title function_">setuid</span><span class="params">(<span class="type">uid_t</span> uid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setgid</span><span class="params">(<span class="type">gid_t</span> gid)</span>;</span><br></pre></td></tr></table></figure><h4 id="主机信息"><a href="#主机信息" class="headerlink" title="主机信息"></a>主机信息</h4><p>正如程序可以查找用户信息一样，程序也可以获得运行它的计算机的有关细节。</p><h5 id="gethostname函数"><a href="#gethostname函数" class="headerlink" title="gethostname函数"></a>gethostname函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gethostname</span><span class="params">(<span class="type">char</span> *name, <span class="type">size_t</span> namelen)</span>;</span><br></pre></td></tr></table></figure><p>gethostname函数把机器的网络名写入name字符串。该字符串至少有namelen个字符长。成功时，gethostname返回0，否则返回-1。</p><h5 id="uname函数"><a href="#uname函数" class="headerlink" title="uname函数"></a>uname函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/utsname.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">uname</span><span class="params">(<span class="keyword">struct</span> utsname *name)</span>;</span><br></pre></td></tr></table></figure><p>uname函数主机信息写入name参数指向的结构。utsname结构定义在头文件sys&#x2F;utsname.h中，至少包括以下成员：</p><img src="《linux程序设计》阅读笔记/image-20220418235142742.png" alt="image-20220418235142742" style="zoom:67%;" /><p>uname成功时返回一个非负整数，否则返回-1并设置errno来指出错误。</p><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>许多应用程序需要记录它们的活动。系统程序经常需要向控制台或日志文件写消息。这些消息可能指示错误、警告或是与系统状态有关的一般信息。</p><h5 id="syslog函数"><a href="#syslog函数" class="headerlink" title="syslog函数"></a>syslog函数</h5><p>虽然系统消息的格式和存储方式不尽相同，但产生消息的方法却是标准的。UNIX规范通过syslog函数为所有程序产生日志信息提供了一个接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syslog</span><span class="params">(<span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span> *message, arguments...)</span>;</span><br></pre></td></tr></table></figure><p>syslog函数向系统的日志设施（facility）发送一个日志信息。每条信息都有一个priority参数，该参数是一个<strong>严重级别</strong>与一个<strong>设施值</strong>的<u>按位或</u>。其中，严重级别控制日志信息的处理方式，设施值记录日志信息的来源。</p><p>定义在头文件syslog.h中的<strong>设施值</strong>包括LOG_USER（默认值）——它指出消息来自一个用户应用程序，以及LOG_LOCAL0、LOG_LOCAL1直到LOG_LOCAL7，它们含义由本地管理员指定。</p><p><strong>严重级别</strong>按优先级递减排列：</p><img src="《linux程序设计》阅读笔记/image-20220419000555074.png" alt="image-20220419000555074" style="zoom:67%;" /><p>根据系统配置，LOG_EMERG信息可能会广播给所有用户，LOG_ALERT信息可能会EMAIL给管理员，LOG_DEBUG信息可能会被忽略，而其他信息则写入日志文件。</p><p>syslog创建的日志信息包含消息头和消息体。消息头根据设施值及日期和时间创建。消息体根据syslog的message参数创建，该参数的作用类似printf中的格式字符串。syslog的其他参数根据message字符串中printf风格的转换控制符而定。</p><p>此外，转换控制符%m可用于插入与错误变量errno当前值对应的出错消息字符串，对于记录错误消息很有用。</p><p><code>例：syslog(LOG_ERR | LOG_USER, &quot;oops-%m\n&quot;);</code></p><h5 id="其他函数-1"><a href="#其他函数-1" class="headerlink" title="其他函数"></a>其他函数</h5><p>在头文件syslog.h中还定义了一些能够改变日志记录行为的其他函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">closelog</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">openlog</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ident, <span class="type">int</span> logopt, <span class="type">int</span> facility)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setlogmask</span><span class="params">(<span class="type">int</span> maskpri)</span>;</span><br></pre></td></tr></table></figure><p>你可以通过调用openlog函数来改变日志信息的表示方式。它可以设置一个字符串ident，该字符串会添加在日志信息的前面。你可以通过它来指明是哪个程序创建了这条信息。facility参数记录一个将被用于后续syslog调用的默认设施值，其默认值是LOG_USER。logopt参数对后续syslog调用的行为进行配置，它是0个或多个表中参数的按位或。</p><img src="《linux程序设计》阅读笔记/image-20220419001914154.png" alt="image-20220419001914154" style="zoom:67%;" /><p>openlog函数会分配并打开一个文件描述符，并通过它来写日志。你可以调用closelog函数来关闭它。注意，在调用syslog.之前无需调用openlog,因为syslog会根据需要自行打开日志设施。</p><p>你可以使用setlogmask函数来设置一个日志掩码，并通过它来控制日志信息的优先级。优先级未在日志掩码中置位的后续syslog调用都将被丢弃。所以你可以通过这个方法关闭LOG_DEBUG消息而不用改变程序主体。</p><p>你可以用LOG_MASK(priority)为日志信息创建一个掩码，它的作用是创建一个只包含一个优先级的掩码。你还可以用LOG_UPTO(priority)来创建一个由指定优先级之上的所有优先级（包括指定优先级）构成的掩码。</p><h4 id="资源和限制"><a href="#资源和限制" class="headerlink" title="资源和限制"></a>资源和限制</h4><p>Linux系统上运行的程序会受到资源限制的影响。它们可能是硬件方面的物理性限制（例如内存）、系统策略的限制(例如，允许使用的CPU时间)或具体实现的限制（如整数的长度或文件名中所允许的最大字符数）。UNIX规范定义了一些可由应用程序决定的限制。</p><p>头文件limits.h中定义了许多代表操作系统方面限制的显式常量，如表所示。</p><img src="《linux程序设计》阅读笔记/image-20220419002212785.png" alt="image-20220419002212785" style="zoom:67%;" /><p><code>注意：NAME_MAX是特定于文件系统的。为了写可移植性更好的代码，你应该使用pathconf函数。详细信息请参考pathconf的手册页。</code></p><p>头文件sys&#x2F;resource.h提供了资源操作方面的定义，其中包括对程序长度、执行优先级和文件资源等方面限制进行查询和设置的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getpriority</span><span class="params">(<span class="type">int</span> which, <span class="type">id_t</span> who)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setpriority</span><span class="params">(<span class="type">int</span> which, <span class="type">id_t</span> who, <span class="type">int</span> priority)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="keyword">struct</span> rlimit *r_limit)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setrlimit</span> <span class="params">(<span class="type">int</span> resource, <span class="type">const</span> <span class="keyword">struct</span> rlimit *r_limit)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getrusage</span><span class="params">(<span class="type">int</span> who, <span class="keyword">struct</span> rusage *r_usage)</span>;</span><br></pre></td></tr></table></figure><p>id_t是一个整数类型，它用于用户和组标识符。在头文件sys&#x2F;resource.h中定义的rusage结构用来确定当前程序已耗费了多少CPU时间，它至少包含如下两个成员。</p><ul><li>struct timeval ru_utime: 使用的用户时间</li><li>struct timeval ru_stime: 使用的系统时间</li></ul><p>***暂略！</p><h2 id="Linux数据管理"><a href="#Linux数据管理" class="headerlink" title="Linux数据管理"></a>Linux数据管理</h2><p>数据管理的3个方面。</p><ul><li>动态内存管理：可以做什么以及Liux不允许做什么。</li><li>文件锁定：协调锁、共享文件的锁定区域和避免死锁。</li><li>dbm数据库：一个大多数Linux系统都提供的、基本的、不基于SQL的数据库函数库。</li></ul><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p>Linux为应用程序提供了一个简洁的视图，它能反映一个巨大的可直接寻址的内存空间。</p><p>此外，Linux还提供了内存保护机制，它避免了不同的应用程序之间的互相干扰。</p><p>如果机器被正确配置并且有足够的交换空间，Linux还允许应用程序访问比实际物理内存更大的内存空间。</p><h5 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h5><p>使用标准C语言函数库中的malloc调用来分配内存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="comment">//为一个结构数组分配内存，返回结果为第一个元素的指针</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> number_of_elements, <span class="type">size_t</span> element_size)</span>;</span><br><span class="line"><span class="comment">//改变之前分配的内存块的大小，使用该函数后应使用返回的新的内存指针</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *existing_memory, <span class="type">size_t</span> new_size)</span>;</span><br></pre></td></tr></table></figure><p>刚开始时，内核只是通过使用空闲的物理内存来满足应用程序的内存请求，但是当物理内存耗尽时，它便会开始使用所谓的交换空间(swap space)。在Linux系统中，交换空间是一个在安装系统时分配的独立的磁盘区域。如果熟悉Windows操作系统的话，Linux交换空间的作用有点像隐藏的Windows交换文件。但与Windows不同，Linux的交换空间中没有局部堆、全局堆或可丢弃内存段等需要在代码中操心的内容——Linux内核会为你完成所有的管理工作。</p><p>内核会在物理内存和交换空间之间移动数据和程序代码，使得每次读写内存时，数据看起来总像是已存在于物理内存中，而不管在你访问它们之前，它们究竟是在哪里。用更专业的术语来说，Linux实现了一个“按需换页的虚拟内存系统”。用户程序看到的所有内存全是虚拟的，也就是说，它并不真正存在于程序使用的物理地址上。Linux将所有的内存都以页为单位进行划分，通常每一页的大小为4096字节。每当程序试图访问内存时，就会发生虚拟内存到物理内存的转换，转换的具体实现和耗费的时间取决于你所使用的特定硬件情况。当所访问的内存在物理上并不存在时，就会产生一个页面错误并将控制权交给内核。</p><p>Linux内核会对访问的内存地址进行检查，如果这个地址对于程序来说是合法可用的，内核就会确定需要向程序提供哪一个物理内存页面。然后，如果该页面之前从未被写入过，内核就直接分配它，如果它己经被保存在硬盘的交换空间上，内核就读取包含数据的内存页面到物理内存（可能需要把一个已有页面从内存中移出到硬盘）。接着，在完成虚拟内存地址到物理地址的映射之后，内核允许用户程序继续运行。Linux应用程序并不需要操心这一过程，因为所有的具体实现都已隐藏在内核中了。最终，当应用程序耗尽所有的物理内存和交换空间，或者当最大栈长度被超过时，内核将拒绝此后的内存请求，并可能提前终止程序的运行。</p><h5 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h5><p>动态使用内存的程序应该总是通过free调用，来把不用的内存释放给malloc内存管理器。这样做可以将分散的内存块重新合并到一起，并由malloc函数库而不是应用程序来管理它。如果一个运行中的程序（进程）自己使用并释放内存，则这些自由内存实际上仍然处于被分配给该进程的状态。</p><p>在幕后，Linux将程序员使用的内存块作为一个物理页面集来管理，通常内存中的每个页面为4K字节。但如果一个内存页面未被使用，Linux内存管理器就可以将其从物理内存置换到交换空间中（术语叫换页），从而减轻它对资源使用的影响。如果程序试图访问位于已置换到交换空间中的内存页中的数据，那么Linux会短暂地暂停程序，将内存页从交换空间再次置换到物理内存，然后允许程序继续运行，就像数据一直存在于内存中一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr_to memory)</span>;</span><br></pre></td></tr></table></figure><p><code>调用free时使用的指针参数必须是指向由malloc、calloc或realloc调用所分配的内存</code></p><p>请记住：一旦调用free释放了一块内存，它就不再属于这个进程。它将由malloc函数库负责管理。在对一块内存调用free之后，就绝不能再对其进行读写操作了。</p><h4 id="文件锁定"><a href="#文件锁定" class="headerlink" title="文件锁定"></a>文件锁定</h4><p>文件锁定是多用户、多任务操作系统中一一个非常重要的组成部分。程序经常需要共享数据，而这通常是通过文件来实现的。因此，对于这些程序来说，建立某种控制文件的方式就非常重要了。只有这样，文件才可以通过一种安全的方式更新，或者说，当一个程序正在对文件进行写操作时，文件就会进入一个暂时状态，在这个状态下，如果另外一个程序尝试读这个文件，它就会自动停下来等待这个状态的结束。</p><p>第一种方法——<strong>创建锁文件</strong>。Linux提供了多种特性来实现文件锁定。其中最简单的方法就是以原子操作的方式创建锁文件，所谓“原子操作”就是在创建锁文件时，系统将不允许任何其他的事情发生。这就给程序提供了一种方式来确保它所创建的文件是唯一的，而且这个文件不可能被其他程序在同一时刻创建。</p><p>第二种方法——<strong>区域锁定</strong>。这种方法更高级一些，它允许程序锁定文件的一部分，从而可以独享对这一部分内容的访问。有两种不同的方式可以实现第二种形式的文件锁定。将只对其中的一种做详细介绍，因为两种方式非常相似——第二种方式只不过是程序接口稍微不同而己。</p><h5 id="方法一：创建锁文件"><a href="#方法一：创建锁文件" class="headerlink" title="方法一：创建锁文件"></a>方法一：创建锁文件</h5><p>许多应用程序只需要能够针对某个资源创建一个锁文件即可。然后，其他程序就可以通过检查这个文件来判断它们自己是否被允许访问这个资源。</p><p><code>注意，锁文件仅仅只是充当一个指示器的角色，程序间需要通过相互协作来使用它们。用术语来说，锁文件只是建议锁，而不是强制锁，在后者中，系统将强制锁的行为。</code></p><p>为了创建一个用作锁指示器的文件，你可以使用在fcntl.h头文件中定义的open系统调用，并带上O_CREAT和O_EXCL标志。这样能够以一个原子操作同时完成两项工作：确定文件不存在，然后创建它。</p><h5 id="方法二：区域锁定"><a href="#方法二：区域锁定" class="headerlink" title="方法二：区域锁定"></a>方法二：区域锁定</h5><p>用创建锁文件的方法来控制对诸如串行口或不经常访问的文件之类的资源的独占式访问，是一个不错的选择，但它并不适用于访问大型的共享文件。假设你有一个大文件，它由一个程序写入数据，但却由许多不同的程序同时对这个文件进行更新。当一个程序负责记录长期以来连续收集到的数据，而其他一些程序负责对记录的数据进行处理时，这种情况就可能发生。处理程序不能等待记录程序结束，因为记录程序将一直不停地运行，所以它们需要一些协调方法来提供对同一个文件的并发访问。</p><p>你可以通过锁定文件区域的方法来解决这个问题，文件中的某个特定部分被锁定了，但其他程序可以访问这个文件中的其他部分。这被称为文件段锁定或文件区域锁定。Linux提供了至少两种方式来实现这一功能：使用<strong>fcntl系统调用</strong>和使用<strong>lockf调用</strong>。</p><p>我们将主要介绍fcntl接口，因为它是最常使用的接口。lockf和fcntl非常相似，在Linux中，它一般作为fcntl的备选接口。但是，fcntl和lockf的锁定机制不能同时工作：它们使用不同的底层实现，因此决不要混合使用这两种类型的调用，而应坚持使用其中的一种。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fildes, <span class="type">int</span> command, ···)</span>;</span><br></pre></td></tr></table></figure><p>fcntl对一个打开的文件描述符进行操作，并能根据<strong>command</strong>参数的设置完成不同的任务。它为我们提供了3个用于文件锁定的命令选项：F_GETLK、F_SETLK和F_SETLKW。</p><p>当使用这些命令选项时，fcntl的第三个参数必须是一个指向flock结构的指针，所以实际的函数原型应为：<code>int fcntl(int fildes, int command, struct flock *flock_structure);</code></p><p><strong>flock_structure</strong>（文件锁）结构依赖具体的实现，但它至少包含下述成员：</p><ul><li>short l_type</li><li>short l_whence</li><li>off_t l_start</li><li>off_t l_1en</li><li>pid_t l_pid</li></ul><p><strong>l_type</strong>成员的取值定义在头文件fcntl.h中，如表所示。</p><img src="《linux程序设计》阅读笔记/image-20220426113659898.png" alt="image-20220426113659898" style="zoom:67%;" /><p><strong>l_whence</strong>、<strong>l_start</strong>和<strong>l_len</strong>成员定义了文件中的一个区域，即一个连续的字节集合。l_whence的取值必须是SEEK_SET、SEEK_CUR、SEEK END(在头文件unistd.h中定义)中的一个。它们分别对应于文件头、当前位置和文件尾。l_whence定义了l_start的相对偏移值，其中，l_start是该区域的第一个字节。l_whence通常被设为SEEK_SET，这时l_start就从文件的开始计算。l_len参数定义了该区域的字节数。</p><p><strong>l_pid</strong>参数用来记录持有锁的进程。</p><p>文件中的每个字节在任一时刻只能拥有一种类型的锁：共享锁、独占锁或解锁。fcntl调用可用的命令和选项的组合相当多：</p><p><strong>1、F_GETLK命令</strong></p><p>第一个命令是F_GETLK。它用于获取fildes（第一个参数）打开的文件的锁信息。它不会尝试去锁定文件。调用进程把自己想创建的锁类型信息传递给fcntl，使用F_GETLK命令的fcntl就会返回将会阻止获取锁的任何信息。</p><p>flock结构中使用的值如表所示。</p><img src="《linux程序设计》阅读笔记/image-20220426114303526.png" alt="image-20220426114303526" style="zoom:67%;" /><p><strong>2、F_SETLK命令</strong></p><p>这个命令试图对fildes指向的文件的某个区域加锁或解锁。flock结构中使用的值（与F_GETLK命令中用到的不同之处）如表所示。</p><img src="《linux程序设计》阅读笔记/image-20220426114416221.png" alt="image-20220426114416221" style="zoom:67%;" /><p>与F_GETLK一样，要加锁的区域由flock结构中的l_start、l_whence和l_len的值定义。如果加锁成功，fcntl将返回一个非-1的值：如果失败，则返回-1。这个函数总是立刻返回。</p><p><strong>3、F_SETLKW命令</strong></p><p>F_SETLKW命令与上面介绍的FSETLK命令作用相同，但在无法获取锁时，这个调用将等待直到可以为止。一旦这个调用开始等待，只有在可以获取锁或收到一个信号时它才会返回。</p><p><code>程序对某个文件拥有的所有锁都将在相应的文件描述符被关闭时自动清除。在程序结束时也会自动清除各种锁。</code></p><h5 id="其他锁方法"><a href="#其他锁方法" class="headerlink" title="其他锁方法"></a>其他锁方法</h5><p>还有另外一种锁定文件的方法：lockf函数。它也通过文件描述符进行操作。其原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lockf</span><span class="params">(<span class="type">int</span> fildes, <span class="type">int</span> function, <span class="type">off_t</span> size_to_lock)</span>;</span><br></pre></td></tr></table></figure><p><strong>function参数</strong>的取值如下所示。</p><ul><li>F_ULOCK:解锁。</li><li>F_LOCK:设置独占锁。</li><li>F_TLOCK:测试并设置独占锁。</li><li>F_TEST:测试其他进程设置的锁。</li></ul><p><strong>size_to_lock参数</strong>是操作的字节数，它从文件的当前偏移值开始计算。</p><p>lockf有一个比fcntl函数更简单的接口，这主要是因为它在功能性和灵活性上都要比fcntl函数差一些。为了使用这个函数，必须首先搜寻你想锁定的区域的起始位置，然后以要锁定的字节数为参数来调用它。</p><p>与文件锁定的fcntl方法一样，lockf设置的所有锁都是建议锁，它们并不会真正地阻止你读写文件中的数据。对锁的检测是程序的责任。混合使用fcntl锁和lockf锁的效果未被定义，因此你必须决定使用哪种类型的锁定方法并坚持用下去。</p><h5 id="锁定状态下的读写操作"><a href="#锁定状态下的读写操作" class="headerlink" title="锁定状态下的读写操作"></a>锁定状态下的读写操作</h5><p>当对文件区域加锁之后，你必须使用底层的read和write调用来访问文件中的数据，而不要使用更高级的fread和fwrite调用，这是因为fread和fwrite会对读写的数据进行缓存。</p><h5 id="文件锁的竞争"><a href="#文件锁的竞争" class="headerlink" title="文件锁的竞争"></a>文件锁的竞争</h5><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>在讨论锁定时如果未提到死锁的危险，那么这个讨论就不能算是完整的。假设两个程序想要更新同一个文件。它们需要同时更新文件中的字节1和字节2。程序A选择首先更新字节2，然后再更新字节1；程序B则是先更新字节1，然后才是字节2。两个程序同时启动。程序A锁定字节2，而程序B锁定字节1。然后程序A尝试锁定字节1，但因为这个字节已经被程序B锁定，所以程序A将在那里等待。接着程序B尝试锁定字节2，但因为这个字节已经被程序A锁定，所以程序B也将在那里等待。</p><p>这种两个程序都无法继续执行下去的情况，就被称为死锁(deadlock或deadly embrace)。这个问题在数据库应用程序中很常见，当许多用户频繁访问同一个数据时就很容易发生死锁。大多数的商业关系型数据库都能够检测到死锁并自动解开，但Liux内核不行。这时就需要采取一些外部干涉手段，例如强制终止其中一个程序来解决这个问题。</p><p>程序员必须对这种情况提高警惕。当有多个程序都在等待获得锁时，你就需要非常小心地考虑是否会发生死锁。在本例中，死锁是非常容易避免的：两个程序只需要使用相同的顺序来锁定它们需要的字节或锁定一个更大的区域即可。</p><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><h4 id="make和makefile"><a href="#make和makefile" class="headerlink" title="make和makefile"></a>make和makefile</h4><p>多个源文件带来的问题：对于一个含多个头文件的程序，假设只修改其中一个头文件，此时只影响局部包含该头文件的源文件，若希望仅重新编译该部分程序的文件，而不用将整个工程的文件重新编译，可以使用make工具解决该问题。</p><p>makefile文件：make命令内置了很多智能机制，但是需要根据工程编写一个makefile文件来告诉make去构造该工程应用程序的编译。</p><h5 id="makefile语法"><a href="#makefile语法" class="headerlink" title="makefile语法"></a>makefile语法</h5><p>makefile文件由一组<strong>依赖关系和规则</strong>构成。每个依赖关系由一个目标（即将要创建的文件）和一组该目标所依赖的源文件组成。而规则描述了如何通过这些依赖文件创建目标。一般来说，目标是一个单独的可执行文件。</p><p>make命令会读取makefile文件的内容，它先确定目标文件或要创建的文件，然后比较该目标所依赖的源文件的日期和时间以决定该采用哪条规则来构造目标。通常在创建最终的目标文件之前，它需要先创建一些中间目标。make命令会根据makefile文件来确定目标文件的创建顺序以及正确的规则调用顺序。</p><p>make程序本身有许多选项，其中最常用的3个选项如下所示。</p><ul><li>-k: 它的作用是让make命令在发现错误时仍然继续执行，而不是在检测到第一个错误时就停下来。你可以利用这个选项在一次操作中发现所有未编译成功的源文件。</li><li>-n: 它的作用是让make命令输出将要执行的操作步骤，而不真正执行这些操作。</li><li>-f <filename>: 它的作用是告诉make命令将哪个文件作为makefile文件。如果未使用这个选项，标准版本的make命令将首先在当前目录下查找名为makefile的文件，如果该文件不存在，它就会查找名为Makefilel的文件。<code>如果是在Linux系统中，使用的可能是GNU Make，这个版本的make命令将在搜索makefile文件和Makefile文件之前，首先查找名为GNUmakefilel的文件。按惯例，许多Linux程序员使用文件名Makefile，因为如果一个目录下都是以小写字母为名称的文件，则Makefi1e文件将在目录的文件列表中第一个出现。建议不要使用文件名GNUmakefile，因为它是特定于make命令的GNU实现的。</code></li></ul><p>为了指示make命令创建一个特定的目标（通常是一个可执行文件），你可以把该目标的名字作为make命令的一个参数。如果不这么做，make命令将试图创建列在makefile文件中的第一个目标。许多程序员都会在自己的makefile文件中将第一个目标定义为all，然后再列出其他从属目标。这个约定可以明确地告诉make命令，在未指定特定目标时，默认情况下应该创建哪个目标，建议坚持使用这一约定。</p><p><em><strong>1依赖关系</strong></em></p><p>依赖关系定义了最终应用程序里的每个文件与源文件之间的关系。在makefile文件中，这些规则的写法是：先写目标的名称，然后紧跟着一个冒号，接着是空格或制表符tab，最后是用空格或制表符tab隔开的文件列表（这些文件用于创建目标文件）。</p><p>例如下面的示例，表示目标myapp依赖于main.o、2.o和3.o，而main.o依赖于main.c和a.h，等等。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">myapp: main.o 2.o 3.o</span></span><br><span class="line"><span class="section">main.o: main.c a.h</span></span><br><span class="line"><span class="section">2.o: 2.c a.h b.h</span></span><br><span class="line"><span class="section">3.o: 3.c b.h c.h</span></span><br></pre></td></tr></table></figure><p>这组依赖关系形成一个层次结构，它显示了源文件之间的关系。可以很容易地看出，如果文件b.h发生改变，就需重新编译2.o和3.o，而由于2.o和3.o发生了改变，还需要重新创建目标myapp。</p><p>如果想一次创建多个文件，可以利用伪目标all。假设应用程序由二进制文件myapp和使用手册myapp.1组成。可以用下面这行语句进行定义：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: myapp myapp.1</span></span><br></pre></td></tr></table></figure><p>再次强调，如果未指定一个all目标，则make命令将只创建它在文件makefile中找到的第一个目标。</p><p><em><strong>2规则</strong></em></p><p>makefile文件的第二部分内容是规则，它们定义了目标的创建方式。</p><p>对于该部分，空格和制表符tab是有区别的。</p><ul><li>规则所在的行必须以制表符tab开头，用空格是不行的；</li><li>如果makefile文件中的某行以空格结尾，它也可能会导致make命令执行失败；</li><li>如果缺少了制表符tab，make命令就不会正常工作，所以发现这个错误很容易。</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">myapp: main.o 2.o 3.o</span></span><br><span class="line">gcc -o myapp main.o 2.o 3.o</span><br><span class="line"><span class="section">main.o: main.c a.h</span></span><br><span class="line">gcc -c main.c</span><br><span class="line"><span class="section">2.o: 2.c a.h b.h</span></span><br><span class="line">gcc -c 2.c</span><br><span class="line"><span class="section">3.o: 3.c b.h c.h</span></span><br><span class="line">gcc -c 3.c</span><br></pre></td></tr></table></figure><h5 id="makefile注释"><a href="#makefile注释" class="headerlink" title="makefile注释"></a>makefile注释</h5><p>makefile文件中的注释以#号开头，一直延续到这一行的结束。和C语言源文件中的注释一样。</p><h5 id="makefile的宏"><a href="#makefile的宏" class="headerlink" title="makefile的宏"></a>makefile的宏</h5><p><em><strong>问题 1</strong></em></p><p>对于管理包含非常多源文件的大型项目来说，按照上面的makefile构建会显得过于庞大并缺乏弹性。因此，makefile文件允许使用宏，以一种更通用的格式来书写它们。</p><ul><li>通过语句MACRONAME&#x3D;value在makefile文件中定义宏</li><li>引用宏的方法是使用$(MACRONAME)或${MACRONAME}。make的某些版本还接受$MACRONAME的用法。</li><li>如果想把一个宏的值设置为空，可以令等号(&#x3D;)后面留空。</li></ul><p><em><strong>问题 2</strong></em></p><p>Makefilel文件的另一问题是，它假设编译器的名字是gcc，而在其他UNIX系统中，编译器的名字可能是cc或c89。如果想将makefile文件移植到另一版本的UNIX系统中，或在现有系统中使用另一个编译器，为了使其工作，将不得不修改makefile文件中许多行的内容。宏是用来收集所有这些与系统相关内容的好方法，通过使用宏定义，可以方便地修改这些内容。</p><p>宏通常都是在makefile文件中定义的，但也可以在调用make命令时在命令行上给出宏定义，例如命令make CC&#x3D;c89。命令行上的宏定义将覆盖在makefile文件中的宏定义。当在makefile文件之外使用宏定义时，要注意宏定义必须以单个参数的形式传递，所以应避免在宏定义中使用空格或应像下面这样给宏定义加上引号：make “cc&#x3D;c89”。</p><p>示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: myapp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Which compiler</span></span><br><span class="line">CC = gcc</span><br><span class="line"></span><br><span class="line"><span class="comment">#Where are include files kept</span></span><br><span class="line">INCLUDE =</span><br><span class="line"></span><br><span class="line"><span class="comment">#Options for development</span></span><br><span class="line">CFLAGS = -g -Wall -ansi</span><br><span class="line"></span><br><span class="line"><span class="comment">#Options for release</span></span><br><span class="line"><span class="comment">#CFLAGS = -o -Wall -ansi</span></span><br><span class="line"></span><br><span class="line"><span class="section">myapp: main.o 2.o 3.o</span></span><br><span class="line"><span class="variable">$(CC)</span> -o myapp main.o 2.o 3.o</span><br><span class="line"><span class="section">main.o: main.c a.h</span></span><br><span class="line"><span class="variable">$(CC)</span> -I <span class="variable">$(INCLUDE)</span> <span class="variable">$(CFLAGS)</span> -c main.c</span><br><span class="line"><span class="section">2.o: 2.c a.h b.h</span></span><br><span class="line"><span class="variable">$(CC)</span> -I <span class="variable">$(INCLUDE)</span> <span class="variable">$(CFLAGS)</span> -c 2.c</span><br><span class="line"><span class="section">3.o: 3.c b.h c.h</span></span><br><span class="line"><span class="variable">$(CC)</span> -I <span class="variable">$(INCLUDE)</span> <span class="variable">$(CFLAGS)</span> -c 3.c</span><br></pre></td></tr></table></figure><p>make命令内置了一些特殊的宏定义，通过使用它们，可以让makefile文件变得更加简洁：</p><img src="《linux程序设计》阅读笔记/image-20220413204745198.png" alt="image-20220413204745198" style="zoom:67%;" /><p>在makefi1e文件中，可能还会看到下面两个有用的特殊字符，它们出现在命令之前。</p><ul><li>-：告诉make命令忽略所有错误。例如，如果想创建一个目录，但又想忽略任何错误（比如目录已存在），就可以在mkdir命令的前面加上一个减号。</li><li>@: 告诉make在执行某条命令前不要将该命令显示在标准输出上。如果想用echo命令给出一些说明信息，这个字符将非常有用。</li></ul><h5 id="多个目标文件"><a href="#多个目标文件" class="headerlink" title="多个目标文件"></a>多个目标文件</h5><p>通常制作不止一个目标文件或者将多组命令集中到一个位置来执行是很有用的。可以通过扩展makefile文件来达到这一目的。</p><p>下面的例子中在makefile文件中增加一个clean选项来删除不需要的目标文件，增加一个install选项来将编译成功的应用程序安装到另一个目录下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: myapp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Which compiler</span></span><br><span class="line">CC = gcc</span><br><span class="line"></span><br><span class="line"><span class="comment">#####################################################################</span></span><br><span class="line"><span class="comment">#Where to install</span></span><br><span class="line">INSTDIR = /usr/local/bin</span><br><span class="line"><span class="comment">#####################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Where are include files kept</span></span><br><span class="line">INCLUDE =</span><br><span class="line"></span><br><span class="line"><span class="comment">#Options for development</span></span><br><span class="line">CFLAGS = -g -Wall -ansi</span><br><span class="line"></span><br><span class="line"><span class="comment">#Options for release</span></span><br><span class="line"><span class="comment">#CFLAGS = -o -Wall -ansi</span></span><br><span class="line"></span><br><span class="line"><span class="section">myapp: main.o 2.o 3.o</span></span><br><span class="line"><span class="variable">$(CC)</span> -o myapp main.o 2.o 3.o</span><br><span class="line"><span class="section">main.o: main.c a.h</span></span><br><span class="line"><span class="variable">$(CC)</span> -I <span class="variable">$(INCLUDE)</span> <span class="variable">$(CFLAGS)</span> -c main.c</span><br><span class="line"><span class="section">2.o: 2.c a.h b.h</span></span><br><span class="line"><span class="variable">$(CC)</span> -I <span class="variable">$(INCLUDE)</span> <span class="variable">$(CFLAGS)</span> -c 2.c</span><br><span class="line"><span class="section">3.o: 3.c b.h c.h</span></span><br><span class="line"><span class="variable">$(CC)</span> -I <span class="variable">$(INCLUDE)</span> <span class="variable">$(CFLAGS)</span> -c 3.c</span><br><span class="line"></span><br><span class="line"><span class="comment">#####################################################################</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">-rm main.o 2.o 3.o</span><br><span class="line"><span class="section">install: myapp</span></span><br><span class="line">@if [ -d <span class="variable">$(INSTDIR)</span> ];\</span><br><span class="line">then\</span><br><span class="line">cp myapp <span class="variable">$(INSTDIR)</span>;\</span><br><span class="line">chmod a+x <span class="variable">$(INSTDIR)</span>/myapp;\</span><br><span class="line">chmod og-w <span class="variable">$(INSTDIR)</span>/myapp;\</span><br><span class="line">echo <span class="string">&quot;Installed in <span class="variable">$(INSTDIR)</span>&quot;</span>;\</span><br><span class="line"><span class="keyword">else</span>\</span><br><span class="line">echo <span class="string">&quot;Sorry, <span class="variable">$(INSTDIR)</span> does not exist&quot;</span>;\</span><br><span class="line">fi</span><br><span class="line"><span class="comment">##################################################################</span></span><br></pre></td></tr></table></figure><h5 id="内置规则"><a href="#内置规则" class="headerlink" title="内置规则"></a>内置规则</h5><p>事实上，make命令本身带有大量的内置规则，它们可以极大地简化makefile文件的内容，尤其在拥有许多源文件时更是如此。</p><h5 id="后缀和模式规则"><a href="#后缀和模式规则" class="headerlink" title="后缀和模式规则"></a>后缀和模式规则</h5><h5 id="用make管理函数库"><a href="#用make管理函数库" class="headerlink" title="用make管理函数库"></a>用make管理函数库</h5><p>对于大型项目，一种比较方便的做法是用函数库来管理多个编译产品。函数库实际上就是文件，它们通常以。a(a是英文archive的首字母)为后缀名，在该文件中包含了一组目标文件。make命令用一个特殊的语法来处理函数库，这使得函数库的管理工作变得非常容易。</p><p>用于管理函数库的语法是lib(file.o),它的含义是目标文件file.o是存储在函数库lib.a中的。make命令用一个内置规则来管理函数库，该规则的常见形式如下所示：</p><h5 id="makefile文件和子目录"><a href="#makefile文件和子目录" class="headerlink" title="makefile文件和子目录"></a>makefile文件和子目录</h5><p>对于大型的项目，有时希望能把构成一个函数库的几个文件从主文件中分离出来，并将它们保存到一个子目录中。使用make命令完成这一工作的方法有两个。</p><p>第一个方法是，可以在子目录中编写出第二个makefile文件，它的作用是编译该子目录下的源文件，并将它们保存到一个函数库中，然后将该库文件复制到上一级的主目录中。在主目录中的makefile文件包含一条用于制作函数库的规则，该规则会调用第二个makefile.文件，如下所示：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mylib.a:</span></span><br><span class="line">(cd mylibdirectory;<span class="variable">$(MAKE)</span>)</span><br></pre></td></tr></table></figure><p>​</p><p>这就是说，你必须总是执行命令make mylib.a。当make命令调用这条规则来创建函数库时，它将切换到子目录mylibdirectory中，然后调用一个新的make命令来管理函数库。由于make会针对每个命令调用一个新的shell,而使用第二个makefile文件的make命令本身又并没有执行cd命令，但它又必须在一个不同的目录下创建函数库，为解决这一问题，我们用括号将这两个命令括起来，从而确保它们只被一个单独的shell处理。</p><p>第二个方法是，在原来的makefile文件中添加一些宏。新添加的宏通过在我们己见过的宏的尾部追加一个字母得到，字母D代表目录，字母F代表文件名。然后你就可以用下面的规则来替换内置的.c.o后缀规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">.c.o:</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c $(@D) /$(&lt;F) -o $(@D)/$(@F)</span><br></pre></td></tr></table></figure><p>这条规则的作用是：编译子目录中的源文件并将目标文件放在该子目录中。然后，你用如下的依赖关系和规则来更新当前目录下的函数库：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mylib.a: mydir/2.o mydir/3.o</span></span><br><span class="line">ar -rv mylib.a <span class="variable">$?</span></span><br></pre></td></tr></table></figure><h5 id="GNU-make和gcc"><a href="#GNU-make和gcc" class="headerlink" title="GNU make和gcc"></a>GNU make和gcc</h5>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-基础命令使用</title>
      <link href="/2024/02/26/linux-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/02/26/linux-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux系统基础"><a href="#Linux系统基础" class="headerlink" title="Linux系统基础"></a>Linux系统基础</h2><p>资料：<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/index.html">https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/index.html</a></p><h3 id="0-Linux帮助命令"><a href="#0-Linux帮助命令" class="headerlink" title="0.Linux帮助命令"></a>0.Linux帮助命令</h3><p>在linux终端，面对命令不知道怎么用，或不记得命令的拼写及参数时，我们需要求助于系统的帮助文档； linux系统内置的帮助文档很详细，通常能解决我们的问题，我们需要掌握如何正确的去使用它们；</p><ul><li>在只记得部分命令关键字的场合，我们可通过<strong>man -k</strong>来搜索；</li><li>需要知道某个命令的简要说明，可以使用<strong>whatis</strong>；而更详细的介绍，则可用<strong>info</strong>命令；</li><li>查看命令在哪个位置，我们需要使用<strong>which</strong>；</li><li>而对于命令的具体参数及使用方法，我们需要用到强大的<strong>man</strong>；</li></ul><h4 id="whatis与info命令"><a href="#whatis与info命令" class="headerlink" title="whatis与info命令"></a>whatis与info命令</h4><p>简要说明命令的作用（显示命令所处的man分类页面）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$whatis command</span><br></pre></td></tr></table></figure><p>正则匹配:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$whatis -w &quot;loca*&quot;</span><br></pre></td></tr></table></figure><p>更加详细的说明文档:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$info command</span><br></pre></td></tr></table></figure><h4 id="man命令"><a href="#man命令" class="headerlink" title="man命令"></a>man命令</h4><p>查询命令command的说明文档:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$man command</span><br><span class="line">eg：man date</span><br></pre></td></tr></table></figure><p>使用page up和page down来上下翻页。</p><p>在man的帮助手册中，将帮助文档分为了9个类别，对于有的关键字可能存在多个类别中， 我们就需要指定特定的类别来查看；（一般我们查询bash命令，归类在1类中）；</p><p>man页面所属的分类标识(常用的是分类1和分类3)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(1)、用户可以操作的命令或者是可执行文件</span><br><span class="line">(2)、系统核心可调用的函数与工具等</span><br><span class="line">(3)、一些常用的函数与数据库</span><br><span class="line">(4)、设备文件的说明</span><br><span class="line">(5)、设置文件或者某些文件的格式</span><br><span class="line">(6)、游戏</span><br><span class="line">(7)、惯例与协议等。例如Linux标准文件系统、网络协议、ASCⅡ，码等说明内容</span><br><span class="line">(8)、系统管理员可用的管理条令</span><br><span class="line">(9)、与内核有关的文件</span><br></pre></td></tr></table></figure><p>前面说到使用whatis会显示命令所在的具体的文档类别，我们学习如何使用它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">$whatis printf</span><br><span class="line">printf               (1)  - format and print data</span><br><span class="line">printf               (1p)  - write formatted output</span><br><span class="line">printf               (3)  - formatted output conversion</span><br><span class="line">printf               (3p)  - print formatted output</span><br><span class="line">printf [builtins]    (1)  - bash built-in commands, see bash(1)</span><br></pre></td></tr></table></figure><p>我们看到printf在分类1和分类3中都有；分类1中的页面是命令操作及可执行文件的帮助；而3是常用函数库说明；如果我们想看的是C语言中printf的用法，可以指定查看分类3的帮助：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$man 3 printf</span><br><span class="line"></span><br><span class="line">$man -k keyword</span><br></pre></td></tr></table></figure><p>查询关键字 根据命令中部分关键字来查询命令，适用于只记住部分命令的场合；</p><p>eg：查找GNOME的config配置工具命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$man -k GNOME config| grep 1</span><br></pre></td></tr></table></figure><p>对于某个单词搜索，可直接使用&#x2F;word来使用: &#x2F;-a; 多关注下SEE ALSO 可看到更多精彩内容</p><h4 id="which与whereis命令"><a href="#which与whereis命令" class="headerlink" title="which与whereis命令"></a>which与whereis命令</h4><p>查看程序的binary文件所在路径:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$which command</span><br></pre></td></tr></table></figure><p>eg:查找make程序安装路径:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$which make</span><br><span class="line">/opt/app/openav/soft/bin/make install</span><br></pre></td></tr></table></figure><p>查看程序的搜索路径:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$whereis command</span><br></pre></td></tr></table></figure><p>当系统中安装了同一软件的多个版本时，不确定使用的是哪个版本时，这个命令就能派上用场；</p><h3 id="1-文件及目录管理"><a href="#1-文件及目录管理" class="headerlink" title="1.文件及目录管理"></a>1.文件及目录管理</h3><h4 id="文件创建、删除和修改"><a href="#文件创建、删除和修改" class="headerlink" title="文件创建、删除和修改"></a>文件创建、删除和修改</h4><ul><li><p>创建新文件（夹）：touch、mkdir</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建新文件</span></span><br><span class="line">touch 新文件名1 新文件名2...</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建新文件夹</span></span><br><span class="line">mkdir 新文件夹1 新文件夹2...</span><br></pre></td></tr></table></figure></li><li><p>删除：rm、rmdir</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除文件</span></span><br><span class="line">rm 文件名1 文件名2...</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除空文件夹</span></span><br><span class="line">rmdir 空文件夹名1 空文件夹名2...</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除整个文件夹，包含里面所有内容</span></span><br><span class="line">rm -rf 文件夹名1 文件夹名2...</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除日志</span> </span><br><span class="line">rm \*log (等价: $find ./ -name “*log” -exec rm &#123;&#125; ;)</span><br></pre></td></tr></table></figure></li><li><p>移动和重命名：mv</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">移动文件</span></span><br><span class="line">mv 文件名 目标路径</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">移动文件夹，需在文件夹名后面加<span class="string">&#x27;/&#x27;</span></span></span><br><span class="line">mv 文件夹名/ 目标路径</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重命名文件/文件夹</span></span><br><span class="line">mv 原文件名/文件夹名 新文件名/文件夹名</span><br></pre></td></tr></table></figure></li><li><p>复制：cp (cp -r )</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">复制文件</span></span><br><span class="line">cp 待复制文件(夹)名 目标路径</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">复制文件夹，文件夹名后加<span class="string">&#x27;/&#x27;</span></span></span><br><span class="line">cp 带复制文件夹名/ 目标路径</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">若含子文件夹则需加-r</span></span><br><span class="line">cp -r 带复制文件夹名/ 目标路径</span><br></pre></td></tr></table></figure></li></ul><h4 id="文件颜色"><a href="#文件颜色" class="headerlink" title="文件颜色"></a>文件颜色</h4><p><strong>颜色–详解：</strong></p><p>绿色文件———-可执行文件，可执行的程序</p><p>红色文件———–压缩文件或者包文件</p><p>蓝色文件———-目录   </p><p>白色文件———-普通，如文本文件，配置文件，源码文件等</p><p>浅蓝色文件———-链接文件，主要是使用ln命令建立的文件</p><p>红色闪烁———-表示链接的文件有问题</p><p>黄色文件———-表示设备文件</p><p>灰色文件———-表示其它文件</p><h4 id="目录显示及切换"><a href="#目录显示及切换" class="headerlink" title="目录显示及切换"></a>目录显示及切换</h4><h5 id="目录内容显示"><a href="#目录内容显示" class="headerlink" title="目录内容显示"></a>目录内容显示</h5><ul><li>显示当前目录下的文件 ls</li><li>按时间排序，以列表的方式显示目录项 ls -lrt</li><li>显示当前目录路径：pwd</li></ul><h5 id="目录切换"><a href="#目录切换" class="headerlink" title="目录切换"></a>目录切换</h5><ul><li>找到文件&#x2F;目录位置：cd</li><li>切换到上一个工作目录： cd -</li><li>切换到home目录： cd or cd ~</li><li>显示当前路径: pwd</li><li>更改当前工作路径为path: cd path</li></ul><h4 id="查找目录及文件名-find"><a href="#查找目录及文件名-find" class="headerlink" title="查找目录及文件名 find"></a>查找目录及文件名 find</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.按文件名</span></span><br><span class="line">find 路径 -name &quot;文件名&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">搜寻文件或目录:</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">find ./ -name <span class="string">&quot;core*&quot;</span> | xargs file</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查找目标文件夹中是否有obj文件:</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">find ./ -name <span class="string">&#x27;*.o&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.按文件类型</span></span><br><span class="line">find 路径 -type 类型</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">类型：普通文件f、目录d、符号链接l、块设备文件b、字符设备文件c、socket文件s、管道文件p</span></span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3.按照文件大小</span></span><br><span class="line">find 路径 -size 范围</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">范围：+表示大于        -表示小于        等于不需要符号</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">大小：M(必须大写)        k(必须小写)        c(表示字符)</span></span><br><span class="line">find / -size +0k -size -10k</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4.按照文件日期</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">按照创建日期查找</span></span><br><span class="line">find 路径 -ctime -n/+n#-n:n天以内，+n：n天以外</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">按照修改日期查找</span></span><br><span class="line">find 路径 -mtime -n/+n</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">按照访问日期查找</span></span><br><span class="line">find 路径 -atime -n/+n</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5.高级查找</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-<span class="built_in">exec</span></span></span><br><span class="line">find 路径 查找方式 -exec shell命令 &#123;&#125; \;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">递归当前目录及子目录删除所有.o文件:</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">find ./ -name <span class="string">&quot;*.o&quot;</span> -<span class="built_in">exec</span> <span class="built_in">rm</span> &#123;&#125; \;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-ok，该方法与-<span class="built_in">exec</span>相比更加安全，其存在确认过程</span></span><br><span class="line">find 路径 查找方式 -ok shell命令 &#123;&#125; \;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">管道方式</span></span><br><span class="line">find 路径 查找方式 | xargs shell命令</span><br></pre></td></tr></table></figure><h4 id="文件定位locate"><a href="#文件定位locate" class="headerlink" title="文件定位locate"></a>文件定位locate</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">find是实时查找，如果需要更快的查询，可试试locate；locate会为文件系统建立索引数据库，如果有文件更新，需要定期执行更新命令来更新索引库:</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">updatedb</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">寻找包含有string的路径:</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">locate string</span></span><br></pre></td></tr></table></figure><h4 id="文件内容查看及查找"><a href="#文件内容查看及查找" class="headerlink" title="文件内容查看及查找"></a>文件内容查看及查找</h4><h5 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看文件：<span class="built_in">cat</span> vi <span class="built_in">head</span> <span class="built_in">tail</span> more</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示时同时显示行号:</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">cat</span> -n</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">按页显示列表内容:</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">ls</span> -al | more</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">只看前10行:</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">head</span> - 10 **</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示文件第一行:</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">head</span> -1 filename</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示文件倒数第五行:</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">tail</span> -5 filename</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看两个文件间的差别:</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">diff file1 file2</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">动态显示文本最新信息:</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">tail</span> -f crawler.log</span></span><br></pre></td></tr></table></figure><h5 id="查找文件内容grep-egrep"><a href="#查找文件内容grep-egrep" class="headerlink" title="查找文件内容grep&#x2F;egrep"></a>查找文件内容grep&#x2F;egrep</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">grep查找</span></span><br><span class="line">grep 参数 &quot;内容&quot; 查找目录或文件</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">参数：</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-r 若是目录，则可以递归查找</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-n:可以显示该查找内容所在的行号</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-i:可以忽略大小写进行查找</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-v:不显示含有某字符串</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">grep和find命令结合使用</span></span><br><span class="line">find ./ -name &quot;*.cpp&quot; | xargs grep -n &quot;main&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">egrep支持更多扩展，使用egrep查询文件内容:</span></span><br><span class="line">egrep &#x27;03.1\/CO\/AE&#x27; TSF_STAT_111130.log.012</span><br><span class="line">egrep &#x27;A_LMCA777:C&#x27; TSF_STAT_111130.log.035 &gt; co.out2</span><br></pre></td></tr></table></figure><h4 id="文件权限及修改"><a href="#文件权限及修改" class="headerlink" title="文件权限及修改"></a>文件权限及修改</h4><h5 id="1、命令ls"><a href="#1、命令ls" class="headerlink" title="1、命令ls"></a><strong>1、命令ls</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">默认只显示可见文件名称，-a显示所有文件，-l显示可见文件的权限</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示所有文件及权限</span></span><br><span class="line">ls -al</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显示指定文件的权限</span></span><br><span class="line">ls 指定文件名 -l</span><br></pre></td></tr></table></figure><h5 id="2、权限内容"><a href="#2、权限内容" class="headerlink" title="2、权限内容"></a><strong>2、权限内容</strong></h5><p><img src="/linux-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/image-20220528152129627.png" alt="image-20220528152129627"></p><p>权限结构：设备类型+所属用户权限+所属组权限+其他用户权限。</p><p>第一位为<strong>设备类型</strong>。各类型如下：</p><ul><li><code>-rw-rw-r--</code>-:普通文件</li><li><code>crw-rw----</code>c:字符设备</li><li><code>brw-rw----</code>b:块设备</li><li><code>drwxrwxr-x</code>d:目录文件</li><li><code>srw-rw-r--</code>s:套接字</li><li><code>lrwxrwxrwx</code>l：连接文件（软连接）</li></ul><p>后面每三位为一组权限，顺序依次为”所属用户权限+所属组权限+其他用户权限“。</p><ul><li>r：读</li><li>w：写</li><li>x：可执行</li></ul><h5 id="3、权限修改"><a href="#3、权限修改" class="headerlink" title="3、权限修改"></a><strong>3、权限修改</strong></h5><ul><li>改变文件的拥有者 chown</li><li>改变文件读、写、执行等属性 chmod</li><li>递归子目录修改： chown -R tuxapp source&#x2F;</li><li>增加脚本可执行权限： chmod a+x myscript</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改文件权限。7转化成二进制位111，表示rw权限；三个7则一次表示所属用户、组及其他用户权限。</span></span><br><span class="line">chmod 777 文件名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">改变文件所属用户</span></span><br><span class="line">chown 用户名 文件名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">改变文件所属组</span></span><br><span class="line">chown .组 文件名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">改变文件所属用户及组</span></span><br><span class="line">chown 用户名 .组 文件名</span><br></pre></td></tr></table></figure><h4 id="给文件增加别名"><a href="#给文件增加别名" class="headerlink" title="给文件增加别名"></a>给文件增加别名</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">硬连接；删除一个，将仍能找到；</span></span><br><span class="line">ln cc ccAgain </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">符号链接(软链接)；删除源，另一个无法使用；（后面一个ccTo 为新建的文件）</span></span><br><span class="line">ln -s cc ccTo </span><br></pre></td></tr></table></figure><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><ul><li>批处理命令连接执行，使用 |</li><li>串联: 使用分号 ;</li><li>前面成功，则执行后面一条，否则，不执行:&amp;&amp;</li><li>前面失败，则后一条执行: ||</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls /proc &amp;&amp; echo  suss! || echo failed.</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">与上述相同效果的是:</span></span><br><span class="line">if ls /proc; then echo suss; else echo fail; fi</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.&gt; 和 &gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&gt;是重定向(覆盖)到一个文件，&gt;&gt;是追加内容到一个文件.如果文件不存在，那么这两个命令都会首先创建这个文件。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2. 1&gt; 和 2&gt;</span>  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1&gt; 将正确的输出重定向到某个文件;2&gt; 将错误的输出重定向到某个文件</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将错误输出和正确输出保存到同一个文件：</span></span><br><span class="line">command 1&gt; a.txt 2&gt;&amp;1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或者</span></span><br><span class="line">command &gt; a.txt 2&gt;&amp;1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3.1&gt;&gt; 和 2&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将错误的和正确的信息重定向追加到同一个文件</span></span><br><span class="line">command 1&gt;&gt; a.txt 2&gt;&amp;1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">正确的结果想追加，错误的结果覆盖。</span></span><br><span class="line">command 1&gt;&gt; right.txt 2&gt; wrong.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4.&lt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">&lt; 可以将原本由标准输入改为由指定地方输入</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">建一个hh文件，里面写入hello world</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行 &gt;&gt; txt.py &lt; hh，就可以把hh里面的内容写入到txt.py</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">清空文件:</span></span><br><span class="line">:&gt; a.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动帐号后自动执行的是 文件为 .profile，然后通过这个文件可设置自己的环境变量；安装的软件路径一般需要加入到path中:</span></span><br><span class="line">PATH=$APPDIR:/opt/app/soft/bin:$PATH:/usr/local/bin:$TUXDIR/bin:$ORACLE_HOME/bin;export PATH</span><br></pre></td></tr></table></figure><h4 id="Bash快捷输入或删除"><a href="#Bash快捷输入或删除" class="headerlink" title="Bash快捷输入或删除"></a>Bash快捷输入或删除</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">快捷键:</span><br><span class="line">Ctl-U   删除光标到行首的所有字符,在某些设置下,删除全行</span><br><span class="line">Ctl-W   删除当前光标到前边的最近一个空格之间的字符</span><br><span class="line">Ctl-H   backspace,删除光标前边的字符</span><br><span class="line">Ctl-R   匹配最相近的一个文件，然后输出</span><br></pre></td></tr></table></figure><h4 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h4><p>查找record.log中包含AAA，但不包含BBB的记录的总数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -v record.log | grep AAA | grep -v BBB | wc -l</span><br></pre></td></tr></table></figure><p>总结</p><h3 id="2-文本处理"><a href="#2-文本处理" class="headerlink" title="2.文本处理"></a>2.文本处理</h3><h4 id="find-文件查找"><a href="#find-文件查找" class="headerlink" title="find 文件查找"></a>find 文件查找</h4><h5 id="一般搜索"><a href="#一般搜索" class="headerlink" title="一般搜索"></a>一般搜索</h5><p>查找txt和pdf文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \) -print</span><br></pre></td></tr></table></figure><p>正则方式查找.txt和pdf:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -regex  &quot;.*\(\.txt|\.pdf\)$&quot;</span><br></pre></td></tr></table></figure><p>-iregex： 忽略大小写的正则</p><p>否定参数 ,查找所有非txt文本:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . ! -name &quot;*.txt&quot; -print</span><br></pre></td></tr></table></figure><p>指定搜索深度,打印出当前目录的文件（深度为1）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -maxdepth 1 -type f</span><br></pre></td></tr></table></figure><h5 id="定制搜索"><a href="#定制搜索" class="headerlink" title="定制搜索"></a>定制搜索</h5><ul><li>按类型搜索</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type d -print  //只列出所有目录</span><br></pre></td></tr></table></figure><p>-type f 文件 &#x2F; l 符号链接 &#x2F; d 目录</p><p>find支持的文件检索类型可以区分普通文件和符号链接、目录等，但是二进制文件和文本文件无法直接通过find的类型区分出来；</p><p>file命令可以检查文件具体类型（二进制或文本）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$file redis-cli  # 二进制文件</span><br><span class="line">redis-cli: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.9, not stripped</span><br><span class="line">$file redis.pid  # 文本文件</span><br><span class="line">redis.pid: ASCII text</span><br></pre></td></tr></table></figure><p>所以,可以用以下命令组合来实现查找本地目录下的所有二进制文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lrt | awk &#x27;&#123;print $9&#125;&#x27;|xargs file|grep  ELF| awk &#x27;&#123;print $1&#125;&#x27;|tr -d &#x27;:&#x27;</span><br></pre></td></tr></table></figure><p>按时间搜索</p><pre><code>-atime 访问时间 (单位是天，分钟单位则是-amin，以下类似）-mtime 修改时间 （内容被修改）-ctime 变化时间 （元数据或权限变化）</code></pre><p>最近第7天被访问过的所有文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -atime 7 -type f -print</span><br></pre></td></tr></table></figure><p>最近7天内被访问过的所有文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -atime -7 -type f -print</span><br></pre></td></tr></table></figure><p>查询7天前被访问过的所有文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -atime +7 type f -print</span><br></pre></td></tr></table></figure><ul><li>按大小搜索：</li></ul><p>w字 k M G 寻找大于2k的文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -size +2k</span><br></pre></td></tr></table></figure><p>按权限查找:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -perm 644 -print //找具有可执行权限的所有文件</span><br></pre></td></tr></table></figure><p>按用户查找:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -user weber -print// 找用户weber所拥有的文件</span><br></pre></td></tr></table></figure><h5 id="找到后的后续动作"><a href="#找到后的后续动作" class="headerlink" title="找到后的后续动作"></a>找到后的后续动作</h5><ul><li>删除</li></ul><p>删除当前目录下所有的swp文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -name &quot;*.swp&quot; -delete</span><br></pre></td></tr></table></figure><p>另一种语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . type f -name &quot;*.swp&quot; | xargs rm</span><br></pre></td></tr></table></figure><ul><li>执行动作（强大的exec）</li></ul><p>将当前目录下的所有权变更为weber:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -user root -exec chown weber &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>注：{}是一个特殊的字符串，对于每一个匹配的文件，{}会被替换成相应的文件名；</p><p>将找到的文件全都copy到另一个目录:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -mtime +10 -name &quot;*.txt&quot; -exec cp &#123;&#125; OLD \;</span><br></pre></td></tr></table></figure><ul><li>结合多个命令</li></ul><p>如果需要后续执行多个命令，可以将多个命令写成一个脚本。然后 -exec 调用时执行脚本即可:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-exec ./commands.sh &#123;&#125; \;</span><br></pre></td></tr></table></figure><h5 id="print的定界符"><a href="#print的定界符" class="headerlink" title="-print的定界符"></a>-print的定界符</h5><p>默认使用’\n’作为文件的定界符；</p><p>-print0 使用’\0’作为文件的定界符，这样就可以搜索包含空格的文件；</p><h4 id="grep-文本搜索"><a href="#grep-文本搜索" class="headerlink" title="grep 文本搜索"></a>grep 文本搜索</h4><h4 id="xargs-命令行参数转换"><a href="#xargs-命令行参数转换" class="headerlink" title="xargs 命令行参数转换"></a>xargs 命令行参数转换</h4><h4 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort 排序"></a>sort 排序</h4><h4 id="uniq-消除重复行"><a href="#uniq-消除重复行" class="headerlink" title="uniq 消除重复行"></a>uniq 消除重复行</h4><h4 id="用tr进行转换"><a href="#用tr进行转换" class="headerlink" title="用tr进行转换"></a>用tr进行转换</h4><h4 id="cut-按列切分文本"><a href="#cut-按列切分文本" class="headerlink" title="cut 按列切分文本"></a>cut 按列切分文本</h4><h4 id="paste-按列拼接文本"><a href="#paste-按列拼接文本" class="headerlink" title="paste 按列拼接文本"></a>paste 按列拼接文本</h4><h4 id="wc-统计行和字符的工具"><a href="#wc-统计行和字符的工具" class="headerlink" title="wc 统计行和字符的工具"></a>wc 统计行和字符的工具</h4><h4 id="sed-文本替换利器"><a href="#sed-文本替换利器" class="headerlink" title="sed 文本替换利器"></a>sed 文本替换利器</h4><h4 id="awk-数据流处理工具"><a href="#awk-数据流处理工具" class="headerlink" title="awk 数据流处理工具"></a>awk 数据流处理工具</h4><h4 id="迭代文件中的行、单词和字符"><a href="#迭代文件中的行、单词和字符" class="headerlink" title="迭代文件中的行、单词和字符"></a>迭代文件中的行、单词和字符</h4><ol><li>迭代文件中的每一行<br> 2.迭代一行中的每一个单词</li><li>迭代每一个字符</li></ol><h3 id="3-磁盘管理"><a href="#3-磁盘管理" class="headerlink" title="3.磁盘管理"></a>3.磁盘管理</h3><h4 id="查看磁盘空间"><a href="#查看磁盘空间" class="headerlink" title="查看磁盘空间"></a>查看磁盘空间</h4><p>查看磁盘空间利用大小:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure><p>-h: human缩写，以易读的方式显示结果（即带单位：比如M&#x2F;G，如果不加这个参数，显示的数字以B为单位）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">df</span> -h</span></span><br><span class="line"><span class="meta prompt_">/opt/app/todeav/config#</span><span class="language-bash"><span class="built_in">df</span> -h</span></span><br><span class="line">Filesystem            Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/VolGroup00-LogVol00</span><br><span class="line">2.0G  711M  1.2G  38% /</span><br><span class="line">/dev/mapper/vg1-lv2    20G  3.8G   15G  21% /opt/applog</span><br><span class="line">/dev/mapper/vg1-lv1    20G   13G  5.6G  70% /opt/app</span><br></pre></td></tr></table></figure><p>查看当前目录所占空间大小:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh</span><br></pre></td></tr></table></figure><ul><li>-h 人性化显示</li><li>-s 递归整个目录的大小</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$du -sh</span><br><span class="line">653M</span><br></pre></td></tr></table></figure><p>查看当前目录下所有子文件夹排序后的大小:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in `ls`; do du -sh $i; done | sort</span><br><span class="line">或者：</span><br><span class="line">du -sh `ls` | sort</span><br></pre></td></tr></table></figure><h4 id="打包-压缩"><a href="#打包-压缩" class="headerlink" title="打包&#x2F; 压缩"></a>打包&#x2F; 压缩</h4><p>在linux中打包和压缩和分两步来实现的；</p><p><strong>打包</strong></p><p>打包是将多个文件归并到一个文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf etc.tar /etc &lt;==仅打包，不压缩！</span><br></pre></td></tr></table></figure><ul><li>-c :打包选项</li><li>-v :显示打包进度</li><li>-f :使用档案文件</li></ul><p>注：有的系统中指定参数时不需要在前面加上-，直接使用tar xvf</p><p>示例：用tar实现文件夹同步，排除部分文件不同步:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar --exclude &#x27;*.svn&#x27; -cvf - /path/to/source | ( cd /path/to/target; tar -xf -)</span><br></pre></td></tr></table></figure><p><strong>压缩</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$gzip demo.txt</span><br></pre></td></tr></table></figure><p>生成 demo.txt.gz</p><h4 id="解包-解压缩"><a href="#解包-解压缩" class="headerlink" title="解包&#x2F;解压缩"></a>解包&#x2F;解压缩</h4><p><strong>解包</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf demo.tar</span><br></pre></td></tr></table></figure><p>-x 解包选项</p><p>若解压后缀为 .tar.gz的文件，则分两步：</p><p> 1 先解压缩，生成**.tar:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$gunzip    demo.tar.gz</span><br></pre></td></tr></table></figure><p>2 解包:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$tar -xvf  demo.tar</span><br><span class="line">$bzip2 -d demo.tar.bz2</span><br></pre></td></tr></table></figure><p>bz2解压:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar jxvf demo.tar.bz2</span><br></pre></td></tr></table></figure><p>如果tar 不支持j，则同样需要分两步来解包解压缩，使用bzip2来解压，再使用tar解包:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bzip2 -d  demo.tar.bz2</span><br><span class="line">tar -xvf  demo.tar</span><br></pre></td></tr></table></figure><p>-d decompose,解压缩</p><p>tar解压参数说明：</p><ul><li>-z 解压gz文件</li><li>-j 解压bz2文件</li><li>-J 解压xz文件</li></ul><h3 id="4-进程管理"><a href="#4-进程管理" class="headerlink" title="4.进程管理"></a>4.进程管理</h3><h4 id="查询进程"><a href="#查询进程" class="headerlink" title="查询进程"></a>查询进程</h4><p>查询正在运行的进程信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ps -ef</span><br></pre></td></tr></table></figure><p>eg:查询归属于用户colin115的进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ps -ef | grep colin115</span><br><span class="line">$ps -lu colin115</span><br></pre></td></tr></table></figure><p>查询进程ID（适合只记得部分进程字段）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$pgrep 查找进程</span><br><span class="line"></span><br><span class="line">eg:查询进程名中含有re的进程</span><br><span class="line">[/home/weber#]pgrep -l re</span><br><span class="line">2 kthreadd</span><br><span class="line">28 ecryptfs-kthrea</span><br><span class="line">29515 redis-server</span><br></pre></td></tr></table></figure><p>以完整的格式显示所有的进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ps -ajx</span><br></pre></td></tr></table></figure><p>显示进程信息，并实时更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$top</span><br></pre></td></tr></table></figure><p>查看端口占用的进程状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i:3306</span><br></pre></td></tr></table></figure><p>查看用户username的进程所打开的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$lsof -u username</span><br></pre></td></tr></table></figure><p>查询init进程当前打开的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$lsof -c init</span><br></pre></td></tr></table></figure><p>查询指定的进程ID(23295)打开的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$lsof -p 23295</span><br></pre></td></tr></table></figure><p>查询指定目录下被进程开启的文件（使用+D 递归目录）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$lsof +d mydir1/</span><br></pre></td></tr></table></figure><h4 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h4><p>杀死指定PID的进程 (PID为Process ID)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$kill PID</span><br></pre></td></tr></table></figure><p>杀死相关进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 3434</span><br></pre></td></tr></table></figure><p>杀死job工作 (job为job number)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$kill %job</span><br></pre></td></tr></table></figure><h4 id="进程监控"><a href="#进程监控" class="headerlink" title="进程监控"></a>进程监控</h4><p>查看系统中使用CPU、使用内存最多的进程；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$top</span><br><span class="line">(-&gt;)P</span><br></pre></td></tr></table></figure><p>输入top命令后，进入到交互界面；接着输入字符命令后显示相应的进程状态：</p><p>对于进程，平时我们最常想知道的就是哪些进程占用CPU最多，占用内存最多。以下两个命令就可以满足要求:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P：根据CPU使用百分比大小进行排序。</span><br><span class="line">M：根据驻留内存大小进行排序。</span><br><span class="line">i：使top不显示任何闲置或者僵死进程。</span><br></pre></td></tr></table></figure><h4 id="分析线程栈"><a href="#分析线程栈" class="headerlink" title="分析线程栈"></a>分析线程栈</h4><p>使用命令pmap，来输出进程内存的状况，可以用来分析线程堆栈；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$pmap PID</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">[/home/weber#]ps -fe| grep redis</span><br><span class="line">weber    13508 13070  0 08:14 pts/0    00:00:00 grep --color=auto redis</span><br><span class="line">weber    29515     1  0  2013 ?        02:55:59 ./redis-server redis.conf</span><br><span class="line">[/home/weber#]pmap 29515</span><br><span class="line">29515:   ./redis-server redis.conf</span><br><span class="line">08048000    768K r-x--  /home/weber/soft/redis-2.6.16/src/redis-server</span><br><span class="line">08108000      4K r----  /home/weber/soft/redis-2.6.16/src/redis-server</span><br><span class="line">08109000     12K rw---  /home/weber/soft/redis-2.6.16/src/redis-server</span><br></pre></td></tr></table></figure><h4 id="综合运用"><a href="#综合运用" class="headerlink" title="综合运用"></a>综合运用</h4><p>将用户colin115下的所有进程名以av_开头的进程终止:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -u colin115 |  awk &#x27;/av_/ &#123;print &quot;kill -9 &quot; $1&#125;&#x27; | sh</span><br></pre></td></tr></table></figure><p>将用户colin115下所有进程名中包含HOST的进程终止:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -fe| grep colin115|grep HOST |awk &#x27;&#123;print $2&#125;&#x27; | xargs kill -9;</span><br></pre></td></tr></table></figure><h3 id="5-性能监控工具"><a href="#5-性能监控工具" class="headerlink" title="5.性能监控工具"></a>5.性能监控工具</h3><h4 id="监控CPU"><a href="#监控CPU" class="headerlink" title="监控CPU"></a>监控CPU</h4><p>查看CPU使用率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$sar -u</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">$sar -u 1 2</span><br><span class="line">[/home/weber#]sar -u 1 2</span><br><span class="line">Linux 2.6.35-22-generic-pae (MyVPS)     06/28/2014      _i686_  (1 CPU)</span><br><span class="line"></span><br><span class="line">09:03:59 AM     CPU     %user     %nice   %system   %iowait    %steal     %idle</span><br><span class="line">09:04:00 AM     all      0.00      0.00      0.50      0.00      0.00     99.50</span><br><span class="line">09:04:01 AM     all      0.00      0.00      0.00      0.00      0.00    100.00</span><br></pre></td></tr></table></figure><p>后面的两个参数表示监控的频率，比如例子中的1和2，表示每秒采样一次，总共采样2次；</p><p>查看CPU平均负载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sar -q 1 2</span><br></pre></td></tr></table></figure><p>sar指定-q后，就能查看运行队列中的进程数、系统上的进程大小、平均负载等；</p><h4 id="查询内存"><a href="#查询内存" class="headerlink" title="查询内存"></a>查询内存</h4><p>查看内存使用状况 sar指定-r之后，可查看内存使用状况;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$sar -r 1 2</span><br><span class="line">09:08:48 AM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact</span><br><span class="line">09:08:49 AM     17888    359784     95.26     37796     73272    507004     65.42    137400    150764</span><br><span class="line">09:08:50 AM     17888    359784     95.26     37796     73272    507004     65.42    137400    150764</span><br><span class="line">Average:        17888    359784     95.26     37796     73272    507004     65.42    137400    150764</span><br></pre></td></tr></table></figure><p>查看内存使用量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$free -m</span><br></pre></td></tr></table></figure><h4 id="查询页面交换"><a href="#查询页面交换" class="headerlink" title="查询页面交换"></a>查询页面交换</h4><p>查看页面交换发生状况 页面发生交换时，服务器的吞吐量会大幅下降；服务器状况不良时，如果怀疑因为内存不足而导致了页面交换的发生，可以使用sar -W这个命令来确认是否发生了大量的交换；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sar -W 1 3</span><br></pre></td></tr></table></figure><h4 id="查询硬盘使用"><a href="#查询硬盘使用" class="headerlink" title="查询硬盘使用"></a>查询硬盘使用</h4><p>查看磁盘空间利用情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$df -h</span><br></pre></td></tr></table></figure><p>查询当前目录下空间使用情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh  -h是人性化显示 s是递归整个目录的大小</span><br></pre></td></tr></table></figure><p>查看该目录下所有文件夹的排序后的大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in `ls`; do du -sh $i; done | sort</span><br><span class="line">或者</span><br><span class="line">du -sh `ls`</span><br></pre></td></tr></table></figure><h4 id="综合应用-1"><a href="#综合应用-1" class="headerlink" title="综合应用"></a>综合应用</h4><p>当系统中sar不可用时，可以使用以下工具替代：linux下有 vmstat、Unix系统有prstat</p><p>eg： 查看cpu、内存、使用情况： vmstat n m （n 为监控频率、m为监控次数）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[/home/weber#]vmstat 1 3</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ----cpu----</span><br><span class="line">r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa</span><br><span class="line">0  0  86560  42300   9752  63556    0    1     1     1    0    0  0  0 99  0</span><br><span class="line">1  0  86560  39936   9764  63544    0    0     0    52   66   95  5  0 95  0</span><br><span class="line">0  0  86560  42168   9772  63556    0    0     0    20  127  231 13  2 84  0</span><br></pre></td></tr></table></figure><p>使用watch 工具监控变化 当需要持续的监控应用的某个数据变化时，watch工具能满足要求； 执行watch命令后，会进入到一个界面，输出当前被监控的数据，一旦数据变化，便会高亮显示变化情况；</p><p>eg：操作redis时，监控内存变化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$watch -d -n 1 &#x27;./redis-cli info | grep memory&#x27;</span><br><span class="line">(以下为watch工具中的界面内容，一旦内存变化，即实时高亮显示变化）</span><br><span class="line">Every 1.0s: ./redis-cli info | grep memory                                                                  Mon Apr 28 16:10:36 2014</span><br><span class="line"></span><br><span class="line">used_memory:45157376</span><br><span class="line">used_memory_human:43.07M</span><br><span class="line">used_memory_rss:47628288</span><br><span class="line">used_memory_peak:49686080</span><br><span class="line">used_memory_peak_human:47.38M</span><br></pre></td></tr></table></figure><h3 id="6-网络工具"><a href="#6-网络工具" class="headerlink" title="6.网络工具"></a>6.网络工具</h3><h4 id="查询网络服务和端口"><a href="#查询网络服务和端口" class="headerlink" title="查询网络服务和端口"></a>查询网络服务和端口</h4><p>netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。</p><p>列出所有端口 (包括监听和未监听的):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -a</span><br></pre></td></tr></table></figure><p>列出所有 tcp 端口:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -at</span><br></pre></td></tr></table></figure><p>列出所有有监听的服务状态:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -l</span><br></pre></td></tr></table></figure><p>使用netstat工具查询端口:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$netstat -antp | grep 6379</span><br><span class="line">tcp        0      0 127.0.0.1:6379          0.0.0.0:*               LISTEN      25501/redis-server</span><br><span class="line"></span><br><span class="line">$ps 25501</span><br><span class="line">  PID TTY      STAT   TIME COMMAND</span><br><span class="line">25501 ?        Ssl   28:21 ./redis-server ./redis.conf</span><br></pre></td></tr></table></figure><p>lsof（list open files）是一个列出当前系统打开文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等； 在查询网络端口时，经常会用到这个工具。</p><p>查询7902端口现在运行什么程序:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#分为两步</span><br><span class="line">#第一步，查询使用该端口的进程的PID；</span><br><span class="line">    $lsof -i:7902</span><br><span class="line">    COMMAND   PID   USER   FD   TYPE    DEVICE SIZE NODE NAME</span><br><span class="line">    WSL     30294 tuapp    4u  IPv4 447684086       TCP 10.6.50.37:tnos-dp (LISTEN)</span><br><span class="line"></span><br><span class="line">#查到30294</span><br><span class="line">#使用ps工具查询进程详情：</span><br><span class="line">$ps -fe | grep 30294</span><br><span class="line">tdev5  30294 26160  0 Sep10 ?        01:10:50 tdesl -k 43476</span><br><span class="line">root     22781 22698  0 00:54 pts/20   00:00:00 grep 11554</span><br></pre></td></tr></table></figure><h4 id="网络路由"><a href="#网络路由" class="headerlink" title="网络路由"></a>网络路由</h4><p>查看路由状态:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$route -n</span><br></pre></td></tr></table></figure><p>发送ping包到地址IP:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ping IP</span><br></pre></td></tr></table></figure><p>探测前往地址IP的路由路径:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$traceroute IP</span><br></pre></td></tr></table></figure><p>DNS查询，寻找域名domain对应的IP:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$host domain</span><br></pre></td></tr></table></figure><p>反向DNS查询:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$host IP</span><br></pre></td></tr></table></figure><h4 id="镜像下载"><a href="#镜像下载" class="headerlink" title="镜像下载"></a>镜像下载</h4><p>直接下载文件或者网页:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget url</span><br></pre></td></tr></table></figure><p>常用选项:</p><ul><li>–limit-rate :下载限速</li><li>-o：指定日志文件；输出都写入日志；</li><li>-c：断点续传</li></ul><h4 id="ftp-sftp-lftp-ssh"><a href="#ftp-sftp-lftp-ssh" class="headerlink" title="ftp&#x2F;sftp&#x2F;lftp&#x2F;ssh"></a>ftp&#x2F;sftp&#x2F;lftp&#x2F;ssh</h4><p>SSH登陆:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ssh ID@host</span><br></pre></td></tr></table></figure><p>ssh登陆远程服务器host，ID为用户名。</p><p>ftp&#x2F;sftp文件传输:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sftp ID@host</span><br></pre></td></tr></table></figure><p>登陆服务器host，ID为用户名。sftp登陆后，可以使用下面的命令进一步操作：</p><ul><li>get filename # 下载文件</li><li>put filename # 上传文件</li><li>ls # 列出host上当前路径的所有文件</li><li>cd # 在host上更改当前路径</li><li>lls # 列出本地主机上当前路径的所有文件</li><li>lcd # 在本地主机更改当前路径</li></ul><p>lftp同步文件夹(类似rsync工具):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lftp -u user:pass host</span><br><span class="line">lftp user@host:~&gt; mirror -n</span><br></pre></td></tr></table></figure><h4 id="网络复制"><a href="#网络复制" class="headerlink" title="网络复制"></a>网络复制</h4><p>将本地localpath指向的文件上传到远程主机的path路径:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$scp localpath ID@host:path</span><br></pre></td></tr></table></figure><p>以ssh协议，遍历下载path路径下的整个文件系统，到本地的localpath:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$scp -r ID@site:path localpath</span><br></pre></td></tr></table></figure><h3 id="7-用户管理工具"><a href="#7-用户管理工具" class="headerlink" title="7.用户管理工具"></a>7.用户管理工具</h3><h4 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h4><h5 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$useradd -m username</span><br></pre></td></tr></table></figure><p>该命令为用户创建相应的帐号和用户目录&#x2F;home&#x2F;username；</p><p>用户添加之后，设置密码：</p><p>密码以交互方式创建:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$passwd username</span><br></pre></td></tr></table></figure><h5 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$userdel -r username</span><br></pre></td></tr></table></figure><p>不带选项使用 userdel，只会删除用户。用户的家目录将仍会在&#x2F;home目录下。要完全的删除用户信息，使用-r选项；</p><p>帐号切换 登录帐号为userA用户状态下，切换到userB用户帐号工作:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$su userB</span><br></pre></td></tr></table></figure><p>进入交互模型，输入密码授权进入；</p><h4 id="用户的组"><a href="#用户的组" class="headerlink" title="用户的组"></a>用户的组</h4><h5 id="将用户加入到组"><a href="#将用户加入到组" class="headerlink" title="将用户加入到组"></a>将用户加入到组</h5><p>默认情况下，添加用户操作也会相应的增加一个同名的组，用户属于同名组； 查看当前用户所属的组:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$groups</span><br></pre></td></tr></table></figure><p>一个用户可以属于多个组，将用户加入到组:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$usermod -G groupNmame username</span><br></pre></td></tr></table></figure><p>变更用户所属的根组(将用加入到新的组，并从原有的组中除去）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$usermod -g groupName username</span><br></pre></td></tr></table></figure><h5 id="查看系统所有组"><a href="#查看系统所有组" class="headerlink" title="查看系统所有组"></a>查看系统所有组</h5><p>系统的所有用户及所有组信息分别记录在两个文件中：&#x2F;etc&#x2F;passwd , &#x2F;etc&#x2F;group 默认情况下这两个文件对所有用户可读：</p><p>查看所有用户及权限:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$more /etc/passwd</span><br></pre></td></tr></table></figure><p>查看所有的用户组及权限:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$more /etc/group</span><br></pre></td></tr></table></figure><h4 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h4><p>使用ls -l可查看文件的属性字段，文件属性字段总共有10个字母组成，第一个字母表示文件类型，如果这个字母是一个减号”-”,则说明该文件是一个普通文件。字母”d”表示该文件是一个目录，字母”d”,是dirtectory(目录)的缩写。 后面的9个字母为该文件的权限标识，3个为一组，分别表示文件所属用户、用户所在组、其它用户的读写和执行权限； 例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[/home/weber#]ls -l /etc/group</span><br><span class="line">-rwxrw-r-- colin king 725 2013-11-12 15:37 /home/colin/a</span><br></pre></td></tr></table></figure><p>表示这个文件对文件拥有者colin这个用户可读写、可执行；对colin所在的组（king）可读可写；对其它用户只可读；</p><h5 id="更改读写权限"><a href="#更改读写权限" class="headerlink" title="更改读写权限"></a>更改读写权限</h5><p>使用chmod命令更改文件的读写权限，更改读写权限有两种方法，一种是字母方式，一种是数字方式</p><p>字母方式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$chmod userMark(+|-)PermissionsMark</span><br></pre></td></tr></table></figure><p>userMark取值：</p><ul><li>u：用户</li><li>g：组</li><li>o：其它用户</li><li>a：所有用户</li></ul><p>PermissionsMark取值：</p><ul><li>r:读</li><li>w：写</li><li>x：执行</li></ul><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$chmod a+x main         对所有用户给文件main增加可执行权限</span><br><span class="line">$chmod g+w blogs        对组用户给文件blogs增加可写权限</span><br></pre></td></tr></table></figure><p>数字方式：</p><p>数字方式直接设置所有权限，相比字母方式，更加简洁方便；</p><p>使用三位八进制数字的形式来表示权限，第一位指定属主的权限，第二位指定组权限，第三位指定其他用户的权限，每位通过4(读)、2(写)、1(执行)三种数值的和来确定权限。如6(4+2)代表有读写权，7(4+2+1)有读、写和执行的权限。</p><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$chmod 740 main     将main的用户权限设置为rwxr-----</span><br></pre></td></tr></table></figure><h5 id="更改文件或目录的拥有者"><a href="#更改文件或目录的拥有者" class="headerlink" title="更改文件或目录的拥有者"></a>更改文件或目录的拥有者</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$chown username dirOrFile</span><br></pre></td></tr></table></figure><p>使用-R选项递归更改该目下所有文件的拥有者:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$chown -R weber server/</span><br></pre></td></tr></table></figure><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>bashrc与profile都用于保存用户的环境信息，bashrc用于交互式non-loginshell，而profile用于交互式login shell。</p><p>&#x2F;etc&#x2F;profile，&#x2F;etc&#x2F;bashrc 是系统全局环境变量设定</p><p><del>&#x2F;.profile，</del>&#x2F;.bashrc用户目录下的私有环境变量设定</p><p>当登入系统获得一个shell进程时，其读取环境设置脚本分为三步:</p><ol><li>首先读入的是全局环境变量设置文件&#x2F;etc&#x2F;profile，然后根据其内容读取额外的文档，如&#x2F;etc&#x2F;profile.d和&#x2F;etc&#x2F;inputrc</li><li>读取当前登录用户Home目录下的文件<del>&#x2F;.bash_profile，其次读取</del>&#x2F;.bash_login，最后读取~&#x2F;.profile，这三个文档设定基本上是一样的，读取有优先关系</li><li>读取~&#x2F;.bashrc</li></ol><p><del>&#x2F;.profile与</del>&#x2F;.bashrc的区别:</p><ul><li>这两者都具有个性化定制功能</li><li>~&#x2F;.profile可以设定本用户专有的路径，环境变量，等，它只能登入的时候执行一次</li><li>~&#x2F;.bashrc也是某用户专有设定文档，可以设定路径，命令别名，每次shell script的执行都会使用它一次</li></ul><p>例如，我们可以在这些环境变量中设置自己经常进入的文件路径，以及命令的快捷方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.bashrc</span><br><span class="line">alias m=&#x27;more&#x27;</span><br><span class="line">alias cp=&#x27;cp -i&#x27;</span><br><span class="line">alias mv=&#x27;mv -i&#x27;</span><br><span class="line">alias ll=&#x27;ls -l&#x27;</span><br><span class="line">alias lsl=&#x27;ls -lrt&#x27;</span><br><span class="line">alias lm=&#x27;ls -al|more&#x27;</span><br><span class="line"></span><br><span class="line">log=/opt/applog/common_dir</span><br><span class="line">unit=/opt/app/unittest/common</span><br><span class="line"></span><br><span class="line">.bash_profile</span><br><span class="line">. /opt/app/tuxapp/openav/config/setenv.prod.sh.linux</span><br><span class="line">export PS1=&#x27;$PWD#&#x27;</span><br></pre></td></tr></table></figure><p>通过上述设置，我们进入log目录就只需要输入cd $log即可；</p><h3 id="8-系统管理及IPC资源管理"><a href="#8-系统管理及IPC资源管理" class="headerlink" title="8.系统管理及IPC资源管理"></a>8.系统管理及IPC资源管理</h3><h4 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h4><h5 id="查询系统版本"><a href="#查询系统版本" class="headerlink" title="查询系统版本"></a>查询系统版本</h5><p>查看Linux系统版本:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$uname -a</span><br><span class="line">$lsb_release -a</span><br></pre></td></tr></table></figure><p>查看Unix系统版本：操作系统版本:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$more /etc/release</span><br></pre></td></tr></table></figure><h5 id="查询硬件信息"><a href="#查询硬件信息" class="headerlink" title="查询硬件信息"></a>查询硬件信息</h5><p>查看CPU使用情况:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sar -u 5 10</span><br></pre></td></tr></table></figure><p>查询CPU信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$cat /proc/cpuinfo</span><br></pre></td></tr></table></figure><p>查看CPU的核的个数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$cat /proc/cpuinfo | grep processor | wc -l</span><br></pre></td></tr></table></figure><p>查看内存信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$cat /proc/meminfo</span><br></pre></td></tr></table></figure><p>显示内存page大小（以KByte为单位）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$pagesize</span><br></pre></td></tr></table></figure><p>显示架构:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$arch</span><br></pre></td></tr></table></figure><h5 id="设置系统时间"><a href="#设置系统时间" class="headerlink" title="设置系统时间"></a>设置系统时间</h5><p>显示当前系统时间:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$date</span><br></pre></td></tr></table></figure><p>设置系统日期和时间(格式为2014-09-15 17:05:00):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$date -s 2014-09-15 17:05:00</span><br><span class="line">$date -s 2014-09-15</span><br><span class="line">$date -s 17:05:00</span><br></pre></td></tr></table></figure><p>设置时区:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">选择时区信息。命令为：tzselect</span><br><span class="line">根据系统提示，选择相应的时区信息。</span><br></pre></td></tr></table></figure><p>强制把系统时间写入CMOS（这样，重启后时间也正确了）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$clock -w</span><br></pre></td></tr></table></figure><p>显示当前系统时间:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$date</span><br></pre></td></tr></table></figure><p>设置系统日期和时间(格式为2014-09-15 17:05:00):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$date -s 2014-09-15 17:05:00</span><br><span class="line">$date -s 2014-09-15</span><br><span class="line">$date -s 17:05:00</span><br></pre></td></tr></table></figure><p>设置时区:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">选择时区信息。命令为：tzselect</span><br><span class="line">根据系统提示，选择相应的时区信息。</span><br></pre></td></tr></table></figure><p>强制把系统时间写入CMOS（这样，重启后时间也正确了）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$clock -w</span><br></pre></td></tr></table></figure><h4 id="IPC资源管理"><a href="#IPC资源管理" class="headerlink" title="IPC资源管理"></a>IPC资源管理</h4><h5 id="IPC资源查询"><a href="#IPC资源查询" class="headerlink" title="IPC资源查询"></a>IPC资源查询</h5><p>查看系统使用的IPC资源:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ipcs</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status</span><br><span class="line"></span><br><span class="line">------ Semaphore Arrays --------</span><br><span class="line">key        semid      owner      perms      nsems</span><br><span class="line">0x00000000 229376     weber      600        1</span><br><span class="line"></span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages</span><br></pre></td></tr></table></figure><p>查看系统使用的IPC共享内存资源:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ipcs -m</span><br></pre></td></tr></table></figure><p>查看系统使用的IPC队列资源:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ipcs -q</span><br></pre></td></tr></table></figure><p>查看系统使用的IPC信号量资源:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ipcs -s</span><br></pre></td></tr></table></figure><p>应用示例：查看IPC资源被谁占用</p><p>有个IPCKEY：51036 ，需要查询其是否被占用；</p><ol><li><ul><li><p>首先通过计算器将其转为十六进制:</p><p>   51036 -&gt; c75c</p></li></ul></li><li><p>如果知道是被共享内存占用:</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ipcs -m | grep c75c</span><br><span class="line">0x0000c75c 40403197   tdea3    666        536870912  2</span><br></pre></td></tr></table></figure></li><li><p>如果不确定，则直接查找:</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ipcs | grep c75c</span><br><span class="line">0x0000c75c 40403197   tdea3    666        536870912  2</span><br><span class="line">0x0000c75c 5079070    tdea3    666        4</span><br></pre></td></tr></table></figure></li></ol><h5 id="检测和设置系统资源限制"><a href="#检测和设置系统资源限制" class="headerlink" title="检测和设置系统资源限制"></a>检测和设置系统资源限制</h5><p>显示当前所有的系统资源limit 信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit – a</span><br></pre></td></tr></table></figure><p>对生成的 core 文件的大小不进行限制:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit – c unlimited</span><br></pre></td></tr></table></figure><h3 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h3><h4 id="tar工具"><a href="#tar工具" class="headerlink" title="tar工具"></a>tar工具</h4><p>在Linux平台，tar是主要的打包工具。tar命令通常用来把文件和目录压缩为一个文件（ tarball 或 tar, gzip 和 bzip）。</p><p><strong>Tar选项：</strong></p><ul><li>c – 创建压缩文件</li><li>x – 解压文件</li><li>v – 显示进度.</li><li>f – 文件名.</li><li>t – 查看压缩文件内容.</li><li>j – 通过bzip2归档</li><li>z –通过gzip归档</li><li>r – 在压缩文件中追加文件或目录</li><li>W – 验证压缩文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解压后文件名为原压缩包名字</span></span><br><span class="line">tar xvf 压缩包</span><br></pre></td></tr></table></figure><h4 id="locate定位文件"><a href="#locate定位文件" class="headerlink" title="locate定位文件"></a>locate定位文件</h4><p>linux会把系统内所有的文件都记录在一个数据库文件中，使用locate+文件名的方法会在linux系统维护的这个数据库中去查找目标，相比find命令去遍历磁盘查找的方式，效率会高很多，比较推荐使用这种方法。</p><p>因为该数据库默认是一天更新一次的，所有使用locate命令有可能<strong>找不到最近新建的文件</strong>。这时就需要手动更新数据库,命令很简单，直接在终端中输入sudo updatedb就可以进行更新，更新速度还是比较快的，所以在搜索文件的时候建议使用locate命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate 文件名</span><br></pre></td></tr></table></figure><h4 id="dd工具"><a href="#dd工具" class="headerlink" title="dd工具"></a>dd工具</h4><p><strong>dd命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=xxx of=xxx bs=num seek=num</span><br></pre></td></tr></table></figure><p>dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。注意：指定数字的地方若如下列字符结尾，则乘以相应的数字：b&#x3D;512；c&#x3D;1；k&#x3D;1024；w&#x3D;2。</p><p><strong>参数注释：</strong></p><ol><li>if&#x3D;文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if&#x3D;input file &gt;</li><li>of&#x3D;文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of&#x3D;output file &gt;</li><li>ibs&#x3D;bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。<br> obs&#x3D;bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。<br> bs&#x3D;bytes：同时设置读入&#x2F;输出的块大小为bytes个字节。</li><li>cbs&#x3D;bytes：一次转换bytes个字节，即指定转换缓冲区大小。</li><li>skip&#x3D;blocks：从输入文件开头跳过blocks个块后再开始复制。</li><li>seek&#x3D;blocks：从输出文件开头跳过blocks个块后再开始复制。<br> 注意：一般只用当输出文件是磁盘或磁带时才有效，即备份到磁盘或磁带时才有效。</li><li>count&#x3D;blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。</li><li>conv&#x3D;conversion：用指定的参数转换文件。<br> ascii：转换ebcdic为ascii<br>  ebcdic：转换ascii为ebcdic<br> ibm：转换ascii为alternate ebcdic<br> block：把每一行转换为长度为cbs，不足部分用空格填充<br> unblock：使每一行的长度都为cbs，不足部分用空格填充<br> lcase：把大写字符转换为小写字符<br> ucase：把小写字符转换为大写字符<br> swab：交换输入的每对字节<br>  noerror：出错时不中止<br>  notrunc：不截短输出文件<br> sync：将每一个输入块填充到ibs个字节，不足部分用空（NUL）字符补齐。</li></ol><p><strong>&#x2F;dev&#x2F;null和&#x2F;dev&#x2F;zero的区别</strong></p><p>&#x2F;dev&#x2F;null是一个伪文件，可以看做”黑洞”， 它等价于一个只写文件，全部写入它的内容都会永远丢失，而尝试从它那儿读取内容则什么也读不到。</p><p>&#x2F;dev&#x2F;zero是一个输入设备，该设备无穷尽地提供0，主要的用处是用来建立一个指定长度用于初始化的空文件，就像临时交换文件，可以用它来初始化文件。 </p><h4 id="wget工具"><a href="#wget工具" class="headerlink" title="wget工具"></a>wget工具</h4><p>wget是一个从网络上自动下载文件的自由工具。它支持HTTP，HTTPS和FTP协议，可以使用HTTP代理。</p><p>简单用法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://地址</span><br></pre></td></tr></table></figure><h4 id="回收站"><a href="#回收站" class="headerlink" title="回收站"></a>回收站</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">trash-empty 清空回收站</span><br><span class="line">trash-empty days 删除回收站里面超过指定天数的文件</span><br><span class="line">foo文件会被放入回收站(trashcan)</span><br><span class="line">trash-list 列出回收站里面的文件</span><br><span class="line">restore-trash 恢复指定的文件</span><br></pre></td></tr></table></figure><h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><h5 id="查看系统版本命令："><a href="#查看系统版本命令：" class="headerlink" title="查看系统版本命令："></a>查看系统版本命令：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure><h5 id="Ubuntu系统扩容"><a href="#Ubuntu系统扩容" class="headerlink" title="Ubuntu系统扩容"></a>Ubuntu系统扩容</h5><p>参考：<a href="https://blog.csdn.net/Lem0n_Tree/article/details/120705140">https://blog.csdn.net/Lem0n_Tree/article/details/120705140</a></p><ol><li><a href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&spm=1001.2101.3001.7020">虚拟机</a>修改磁盘大小，查看磁盘</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk -l</span><br></pre></td></tr></table></figure><p><img src="/linux-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATGVtbl9UcmVl,size_20,color_FFFFFF,t_70,g_se,x_16-1708953089999.png" alt="watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATGVtbl9UcmVl,size_20,color_FFFFFF,t_70,g_se,x_16-1708953089999"></p><p>从上图看到，磁盘容量已经识别为100G，但<a href="https://so.csdn.net/so/search?q=%E5%88%86%E5%8C%BA%E8%A1%A8&spm=1001.2101.3001.7020">分区表</a>记录的容量仍然是50G（红色字体提示)</p><ol start="2"><li>修复分区表</li></ol><p>查看分区情况，会立即提示空间未全部使用，提示输入Fix修复分区表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo parted -l</span><br></pre></td></tr></table></figure><p><img src="/linux-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATGVtbl9UcmVl,size_20,color_FFFFFF,t_70,g_se,x_16-16557150543131.png" alt="watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATGVtbl9UcmVl,size_20,color_FFFFFF,t_70,g_se,x_16-16557150543131"></p><ol start="3"><li>扩容分区</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cfdisk</span><br></pre></td></tr></table></figure><p>上下选中要扩容的分区，左右选择<strong>Resize</strong>后回车，会自动填写可用的总容量，也可以手动写入扩容后的总容量，回车后选择<strong>Write</strong>再次回车保存，退出。</p><p><img src="/linux-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATGVtbl9UcmVl,size_20,color_FFFFFF,t_70,g_se,x_16-16557150543142.png" alt="watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATGVtbl9UcmVl,size_20,color_FFFFFF,t_70,g_se,x_16-16557150543142"></p><p>这里是分配99G全部</p><p><img src="/linux-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATGVtbl9UcmVl,size_20,color_FFFFFF,t_70,g_se,x_16-16557150543143.png" alt="watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATGVtbl9UcmVl,size_20,color_FFFFFF,t_70,g_se,x_16-16557150543143"></p><p>保存输入<strong>yes</strong>后按<strong>q</strong>退出</p><p><img src="/linux-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATGVtbl9UcmVl,size_20,color_FFFFFF,t_70,g_se,x_16-16557150543154.png" alt="watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATGVtbl9UcmVl,size_20,color_FFFFFF,t_70,g_se,x_16-16557150543154"></p><ol start="4"><li>扩容文件系统</li></ol><p>此时可看到磁盘已经扩容，但文件系统大小仍然是扩容前的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pvs</span><br><span class="line">lsblk</span><br></pre></td></tr></table></figure><p><img src="/linux-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATGVtbl9UcmVl,size_20,color_FFFFFF,t_70,g_se,x_16-16557150543165.png" alt="watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATGVtbl9UcmVl,size_20,color_FFFFFF,t_70,g_se,x_16-16557150543165"></p><p>重置pv大小，再次查看大小容量已经变为更新了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo pvresize /dev/sda3</span><br><span class="line">sudo pvs</span><br><span class="line">sudo pvdisplay</span><br><span class="line"><span class="comment">#显示存在的卷组</span></span><br><span class="line">sudo vgdisplay </span><br></pre></td></tr></table></figure><p><img src="/linux-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATGVtbl9UcmVl,size_19,color_FFFFFF,t_70,g_se,x_16.png" alt="watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATGVtbl9UcmVl,size_19,color_FFFFFF,t_70,g_se,x_16"></p><p>free空间分配</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo lvextend -l +100%free /dev/mapper/ubuntu--vg-ubuntu--lv</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><img src="/linux-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/732635170d50411db2493b1446534a9c.png" alt="732635170d50411db2493b1446534a9c"></p><p>更新文件系统，查看已经成功扩容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo resize2fs /dev/mapper/ubuntu--vg-ubuntu--lv</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><img src="/linux-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATGVtbl9UcmVl,size_20,color_FFFFFF,t_70,g_se,x_16-16557150543166-1708953418502.png" alt="watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBATGVtbl9UcmVl,size_20,color_FFFFFF,t_70,g_se,x_16-16557150543166-1708953418502"></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
